<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Red-Black Tree - Changhoi Kim</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="white"><meta name="application-name" content="Changhoi Kim"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="white"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Changhoi Kim"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="알고리즘 문제를 해결하다가, 이중 우선순위 큐 문제를 만났다. 문제 시간 제한이 6초라고 되어있길래, Binary Search Tree(BST)로 구현하려고, HashMap을 사용했다. 다만 만든 트리 구조가 최악의 경우 더하는 연산이 O(n)이기 때문에, 시간 초과가 났다. AVL이 생각이 났는데, 어떻게 구현하는지를 알지 못해 알아보던 도중 자바에 Tr"><meta property="og:type" content="blog"><meta property="og:title" content="Red-Black Tree"><meta property="og:url" content="https://changhoi.kim/posts/etc/red-black-tree/"><meta property="og:site_name" content="Changhoi Kim"><meta property="og:description" content="알고리즘 문제를 해결하다가, 이중 우선순위 큐 문제를 만났다. 문제 시간 제한이 6초라고 되어있길래, Binary Search Tree(BST)로 구현하려고, HashMap을 사용했다. 다만 만든 트리 구조가 최악의 경우 더하는 연산이 O(n)이기 때문에, 시간 초과가 났다. AVL이 생각이 났는데, 어떻게 구현하는지를 알지 못해 알아보던 도중 자바에 Tr"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://www.adexchanger.com/wp-content/uploads/2021/05/coding.jpg"><meta property="article:published_time" content="2021-06-30T15:00:00.000Z"><meta property="article:modified_time" content="2021-06-30T15:00:00.000Z"><meta property="article:author" content="changhoi"><meta property="article:tag" content="data_structure"><meta property="article:tag" content="algorithm"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.adexchanger.com/wp-content/uploads/2021/05/coding.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://changhoi.kim/posts/etc/red-black-tree/"},"headline":"Red-Black Tree","image":["https://www.adexchanger.com/wp-content/uploads/2021/05/coding.jpg"],"datePublished":"2021-06-30T15:00:00.000Z","dateModified":"2021-06-30T15:00:00.000Z","author":{"@type":"Person","name":"changhoi"},"publisher":{"@type":"Organization","name":"Changhoi Kim","logo":{"@type":"ImageObject","url":"https://changhoi.kim/img/logo.jpg"}},"description":"알고리즘 문제를 해결하다가, 이중 우선순위 큐 문제를 만났다. 문제 시간 제한이 6초라고 되어있길래, Binary Search Tree(BST)로 구현하려고, HashMap을 사용했다. 다만 만든 트리 구조가 최악의 경우 더하는 연산이 O(n)이기 때문에, 시간 초과가 났다. AVL이 생각이 났는데, 어떻게 구현하는지를 알지 못해 알아보던 도중 자바에 Tr"}</script><link rel="canonical" href="https://changhoi.kim/posts/etc/red-black-tree/"><link rel="alternate" href="/rss2.xml" title="Changhoi Kim" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-QBSLW6WTZW" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-QBSLW6WTZW');</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://www.adexchanger.com/wp-content/uploads/2021/05/coding.jpg" alt="Red-Black Tree"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-06-30T15:00:00.000Z" title="2021. 6. 30. 오전 8:00:00">2021-07-01</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-06-30T15:00:00.000Z" title="2021. 6. 30. 오전 8:00:00">2021-07-01</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/etc/">etc</a></span><span class="level-item">24분안에 읽기 (약 3561 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">Red-Black Tree</h1><div class="content"><p>알고리즘 문제를 해결하다가, <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.acmicpc.net/problem/7662">이중 우선순위 큐</a> 문제를 만났다. 문제 시간 제한이 6초라고 되어있길래, Binary Search Tree(BST)로 구현하려고, <code>HashMap</code>을 사용했다. 다만 만든 트리 구조가 최악의 경우 더하는 연산이 O(n)이기 때문에, 시간 초과가 났다. AVL이 생각이 났는데, 어떻게 구현하는지를 알지 못해 알아보던 도중 자바에 TreeMap 구조가 Red-Black Tree(RBT)라는 걸 알게되었다. TreeMap 이전에 RBT를 더 자세히 공부하고 싶어 위키트리 내용을 최대한 풀어서 정리했다.</p>
<span id="more"></span>

<h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p>RBT는 자료의 추가, 삭제, 검색에서 최악의 경우도 일정한 Worst Case를 보장한다. 이런 특성은, 실행 시간이 중요한 경우, 일정 시간 실행을 보장해야 하는 경우 등 유용하게 쓰인다. 앞서 생각했던 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://ko.wikipedia.org/wiki/AVL_%ED%8A%B8%EB%A6%AC">AVL Tree</a>는 균형에 대한 더 엄격한 기준이 있어서, 삽입과 삭제시 더 많은 회전이 필요하다 (균형을 위한)</p>
<h2 id="특성"><a href="#특성" class="headerlink" title="특성"></a>특성</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png?style=centerme"></p>
<p>RBT는 각각의 노드가 레드, 블랙 속성을 가지고 있는 BST이다. BST의 조건에 추가적으로 다음과 같은 조건을 만족해야 한다.</p>
<ol>
<li>노드는 레드 또는 블랙이다.</li>
<li>루트 노드는 블랙이다.</li>
<li>모든 리프 노드들(NIL)은 블랙이다.</li>
<li>레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다. 즉, 레드 노드는 연달아 나타날 수 없고, 블랙 노드만 레드 노드의 부모 노드가 될 수 있다.</li>
<li>어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.</li>
</ol>
<p>네 번째, 다섯 번째 속성때문에, 극단적인 최단 경로의 경우 블랙 노드만 존재하는 경우이고, 극단적인 최장 경로의 경우 레드와 블랙 노드가 섞여 나오는 경우이다. 이 경우를 가정했을 때에도, 최단 경로와 최장 경로의 차이는 최단 경로의 두 배보다 항상 작다.</p>
<h2 id="동작"><a href="#동작" class="headerlink" title="동작"></a>동작</h2><p>일단, 읽기 작업은 일반적인 BST처럼 진행하면 된다. 다만, 삭제와 삽입은 위 특성을 만족시키기 위해 추가적인 작업이 필요하다. 아래는 위키피디아에서 설명하는 알고리즘을 본인이 읽기 쉽게 정리한 내용이다. 사용된 이미지도, 위키피디아에서 가져왔다.</p>
<h3 id="삽입"><a href="#삽입" class="headerlink" title="삽입"></a>삽입</h3><p>RBT에서 삽입은, BST의 삽입과 동일한 방식으로 우선 삽입 후, 색을 붉은 색으로 만든다. 그 다음 단계는 그 주위 노드의 색에 따라 다르다. RBT에서는 <code>삼촌노드(uncle node)</code>에 대한 개념이 나온다. 부모 노드의 형제 노드를 뜻한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUncle</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">getGrandparent</span>(node);</span><br><span class="line">    <span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="literal">undefined</span>;    <span class="comment">// 할아버지 노드가 없으면, 형제노드는 당연히 없다.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> uncle = g.<span class="property">left</span> === node.<span class="property">parent</span> ? g.<span class="property">right</span> : g.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">return</span> uncle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 다음 삽입하는 경우의 수를 살펴보자.</p>
<ul>
<li><p>처음 루트에 N이 삽입될 때<br>이 경우, RBT의 첫 번째 속성을 위해 N은 검은색이 된다. 그 이후는 RBT가 유지된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertCase1</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node.<span class="property">parent</span>) node.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">insertCase2</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>새로운 노드의 부모 노드가 검은색인 경우<br>이 경우도 RBT가 유지된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertCase2</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">parent</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="title function_">insertCase3</span>(node);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>부모 노드와 삼촌 노드가 모두 붉은색인 경우<br>레드 블랙 트리의 다섯 번째 특성을 유지하기 위해서 부모 P와 삼촌 U를 검은색으로 바꾸고, 할아버지 G를 붉은 색으로 바꾼다. 이렇게 되면, 새로 추가되는 노드 N은 검은 부모를 갖게 된다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png?style=centerme"></p>
<p>다만 이 경우에, 할아버지 노드에서 두 번째 속성 또는 네 번째 속성을 만족하지 않을 수 있다. 이를 위해 지금까지 설명한 세 가지 케이스를 할아버지 노드에도 적용한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertCase3</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> u = <span class="title function_">getUncle</span>(node);</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u.<span class="property">color</span> === <span class="variable constant_">RED</span>) &#123;</span><br><span class="line">        node.<span class="property">parent</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">        u.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">        <span class="keyword">const</span> g = <span class="title function_">getGrandparent</span>(node);</span><br><span class="line">        g.<span class="property">color</span> = <span class="variable constant_">RED</span>;</span><br><span class="line">        <span class="title function_">insertCase1</span>(g);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="title function_">insertCase4</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>부모는 붉은색인데, 삼촌은 검은색이고, N이 부모의 오른쪽(왼쪽) 자식 노드이고, 부모는 할아버지의 왼쪽(오른쪽) 자식 노드인 경우<br>조건부터 아주 복잡한데, 위 순서대로 따라와보면 확인해야 하는 조건은 새로운 노드의 위치와 부모 노드의 위치라는 사실을 알 수 있다. 이 경우, N과 P의 역할을 변경하기 위해 왼쪽 회전을 해야한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertCase4</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">getGrandparent</span>(node);</span><br><span class="line">    <span class="keyword">if</span> (node === node.<span class="property">parent</span>.<span class="property">right</span> &amp;&amp; node.<span class="property">parent</span> === g.<span class="property">left</span>) &#123;</span><br><span class="line">        <span class="title function_">rotateLeft</span>(n.<span class="property">parent</span>);</span><br><span class="line">        n = n.<span class="property">left</span>;   <span class="comment">//과거에 부모 노드였던 것을 새로운 노드로 바꿔줌</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n === n.<span class="property">parent</span>.<span class="property">left</span> &amp;&amp; n.<span class="property">parent</span> === g.<span class="property">right</span>) &#123;</span><br><span class="line">        <span class="title function_">rotateRight</span>(n.<span class="property">parent</span>);</span><br><span class="line">        n = n.<span class="property">right</span>;  <span class="comment">// 위와 마찬가지</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">insertCase5</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>이런 설명은 없지만, <code>insertCase4</code>는 부모 노드와 새로운 노드의 선을 직선으로 맞추는 느낌이 있다. 이는 다음 케이스로 넘어가기 위한 준비 과정처럼 보인다. </p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png?style=centerme"></p>
<p>그 이후, 부모 노드였던 P가 RBT의 다섯 번째 특성을 어기는 문제를 해결해야 한다. 그런데, 현재 상황이, 부모 노드였던 P를 새로운 노드로 판단한다면, 4번째 조건 중 “N이 부모의 오른쪽 자식 노드이고,” 부분만 바뀌게 되므로, 다음 다섯 번째 조건에서 해결할 수 있다.</p>
</li>
</ul>
<blockquote>
<p>왼쪽회전은 오른쪽 자식 노드를 그 노드의 부모 노드와 바꾸는 과정이다. 대략 아래와 같은 느낌</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = n.<span class="property">parent</span>;</span><br><span class="line">c = n.<span class="property">right</span>;</span><br><span class="line"><span class="keyword">if</span> (c.<span class="property">left</span>) c.<span class="property">left</span>.<span class="property">parent</span> = p;</span><br><span class="line">n.<span class="property">right</span> = c.<span class="property">left</span></span><br><span class="line">n.<span class="property">parent</span> = c;</span><br><span class="line">c.<span class="property">left</span> = n;</span><br><span class="line">c.<span class="property">parent</span> = p;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p.<span class="property">left</span> == p) p.<span class="property">left</span> = c;</span><br><span class="line">  <span class="keyword">else</span> p.<span class="property">right</span> = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>오른쪽 회전은 이와 반대 방향으로 돌리는 걸 의미한다.</p>
</blockquote>
<ul>
<li><p>부모 노드가 붉은 색이지만, 삼촌 노드가 검은색이고, 새로운 노드 N이 부모의 왼쪽(오른쪽) 자식 노드이고, 부모 할아버지 노드의 왼쪽(오른쪽) 자식인 경우<br>위의 케이스에서 한 번 왼쪽 회전을 통해 이 케이스로 왔든, 처음부터 부모 노드의 왼쪽으로 들어왔든 이 케이스로 들어오게 된다. 이 경우에는 할아버지 노드 G에 대해서 오른쪽 회전을 진행한다. 이 결과로 이전 부모 노드인 P는 새로운 노드 N과 할아버지 노드 G를 자식으로 갖게 된다. P는 붉은색, G는 검은색일 수 밖에 없으므로 P와 G의 색을 바꾸면, RBT의 네 번째 속성을 만족하게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertCase5</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">getGrandparent</span>(node);</span><br><span class="line">    node.<span class="property">parent</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">    g.<span class="property">color</span> = <span class="variable constant_">RED</span>;</span><br><span class="line">    <span class="keyword">if</span> (node === node.<span class="property">parent</span>.<span class="property">left</span>) <span class="title function_">rotateRight</span>(g);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">rotateLeft</span>(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png?style=centerme">
<br>

<h3 id="삭제"><a href="#삭제" class="headerlink" title="삭제"></a>삭제</h3><p>아주 복잡한 삽입 과정이 끝났다. 이제 삭제 작업을 보자. 삭제 방식 역시 BST의 삭제 방법을 기본적으로 따른 후, 색을 맞춘다. BST에서 노드 N을 삭제할 때, N의 자식이 둘이라면, 왼쪽 자손 중 최대 또는 오른쪽 자손 중 최소 노드를 N 위치로 옮긴다. 이때 문제가 되는 것은, 옮긴 주변의 레드 블랙 특성을 위반하는지이다. 옮긴 노드는 해당 트리에서 최소 또는 최대라는 특성때문에 최대 1개의 자손만을 가질 수 있다. 결국, 삭제 작업은 최대 1개의 자식만 가진 노드를 삭제하는 것과 마찬가지이다. 따라서, 자식이 1개 이하인 상황을 가정하고 삭제를 설명한다.</p>
<p>삭제할 노드는 M, M의 자식을 C라고 하자. 우선 간단한 상황을 먼저 해결하자. 삭제 대상이 붉은 색이라면, 그냥 M을 삭제한 뒤, C를 M대신 치환하면 된다. 또, M이 검은 노드, C가 붉은 노드라고 가정하자, 검은 노드를 삭제하면 경로의 검은 노드의 수가 같아야 하고, 또는 붉은 노드의 부모는 검은 노드여야 한다는 원칙을 위반할 가능성이 있다. 하지만, C를 검은색으로 바꿔주면 모두 해결 가능하다.</p>
<hr>
<p>어려운 상황은 M, C가 모두 검은 노드일 때 발생한다. 일단 M을 자식 노드 C로 치환한다. 이 상황에서 C를 N으로 명명하고, N의 형제 노드를 S, 부모 노드를 P라고 명명한다.</p>
<ul>
<li><p>N이 새로운 루트가 될 때<br>이전 삭제한 노드가 루트였음을 의미하고, 이는 모든 경로에서 검은색을 하나 줄인 것이다. 이전 특성이 모두 유지되므로 상황은 종료</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCase1</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.<span class="property">parent</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="title function_">deleteCase2</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>S가 붉은 노드인 경우, N이 P의 왼쪽(오른쪽) 자식인 경우<br>현재 상황에서 부모 노드 P가 검은 노드임이 확실한 상황이다. (삼촌 노드가 붉은 색이기 때문에) 이 경우, P와 S의 색을 바꾸고, P에서 왼쪽(오른쪽) 회전하면, S가 N의 할아버지 노드가 된다. 이제 N이 검은색 형제 노드와 붉은 부모 노드를 가지고 있게 된다. 이 상황을 만든 후 다음 케이스에서 나머지 문제(모든 경로에서 검은 노드의 수가 같지 않다.)를 해결하도록 한다. 이후 상황에 대해서 S는 할아버지 노드가 된 기존 S가 아니라, 새롭게 바뀐 N의 형제 노드를 의미한다.</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Red-black_tree_delete_case_3_as_svg.svg/337px-Red-black_tree_delete_case_3_as_svg.svg.png?style=centerme">


<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCase2</span>(<span class="params">node</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="title function_">getSibling</span>(node);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="property">color</span> == <span class="variable constant_">RED</span>) &#123;</span><br><span class="line">    node.<span class="property">parent</span>.<span class="property">color</span> = <span class="variable constant_">RED</span>;</span><br><span class="line">    s.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">    <span class="keyword">if</span> (n === n.<span class="property">parent</span>.<span class="property">left</span>) <span class="title function_">rotateLeft</span>(node.<span class="property">parent</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">rotateRight</span>(node.<span class="property">parent</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteCase3</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>P, S, 그리고 S의 자식들이 검은색인 경우<br>S를 붉은 노드로 만들면 된다. S를 지나는 모든 경로에서 검은 노드 수를 하나 줄여, N을 지나는 경로의 검은 노드 수와 맞출 수 있다. 그러나, P 이하의 트리에서 검은 노드의 수가 1개 줄은 것이기 때문에, P를 지나지 않던 경로가 있다면, P를 지나는 경로보다 검은 노드 수가 한 개 더 많게 된다. 따라서, P에 <code>deleteCase1</code>을 재귀적으로 적용할 필요가 있다.</p>
<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Red-black_tree_delete_case_3_as_svg.svg/337px-Red-black_tree_delete_case_3_as_svg.svg.png?style=centerme">
<br>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCase3</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="title function_">getSibling</span>(node);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">      node.<span class="property">parent</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span> &amp;&amp; </span><br><span class="line">      s.<span class="property">color</span> === <span class="variable constant_">BLACK</span> &amp;&amp;</span><br><span class="line">      s.<span class="property">left</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span> &amp;&amp;</span><br><span class="line">      s.<span class="property">right</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span>) &#123;</span><br><span class="line">       s.<span class="property">color</span> = <span class="variable constant_">RED</span>;</span><br><span class="line">       <span class="title function_">deleteCase1</span>(node.<span class="property">parent</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">deleteCase4</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>S와 S의 자식들은 검은색이지만, P는 붉은색인 경우<br>S와 P의 색을 바꿔주면 된다. 이는 S를 지나는 경로의 검은 노드 개수에 영향을 주지는 않지만, N을 지나는 경로에 대해서는 검은 노드의 개수를 1개 증가시킨다. 이를 통해 삭제된 원래 검은 노드의 개수를 보충한다.</p>
</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Red-black_tree_delete_case_4_as_svg.svg/337px-Red-black_tree_delete_case_4_as_svg.svg.png?centerme"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCase4</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="title function_">getSibling</span>(node);</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">parent</span>.<span class="property">color</span> === <span class="variable constant_">RED</span> &amp;&amp; s.<span class="property">color</span> === <span class="variable constant_">BLACK</span> &amp;&amp; s.<span class="property">left</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span> &amp;&amp; s.<span class="property">right</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span>) &#123;</span><br><span class="line">    s.<span class="property">color</span> = <span class="variable constant_">RED</span>;</span><br><span class="line">    n.<span class="property">parent</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="title function_">deleteCase5</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>S가 검정, S의 왼쪽(오른쪽) 자식이 빨강, 오른쪽(왼쪽) 자식이 검정이고, N이 부모의 왼쪽(오른쪽) 자식인 경우<br>S를 오른쪽(왼쪽) 회전시켜 S의 왼쪽 자식이 S의 부모 노드이자, 새로운 S(N의 형제)가 되도록 한다. 그리고 S의 색을 부모 노드와 바꿔준다. 이 상태를 만들고 나서, <code>deleteCase6</code>으로 넘겨준다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/Red-black_tree_delete_case_5_as_svg.svg/243px-Red-black_tree_delete_case_5_as_svg.svg.png?style=centerme"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCase5</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="title function_">getSibling</span>(node);</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="property">color</span> === <span class="variable constant_">BLACK</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === n.<span class="property">parent</span>.<span class="property">left</span> &amp;&amp; s.<span class="property">right</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span> &amp;&amp; s.<span class="property">left</span>.<span class="property">color</span> === <span class="variable constant_">RED</span>) &#123;</span><br><span class="line">      s.<span class="property">color</span> = <span class="variable constant_">RED</span>;</span><br><span class="line">      s.<span class="property">left</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">      <span class="title function_">rotateRight</span>(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n === n.<span class="property">parent</span>.<span class="property">right</span> &amp;&amp; s.<span class="property">left</span>.<span class="property">color</span> === <span class="variable constant_">BLACK</span> &amp;&amp; s.<span class="property">right</span>.<span class="property">color</span> == <span class="variable constant_">RED</span>) &#123;</span><br><span class="line">      s.<span class="property">color</span> = <span class="variable constant_">RED</span>;</span><br><span class="line">      s.<span class="property">right</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">      <span class="title function_">rotateLeft</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">deleteCase6</span>(node);</span><br></pre></td></tr></table></figure>
</li>
<li><p>S가 검은색, S의 오른쪽(왼쪽) 자식이 빨강, N이 P의 왼쪽(오른쪽) 자식인 경우<br>P를 왼쪽(오른쪽)으로 회전해서 S가 P와 S의 오른쪽(왼쪽) 자식 노드의 부모 노드가 되도록 한다. 그리고, P와 S의 색을 바꾸고, S의 오른쪽(왼쪽) 자식노드를 검은색으로 만든다. </p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Red-black_tree_delete_case_6_as_svg.svg/337px-Red-black_tree_delete_case_6_as_svg.svg.png?style=centerme"></p>
<p>이렇게 만들어진 트리에서 N은 하나의 검은 조상 노드를 더 갖게 되었고, 따라서 N을 지나는 경로는 검은색을 하나 더 갖게 된다. 반면, N을 통과하는 케이스는 두 가지 경우의 수를 갖는다.</p>
<ol>
<li>N의 새로운 형제 노드를 지나는 경우: 변경되기 전과 같은 순서를 만난다. <code>P -&gt; S -&gt; ...</code> 이던게, <code>S -&gt; P -&gt; ...</code> 로 바뀐 것 뿐</li>
<li>N의 새로운 삼촌 노드를 지나는 경우: 변형 되기 전에 <code>P -&gt; S -&gt; S 오른쪽 자식 -&gt; ...</code> 경로를 가지던 것이, 변형 후, <code>S -&gt; S 오른쪽 자식 -&gt; ...</code>로 바뀌게 되었다. 하지만 붉은 노드가 하나 줄었기 때문에 경로 상에서는 같은 검은 노드를 만나게 된다.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteCase6</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="title function_">getSibling</span>(node);</span><br><span class="line">  s.<span class="property">color</span> = node.<span class="property">parent</span>.<span class="property">color</span>;</span><br><span class="line">  node.<span class="property">parent</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node == node.<span class="property">parent</span>.<span class="property">left</span>) &#123;</span><br><span class="line">    s.<span class="property">right</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">    <span class="title function_">rotateRight</span>(node.<span class="property">parent</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s.<span class="property">left</span>.<span class="property">color</span> = <span class="variable constant_">BLACK</span>;</span><br><span class="line">    <span class="title function_">rotateRight</span>(node.<span class="property">parent</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC">https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98">https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://coding-factory.tistory.com/557">https://coding-factory.tistory.com/557</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Red-Black Tree</p><p><a href="https://changhoi.kim/posts/etc/red-black-tree/">https://changhoi.kim/posts/etc/red-black-tree/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>changhoi</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-07-01</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-07-01</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/data-structure/">data_structure</a><a class="link-muted mr-2" rel="tag" href="/tags/algorithm/">algorithm</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="title is-5">관련 글</h3><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/great-operation-creating-react-ui-kit/"><img src="https://upload.wikimedia.org/wikipedia/commons/1/18/React_Native_Logo.png" alt="React UI Kit 만들기 대작전"></a></figure><div class="media-content"><p class="date"><time datetime="2021-02-13T15:00:00.000Z">2021-02-14</time></p><p class="title"><a href="/posts/etc/great-operation-creating-react-ui-kit/">React UI Kit 만들기 대작전</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/rxjs-operator-01/"><img src="/images/2020-09-17-rxjs-quicklearn-02/01.png" alt="RxJS Operator 01 - Creation, Filtering"></a></figure><div class="media-content"><p class="date"><time datetime="2020-09-25T15:00:00.000Z">2020-09-26</time></p><p class="title"><a href="/posts/etc/rxjs-operator-01/">RxJS Operator 01 - Creation, Filtering</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/rxjs-quicklearn-03/"><img src="/images/2020-09-17-rxjs-quicklearn-02/01.png" alt="RxJS 빠르게 배우기 03 - Observer &amp; Subscription &amp; Operator"></a></figure><div class="media-content"><p class="date"><time datetime="2020-09-19T15:00:00.000Z">2020-09-20</time></p><p class="title"><a href="/posts/etc/rxjs-quicklearn-03/">RxJS 빠르게 배우기 03 - Observer &amp; Subscription &amp; Operator</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/rxjs-quicklearn-02/"><img src="/images/2020-09-17-rxjs-quicklearn-02/01.png" alt="RxJS 빠르게 배우기 02 - Observables"></a></figure><div class="media-content"><p class="date"><time datetime="2020-09-16T15:00:00.000Z">2020-09-17</time></p><p class="title"><a href="/posts/etc/rxjs-quicklearn-02/">RxJS 빠르게 배우기 02 - Observables</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/rxjs-quicklearn-01/"><img src="/images/2020-09-17-rxjs-quicklearn-02/01.png" alt="RxJS 빠르게 배우기 01 - Overview"></a></figure><div class="media-content"><p class="date"><time datetime="2020-08-18T15:00:00.000Z">2020-08-19</time></p><p class="title"><a href="/posts/etc/rxjs-quicklearn-01/">RxJS 빠르게 배우기 01 - Overview</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/refactoring-practice/"><img src="https://c0.wallpaperflare.com/preview/600/243/618/javascript-vscode-editor-code.jpg" alt="리팩토링 실습하기"></a></figure><div class="media-content"><p class="date"><time datetime="2020-06-18T15:00:00.000Z">2020-06-19</time></p><p class="title"><a href="/posts/etc/refactoring-practice/">리팩토링 실습하기</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/husky/"><img src="https://cdn-images-1.medium.com/fit/t/1600/480/1*6BjEhSPYwkgeQfpLvHU3BA.png" alt="Husky로 Git hooks 관리하기"></a></figure><div class="media-content"><p class="date"><time datetime="2020-04-07T15:00:00.000Z">2020-04-08</time></p><p class="title"><a href="/posts/etc/husky/">Husky로 Git hooks 관리하기</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/react-redux-hooks/"><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRe6MxDK7g_9SNVN_KMNdr130TjtEg6XraxMHK7LqufJU2rcka9" alt="React환경에서 Hooks로 Redux 사용 하기"></a></figure><div class="media-content"><p class="date"><time datetime="2020-02-04T15:00:00.000Z">2020-02-05</time></p><p class="title"><a href="/posts/etc/react-redux-hooks/">React환경에서 Hooks로 Redux 사용 하기</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/redux-async-demo/"><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRe6MxDK7g_9SNVN_KMNdr130TjtEg6XraxMHK7LqufJU2rcka9" alt="React환경에서 Redux로 비동기 처리 하기"></a></figure><div class="media-content"><p class="date"><time datetime="2020-02-03T15:00:00.000Z">2020-02-04</time></p><p class="title"><a href="/posts/etc/redux-async-demo/">React환경에서 Redux로 비동기 처리 하기</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/shallow-knowledge-of-funtional-programming/"><img src="/images/2019-12-19-shallow-knowledge-of-functional-programming/thumbnail.png" alt="함수형 프로그래밍에 대한 얕은 지식"></a></figure><div class="media-content"><p class="date"><time datetime="2019-12-18T15:00:00.000Z">2019-12-19</time></p><p class="title"><a href="/posts/etc/shallow-knowledge-of-funtional-programming/">함수형 프로그래밍에 대한 얕은 지식</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article></div></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/backend/https-dive/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">HTTPS 설명하기</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/database/mongodb-modeling/"><span class="level-item">MongoDB 모델링</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="fb-comments" data-width="100%" data-href="https://changhoi.kim/posts/etc/red-black-tree/" data-num-posts="5"></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ko/sdk.js#xfbml=1&version=v12.0";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/34329147?s=400&amp;u=9d1b1dc88bc8ee5965f35b0160780264c3619eb6&amp;v=4" alt="Changhoi Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Changhoi Kim</p><p class="is-size-6 is-block">Co-Founder of Bayesians</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives/"><p class="title">73</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories/"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags/"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/changhoi/" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn" href="https://www.linkedin.com/in/changhoi/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/changhoi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Email" href="mailto:changhoi0522@gmail.com"><i class="fas fa-envelope-square"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="English" href="https://jayce.kim"><i class="fas fa-language"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/backend/"><span class="level-start"><span class="level-item">backend</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/books/"><span class="level-start"><span class="level-item">books</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/logs/"><span class="level-start"><span class="level-item">logs</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">os</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/serverless/"><span class="level-start"><span class="level-item">serverless</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Red-Black-Tree"><span class="level-left"><span class="level-item">1</span><span class="level-item">Red-Black Tree</span></span></a></li><li><a class="level is-mobile" href="#특성"><span class="level-left"><span class="level-item">2</span><span class="level-item">특성</span></span></a></li><li><a class="level is-mobile" href="#동작"><span class="level-left"><span class="level-item">3</span><span class="level-item">동작</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#삽입"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">삽입</span></span></a></li><li><a class="level is-mobile" href="#삭제"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">삭제</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">4</span><span class="level-item">Reference</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a><p class="is-size-7"><span>&copy; 2025 changhoi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="external nofollow noopener noreferrer" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>