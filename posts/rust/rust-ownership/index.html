<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Rust Ownership - Changhoi Kim</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="white"><meta name="application-name" content="Changhoi Kim"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="white"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Changhoi Kim"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Rust는 GC가 없는 언어이다. 보통은 언어가 힙 메모리를 관리하기 위해 GC를 사용하거나 개발자가 직접 관리하는 두 가지 노선을 선택해 왔지만, Rust는 조금 독자적인 방법을 선택했다. 각 변수가 사용하는 메모리에 대한 소유권을 하나만 유지하면 GC가 필요 없다는 점을 이용한다. 만약 하나의 변수에 힙 영역 데이터가 묶여있다면 해당 변수가 더 이상 접"><meta property="og:type" content="blog"><meta property="og:title" content="Rust Ownership"><meta property="og:url" content="https://changhoi.kim/posts/rust/rust-ownership/"><meta property="og:site_name" content="Changhoi Kim"><meta property="og:description" content="Rust는 GC가 없는 언어이다. 보통은 언어가 힙 메모리를 관리하기 위해 GC를 사용하거나 개발자가 직접 관리하는 두 가지 노선을 선택해 왔지만, Rust는 조금 독자적인 방법을 선택했다. 각 변수가 사용하는 메모리에 대한 소유권을 하나만 유지하면 GC가 필요 없다는 점을 이용한다. 만약 하나의 변수에 힙 영역 데이터가 묶여있다면 해당 변수가 더 이상 접"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://changhoi.kim/images/2022-11-21-rust-ownership/thumbnail.jpeg"><meta property="article:published_time" content="2022-11-20T15:00:00.000Z"><meta property="article:modified_time" content="2022-11-20T15:00:00.000Z"><meta property="article:author" content="changhoi"><meta property="article:tag" content="programming"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://changhoi.kim/images/2022-11-21-rust-ownership/thumbnail.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://changhoi.kim/posts/rust/rust-ownership/"},"headline":"Rust Ownership","image":[],"datePublished":"2022-11-20T15:00:00.000Z","dateModified":"2022-11-20T15:00:00.000Z","author":{"@type":"Person","name":"changhoi"},"publisher":{"@type":"Organization","name":"Changhoi Kim","logo":{"@type":"ImageObject","url":"https://changhoi.kim/img/logo.jpg"}},"description":"Rust는 GC가 없는 언어이다. 보통은 언어가 힙 메모리를 관리하기 위해 GC를 사용하거나 개발자가 직접 관리하는 두 가지 노선을 선택해 왔지만, Rust는 조금 독자적인 방법을 선택했다. 각 변수가 사용하는 메모리에 대한 소유권을 하나만 유지하면 GC가 필요 없다는 점을 이용한다. 만약 하나의 변수에 힙 영역 데이터가 묶여있다면 해당 변수가 더 이상 접"}</script><link rel="canonical" href="https://changhoi.kim/posts/rust/rust-ownership/"><link rel="alternate" href="/rss2.xml" title="Changhoi Kim" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-QBSLW6WTZW" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-QBSLW6WTZW');</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/2022-11-21-rust-ownership/thumbnail.jpeg" alt="Rust Ownership"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2022-11-20T15:00:00.000Z" title="2022. 11. 20. 오전 7:00:00">2022-11-21</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2022-11-20T15:00:00.000Z" title="2022. 11. 20. 오전 7:00:00">2022-11-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/rust/">rust</a></span><span class="level-item">33분안에 읽기 (약 4954 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">Rust Ownership</h1><div class="content"><p>Rust는 GC가 없는 언어이다. 보통은 언어가 힙 메모리를 관리하기 위해 GC를 사용하거나 개발자가 직접 관리하는 두 가지 노선을 선택해 왔지만, Rust는 조금 독자적인 방법을 선택했다. 각 변수가 사용하는 메모리에 대한 소유권을 하나만 유지하면 GC가 필요 없다는 점을 이용한다. 만약 하나의 변수에 힙 영역 데이터가 묶여있다면 해당 변수가 더 이상 접근 불가능한 상태가 되었을 때 메모리를 곧바로 해제해버리면 된다. 실제로 러스트를 사용하다 보면 힙 메모리를 <code>free</code> 하지 않아서 간단한 프로그램을 쓸 때 꼭 GC가 있는 언어처럼 느껴진다. 이번 글에서는 소유권 및 그와 연관된 여러 러스트의 컨셉을 정리했다.</p>
<span id="more"></span>

<h1 id="Ownership-소유권"><a href="#Ownership-소유권" class="headerlink" title="Ownership (소유권)"></a>Ownership (소유권)</h1><p>GC가 있는 언어 같다고 했지만, 개인적으로 사실 조금 이질적인 느낌이 있다. Ownership은 러스트를 잘 쓰기 위해 숙련도가 요구되는 주범이다.</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#what-is-ownership">The Rust Programming Language</a> 책에서는 소유권을 “규칙”이라고 설명한다. 소유권과 관련된 규칙들을 컴파일 타임에 모두 확인하고 하나라도 지켜지지 않는다면 컴파일되지 않는다. 컴파일 타임에 확인되므로 런타임에서는 퍼포먼스에 영향을 주지 않는다.</p>
<p>규칙은 다음과 같다.</p>
<ul>
<li>각 값은 모두 주인(Owner)을 가지고 있다.</li>
<li>한 번에 하나의 Owner를 갖는다.</li>
<li>Owner가 스코프를 벗어나면 값은 정리된다.</li>
</ul>
<p>값은 하나의 식별자를 주인으로 갖게 된다고 이해하면 좋을 것 같다. 식별자는 러스트의 변수 스코프에 의해 접근 불가능해지는 순간이 오는데, 이때 값들을 모두 정리한다.</p>
<h1 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h1><p>변수는 자신이 담고 있는 값이 어느 정도의 메모리를 사용해 할당되는지 알고 있어야 한다. 예를 들어서 다음과 같이 <code>u8</code> 타입이 있다면 컴파일러 입장에서 이 타입은 1바이트를 사용한다는 것을 알 수 있다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="number">1_u8</span>;</span><br></pre></td></tr></table></figure>

<p>하지만 그렇지 않은 경우도 있다. 예를 들어 가변 길이의 벡터라든지, 문자열을 필드로 가지고 있는 구조체라든지 사용자에게 입력받는 경우 런타임에 데이터가 결정되므로 메모리 크기를 컴파일 타임에 알 수 없다.</p>
<p>일반적으로 언어에서 이러한 경우는 힙에 데이터를 넣는 방식으로 해결한다. 보통 동적 할당한다고 표현하는데, 런타임에 메모리를 필요한 만큼 힙 메모리에 할당해 사용한다. 메모리를 관리해야 하는 상황은 이렇게 힙에 할당하는 상황이다. GC 역시 힙 영역의 메모리 관리에 대해 얘기를 한다.</p>
<blockquote>
<p><a href="/posts/go/go-gc">GC에 대해서 작성한 글</a></p>
</blockquote>
<p>Rust의 <code>String</code> 타입이 힙을 사용하면서, 아주 친근한 데이터 타입으로, Ownership을 설명하기 적합하다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// scope 종료 이후 s와 해당 메모리는 정리된다.</span></span><br></pre></td></tr></table></figure>

<p>Rust는 이렇게 스코프가 종료되는 시점에 <code>drop</code> 함수를 호출하는데, 이 함수는 작성자가 메모리를 <code>free</code> 하기 위한 코드가 담겨있다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> v: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;drop my type&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = MyType &#123; v: <span class="number">1</span> &#125;;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// drop my type</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>이 <code>drop</code> 함수는 예시에서 보이는 것처럼 <code>Drop</code> 트레잇을 구현한 것이다. 러스트를 모르지만, 컨셉이 궁금해서 온 사람들은 <code>Drop</code>이 인터페이스라고 생각하면 될 것 같다.</p>
</blockquote>
<p>이렇게 소유권은 하나만 갖게 하면서 소유권을 가진 식별자가 스코프를 벗어날 때 Drop 하므로 GC가 필요 없다. 마치 Reference Count를 하나로 유지하는 것과 비슷하다. C 언어를 잘 알지는 못하지만, 패키지를 사용할 때 잘 만들어진 패키지의 경우 사용된 데이터 타입을 어디서 <code>free</code> 하는 책임을 갖는지 주석으로 명시한다고 들었는데, 러스트는 마치 이 방향을 컴파일 타임에 규칙으로서 명시해 문제를 해결하는 느낌이다.</p>
<blockquote>
<p>러스트처럼 변수 스코프가 종료되는 시점에 패턴을 C++에서는 <code>RAII</code>(<code>Resource Acquisition Is Initialization</code>)이라는 이름으로 부른다.</p>
</blockquote>
<p>이제 <code>String</code> 타입을 통해 소유권에 대해 조금 더 자세히 설명한다.</p>
<h1 id="소유권-이전"><a href="#소유권-이전" class="headerlink" title="소유권 이전"></a>소유권 이전</h1><p>본격적인 소유권 이전에 대한 설명 전에 스택 위에서 할당되는 값으로 보자. 다음과 같이 <code>y = x</code>처럼 다른 식별자에 값을 복사해 넣는 것을 비교해볼 예정이다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = x;</span><br><span class="line">x += <span class="number">1</span>;</span><br><span class="line">y -= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125; / y: &#123;&#125;&quot;</span>, x, y); <span class="comment">// 2, 0</span></span><br></pre></td></tr></table></figure>

<p><code>x</code>는 1을 할당 받고 <code>y</code>는 <code>x</code>를 할당 받았지만, 둘 다 값이 복사되어 서로 다른 메모리에 있는 값을 보게 된다. 이는 정수형처럼 정해진 사이즈를 가진 값인 경우 할당 연산을 수행할 때 새로운 값이 스택에 복사되어 메모리를 따로 받게 되기 때문이다. 구구절절 설명했지만, 일반적으로 프로그래밍 언어에서 우리는 이러한 상황을 아주 자연스럽게 받아들일 수 있다.</p>
<p>이제 힙을 사용하는 경우를 확인해 보자. 힙을 사용하는 데이터 중에 일반적이라고 생각되는 자바스크립트의 코드를 살펴보면 다음과 같이 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">data</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> copeid = obj;</span><br><span class="line">copied.<span class="property">data</span> = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; data: 100 &#125;</span></span><br></pre></td></tr></table></figure>

<p>우리는 이전에 사용했던 <code>obj</code> 객체에 접근할 수도 있고, 같은 힙 메모리를 공유하며 각자의 수정 사항을 모두 동일하게 확인할 수 있다.</p>
<p>러스트는 아주 독특하게 동작하는데, 결과만 말하자면 힙에 있는 데이터를 가리키고 있는 식별자는 다른 식별자에 힙 포인터를 복사해 넣는 순간 해당 데이터에 대한 소유권을 이전한다. 그리고 소유권을 잃은 식별자는 더 이상 접근할 수 없다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1: &#123;&#125; / s2: &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let s1 = String::from(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment"> -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span></span><br><span class="line"><span class="comment">let s2 = s1;</span></span><br><span class="line"><span class="comment">      -- value moved here</span></span><br><span class="line"><span class="comment">println!(&quot;s1: &#123;&#125; / s2: &#123;&#125;&quot;, s1, s2);</span></span><br><span class="line"><span class="comment">                         ^^ value borrowed here after move</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>이해가 어려운 말들이 나오는데, 동작을 설명하기에 앞서 먼저 <code>String</code> 타입을 간단히 설명하자면 아래와 같이 문자열 맨 앞을 가리키는 포인터, <code>len</code>, 그리고 <code>capacity</code>를 스택에 담는 구조이다.</p>
<p><img src="/images/2022-11-21-rust-ownership/string-memory.svg?style=centerme" alt="문자열과 메모리"></p>
<blockquote>
<p><code>len</code>은 문자열의 길이를 뜻하고 <code>capacity</code>는 바이트로 표시한 컨텐츠의 메모리 크기를 의미한다.</p>
</blockquote>
<p>따라서 <code>s2</code> 식별자에 <code>s1</code>을 할당하는 동작은 앞서 정수로 설명한 경우와 동일하게 위 세 개 정보를 스택에 복사하는 것과 같다. 힙에 있는 데이터는 복제되지 않는다.</p>
<p><img src="/images/2022-11-21-rust-ownership/copied-string.svg?style=centerme" alt="스택 데이터만 복사"></p>
<p>우리는 앞서 Rust의 동작 중에 식별자가 스코프에 벗어나면 사용되던 값들을 모두 정리한다고 배웠는데, 위와 같은 구조에서는 문자열이 두 번(<code>s1</code>의 <code>Drop</code> &amp;&amp; <code>s2</code>의 <code>Drop</code>) 정리되는 상황이 생긴다. 즉, 두 번 <code>free</code>를 하는 것과 같고 이는 메모리 충돌을 발생시킨다.</p>
<p>메모리 안전성을 위해서 러스트는 이런 상황에서 <code>s1</code>이 더 이상 유효하지 않다고 판단해버린다. 즉 말해서 러스트는<code>s1</code>이 스코프를 벗어나든 아니든 <code>Drop</code>과 관련된 로직을 수행할 필요가 없다.</p>
<p>다른 언어에서는 이렇게 값을 복사하는 과정에 포인터 내부의 값을 복사하지 않는 것을 <strong>얕은 복사</strong>라고 표현한다. Rust는 이 동작이 모든 데이터에 적용된다. 자동으로 깊은 복사를 수행하는 경우가 없다. 책에서 설명하는 방식으로는 Rust에서 이런 동작을 <code>move</code>라고 한다는데, 한국어로는 이전이라고 표현하면 될 것 같다.</p>
<blockquote>
<p>조금 명시적으로 말하자면 힙 포인터를 얕은 복사하는 경우 발생하는 동작이 “이전”이라고 표현할 수 있을 것 같다.</p>
</blockquote>
<h1 id="Copy-Clone"><a href="#Copy-Clone" class="headerlink" title="Copy &amp; Clone"></a>Copy &amp; Clone</h1><p>힙에 있는 데이터까지 복제하는 작업을 할 때는 일반적으로 <code>Clone</code>이라는 Trait을 구현한다. <code>String</code> 타입도 마찬가지로 <code>Clone</code> 타입을 구현하고 있다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(not(no_global_oom_handling))]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">  <span class="type">String</span> &#123; vec: <span class="keyword">self</span>.vec.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">clone_from</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, source: &amp;<span class="keyword">Self</span>) &#123;</span><br><span class="line">  <span class="keyword">self</span>.vec.<span class="title function_ invoke__">clone_from</span>(&amp;source.vec);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 동작은 다음 그림처럼 힙 데이터 역시 복사해서 새로운 식별자인 <code>s2</code>에 담는다. <code>s1</code>의 소유권은 그대로 유지된다.</p>
<p><img src="/images/2022-11-21-rust-ownership/string-clone.svg?style=centerme" alt="문자열 Clone"></p>
<hr>
<p>다시 스택에 할당되는 값만 가진 이 코드로 돌아와 보자.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = x;</span><br><span class="line">x += <span class="number">1</span>;</span><br><span class="line">y -= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125; / y: &#123;&#125;&quot;</span>, x, y); <span class="comment">// 2, 0</span></span><br></pre></td></tr></table></figure>

<p>스택에 할당되는 값의 경우 할당 연산을 수행할 때 소유권 이전이 발생하지 않고 값을 복사해버린다. 여기서는 얕은 복사니 깊은 복사니 하는 것이 의미가 없다. 이렇게 소유권 이전 없이 값을 간단히 스택에서 복사해버릴 수 있는 타입들은 모두 <code>Copy</code> Trait을 구현하고 있다. <code>Copy</code> 타입은 러스트 시스템의 특별한 어노테이션으로서, 만약 이 Trait을 구현하고 있는 타입이라면 할당 연산을 할 때 소유권을 이전하지 않는다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line"> -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br></pre></td></tr></table></figure>

<p>아까 에러 메시지를 다시 한번 보면, <code>String</code>은 <code>Copy</code> Trait을 구현하고 있지 않기 때문에 <code>move</code>가 발생한다고 설명한다.</p>
<p><code>Copy</code> 타입을 직접 구현하도록 할 수 있는데, 등호 연산을 오버로딩하는 느낌이 아니라 그냥 스택에서 값을 복사할 수 있는 타입의 경우 그 자격을 명시하는 정도이다. <code>Copy</code>를 구현하려면 대상 타입이 <code>Clone</code>을 구현하고, 그 타입 자체 혹은 타입을 구성하는 다른 필드들 모두가 <code>Drop</code> Trait을 구현하고 있지 않아야 한다. 즉, 타입을 구성하는 모든 필드 및 값이 스택에 할당될 수 있어야 한다는 것을 의미한다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Copy</span> <span class="keyword">for</span> <span class="title class_">MyType</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">  *<span class="keyword">self</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Copy</code> Trait은 위 코드처럼, 구현해야 하는 메소드가 없다. 이는 러스트가 의도적으로 오버로딩을 구현하지 못하도록 막은 것이고, 이를 통해 임의 코드가 런타임에서 실행되지 않도록 막는다.</p>
</blockquote>
<blockquote>
<p><code>Copy</code>가 구현될 수 있는 규칙을 설명할 때 책에서는 위와 같이 <strong>Clone + Not Drop</strong>으로 설명하지만, 코드 주석에서는 필드가 모두 Copy를 구현해야 한다고 설명한다. 즉, 기본 타입들은 모두 <strong>Not Drop</strong>이라면 <strong>Copy</strong>를 구현하고 있는 것 같다.</p>
</blockquote>
<blockquote>
<p>위 코드에서 <code>Copy</code>를 구현하는 두 가지 방법은 미묘한 차이가 있는데, 이번 글의 범위를 벗어난다. 궁금하다면 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html#appendix-c-derivable-traits">Derivable Traits 문서</a>와 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/rust-lang/rust/blob/e702534763599db252f2ca308739ec340d0933de/library/core/src/marker.rs#L216-L393">Rust Copy 코드의 주석</a>을 보자.</p>
</blockquote>
<p><code>Copy</code> Trait을 직접 구현해야 하는 일은 거의 드물다. <code>Copy</code>가 구현되어 있다면 최적화가 되어있고 <code>clone</code> 메소드가 아니라 할당 연산자를 사용할 수 있음을 의미하므로 코드가 더 간결해질 수는 있다. <code>Copy</code>를 구현하고 있는 기본 타입들은 다음과 같다.</p>
<ul>
<li>모든 정수형 타입들 (<code>u32</code>, <code>u16</code>, …)</li>
<li>Boolean 타입</li>
<li>부동소수 타입 (<code>f64</code>, …)</li>
<li>모든 캐릭터 타입 (<code>char</code>)</li>
<li><code>Copy</code> 구현체들을 담고 있는 튜플 (<code>(i32, i32)</code>)</li>
</ul>
<h1 id="함수와-Ownership"><a href="#함수와-Ownership" class="headerlink" title="함수와 Ownership"></a>함수와 Ownership</h1><p>함수 파라미터로 값을 넘기는 것이나 리턴 값으로 넘기는 것 모두 할당 연산과 비슷한 동작을 한다. 할당과 마찬가지로 값을 복사하기 때문에 파라미터로 <code>Copy</code>를 구현하지 않은 값을 넣거나, 리턴하는 경우 소유권 이전이 발생한다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> v: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">from</span>(v: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">  MyType &#123; v &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;drop my type&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = MyType::<span class="title function_ invoke__">from</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="title function_ invoke__">take_ownership</span>(s);</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">take_ownership</span>(param: MyType) &#123;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, param.v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// drop my type</span></span><br><span class="line"><span class="comment">// finish</span></span><br></pre></td></tr></table></figure>

<p><code>s</code>는 <code>take_ownership</code> 함수에 넘겨질 때 소유권 이전이 발생한다. 따라서 <code>take_ownership</code> 이후로는 접근이 불가능하다. <code>take_ownership</code> 함수가 끝날 때 해당 변수의 스코프가 종료되므로 <code>drop</code> 함수를 수행한다. 리턴하는 값이 <code>Drop</code>을 구현하고 있는 경우도 마찬가지로 리턴 값에 대한 소유권이 할당받는 식별자에게 넘어가게 된다. 따라서 같은 스코프에 변경된 값을 유지하고 싶으면 다시 함수에서 바깥으로 소유권을 전달해야 한다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> (s, slen) = <span class="title function_ invoke__">calculate_length</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line"> (s, s.<span class="title function_ invoke__">len</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이러한 동작이 사실 매우 귀찮기 때문에 러스트에서는 값은 참조하지만, 소유권은 넘겨주지 않는 방법으로 함수를 사용할 수 있도록 했다.</p>
<h1 id="참조와-소유권-대여"><a href="#참조와-소유권-대여" class="headerlink" title="참조와 소유권 대여"></a>참조와 소유권 대여</h1><p>위와 같은 상황에서 소유권을 넘기지 않으려면 <strong>참조</strong>(<strong>Reference</strong>)를 넘긴다. 원본 데이터에 접근하지 않고 스택의 데이터를 참조하는 자료형으로 파라미터에 전달된다.</p>
<p><img src="/images/2022-11-21-rust-ownership/reference.svg?style=centerme" alt="참조형"><br>참조형으로 전달된 값은 기본적으로 불변 자료형이고, 참조하는 식별자이기 때문에 식별자 스코프가 종료되어도 <code>Drop</code>을 수행하지 않는다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s);</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; length: &#123;&#125;&quot;</span>, s, len); <span class="comment">// hello length: 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line"> s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드처럼, <code>s</code> 식별자를 다른 함수에 참조형으로 전달하게 되면 해당 함수 이후에도 <code>s</code>를 사용할 수 있고, 해당 값을 유지하기 위한 리턴도 필요 없게 된다. 다만 다음과 같이 값을 변경하려고 하는 경우는 컴파일 에러가 발생한다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(s: &amp;<span class="type">String</span>) &#123;</span><br><span class="line"> s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line"> <span class="comment">// compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위에서 짧게 언급한 것처럼 기본적으로 참조형이 <strong>불변형</strong>(<strong>Immutable Reference</strong>)이기 때문이다.</p>
<blockquote>
<p>원래 러스트는 기본적으로 값을 불변형으로 선언한다. <code>let</code>으로 선언된 모든 식별자는 불변 식별자이다. 만약 값을 바꾸려면 <code>mut</code> 키워드를 식별자 앞에 선언해서 해당 식별자가 가변적임을 컴파일러에 알려야 한다.</p>
</blockquote>
<p>참조한 변수를 <strong>가변적</strong>(<strong>Mutable Reference</strong>)으로 사용하려면 다른 변수들처럼 <code>mut</code> 키워드를 사용한다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"> <span class="comment">// 여기도 mutable 한 변수가 되도록 `mut` 키워드를 사용한다.</span></span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s);</span><br><span class="line"> <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; length: &#123;&#125;&quot;</span>, s, len); <span class="comment">// hello, world length: 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line"> s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>러스트는 참조형을 사용할 때 두 가지 안전 장치가 있다.</p>
<ul>
<li>Data Race를 방지하기 위한 특징</li>
<li>쓰레깃값을 만들지 않기 위한 특징</li>
</ul>
<h2 id="Mutable-Reference-Data-Race-방지"><a href="#Mutable-Reference-Data-Race-방지" class="headerlink" title="Mutable Reference Data Race 방지"></a>Mutable Reference Data Race 방지</h2><p>일단 Data Race는 다음과 같은 상황을 얘기한다.</p>
<ul>
<li>두 개 이상의 포인터가 같은 데이터에 접근 가능</li>
<li>최소 하나의 포인터가 데이터 쓰기가 가능</li>
<li>데이터 접근을 동기화하는 메커니즘 부재</li>
</ul>
<p>위 세 개의 상황이 동시에 발생하고 있을 때 Data Race 상태라고 볼 수 있다. 동시성 문제의 Race Condition과 유사한데, 데이터 변경과 읽기 순서에 따라 결과가 달라질 수 있는 상황이다.</p>
<p><img src="/images/2022-11-21-rust-ownership/datarace.png?style=centerme" alt="Data Race"></p>
<p>이 문제는 미묘한 상황과 복잡한 코드에 의해 런타임에 찾기가 어려운 경우가 많지만, 러스트는 뚱뚱한 컴파일러를 지향하는 언어답게 사전에 컴파일 단계에서 이를 방지해준다.</p>
<p>방지하는 방법은 Reference를 전달할 때 Shared Lock, Exclusive Lock을 거는 것처럼 동작을 제한한다. Mutable Reference의 스코프를 벗어나기 전까지 Exclusive Lock처럼 다른 Reference가 걸리는 것을 막는다. 읽기 전용 Reference는 Shared Lock처럼 다른 읽기 전용 Reference가 걸리는 것은 막지 않는다. 하지만 Mutable Reference는 동시에 사용될 수 없다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">ref1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">ref2</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// compile error</span></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, ref1, ref2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이 Mutable Reference를 동시에 Borrow 해줄 수 없다는 에러가 나온다. Immutable Reference가 먼저 있어도 비슷한 컴파일 에러가 발생한다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line">  --&gt; src/main.rs:27:20</span><br><span class="line">   |</span><br><span class="line">26 |     let ref1 = &amp;mut s;</span><br><span class="line">   |                    ------ first mutable borrow occurs here</span><br><span class="line">27 |     let ref2 = &amp;mut s;</span><br><span class="line">   |                    ^^^^^^ second mutable borrow occurs here</span><br><span class="line">28 |     println!(&quot;&#123;&#125; &#123;&#125;&quot;, ref1, ref2)</span><br><span class="line">   |                       ---- first borrow later used here</span><br></pre></td></tr></table></figure>

<p>참조형의 스코프는 마지막으로 사용된 시점까지 유지되므로 다음과 같은 경우는 문제없이 코드가 동작한다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">ref1</span> = &amp;s;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ref1); <span class="comment">// hello // 컴파일러는 여기서 `ref1` 스코프가 종료된다고 판단한다.</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">ref2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"> <span class="title function_ invoke__">change</span>(ref2);</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ref2); <span class="comment">// hello, world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dangling-Reference"><a href="#Dangling-Reference" class="headerlink" title="Dangling Reference"></a>Dangling Reference</h2><p>Dangling Reference는 <code>free</code> 된 레퍼런스를 식별자로 가지고 있는 경우를 말한다. 러스트에서는 이를 컴파일러가 절대 Dangling Reference를 가지고 있지 않도록 보장해준다. 만약 어떤 데이터가 참조되고 있다면 해당 참조 식별자의 스코프가 종료되기 전까지 데이터의 스코프가 끝나지 않도록 해야 한다.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:5:16</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                ~~~~~~~~</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure>

<p>라이프타임 어노테이션에 대해서는 이 글에서 다루지 않는다. 자세한 내용은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-borrow-checker">이 링크</a>에서 확인하면 좋을 것 같다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">https://doc.rust-lang.org/book/appendix-03-derivable-traits.html</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Rust Ownership</p><p><a href="https://changhoi.kim/posts/rust/rust-ownership/">https://changhoi.kim/posts/rust/rust-ownership/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>changhoi</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-11-21</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-21</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/programming/">programming</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="title is-5">관련 글</h3><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/system-design-part-1/"><img src="/images/2023-10-05-system-design-part-1/thumbnail.png" alt="대규모 시스템 디자인 Part 1 강의"></a></figure><div class="media-content"><p class="date"><time datetime="2023-10-04T15:00:00.000Z">2023-10-05</time></p><p class="title"><a href="/posts/etc/system-design-part-1/">대규모 시스템 디자인 Part 1 강의</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/go/go-scheduler/"><img src="/images/2021-10-18-about-go-range/logo.png" alt="Go Scheduler"></a></figure><div class="media-content"><p class="date"><time datetime="2022-05-24T15:00:00.000Z">2022-05-25</time></p><p class="title"><a href="/posts/go/go-scheduler/">Go Scheduler</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/go/about-go-range/"><img src="/images/2021-10-18-about-go-range/logo.png" alt="Go에서 range의 모든 것"></a></figure><div class="media-content"><p class="date"><time datetime="2021-10-17T15:00:00.000Z">2021-10-18</time></p><p class="title"><a href="/posts/go/about-go-range/">Go에서 range의 모든 것</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/shallow-knowledge-of-funtional-programming/"><img src="/images/2019-12-19-shallow-knowledge-of-functional-programming/thumbnail.png" alt="함수형 프로그래밍에 대한 얕은 지식"></a></figure><div class="media-content"><p class="date"><time datetime="2019-12-18T15:00:00.000Z">2019-12-19</time></p><p class="title"><a href="/posts/etc/shallow-knowledge-of-funtional-programming/">함수형 프로그래밍에 대한 얕은 지식</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article></div></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/database/etcd-client-model/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">etcd deep dive - Client Model</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/database/etcd-data-model/"><span class="level-item">etcd deep dive - Data Model</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="fb-comments" data-width="100%" data-href="https://changhoi.kim/posts/rust/rust-ownership/" data-num-posts="5"></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ko/sdk.js#xfbml=1&version=v12.0";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/34329147?s=400&amp;u=9d1b1dc88bc8ee5965f35b0160780264c3619eb6&amp;v=4" alt="Changhoi Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Changhoi Kim</p><p class="is-size-6 is-block">Co-Founder of Bayesians</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives/"><p class="title">73</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories/"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags/"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/changhoi/" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn" href="https://www.linkedin.com/in/changhoi/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/changhoi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Email" href="mailto:changhoi0522@gmail.com"><i class="fas fa-envelope-square"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="English" href="https://jayce.kim"><i class="fas fa-language"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/backend/"><span class="level-start"><span class="level-item">backend</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/books/"><span class="level-start"><span class="level-item">books</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/logs/"><span class="level-start"><span class="level-item">logs</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">os</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/serverless/"><span class="level-start"><span class="level-item">serverless</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Ownership-소유권"><span class="level-left"><span class="level-item">1</span><span class="level-item">Ownership (소유권)</span></span></a></li><li><a class="level is-mobile" href="#Variable"><span class="level-left"><span class="level-item">2</span><span class="level-item">Variable</span></span></a></li><li><a class="level is-mobile" href="#소유권-이전"><span class="level-left"><span class="level-item">3</span><span class="level-item">소유권 이전</span></span></a></li><li><a class="level is-mobile" href="#Copy-Clone"><span class="level-left"><span class="level-item">4</span><span class="level-item">Copy &amp; Clone</span></span></a></li><li><a class="level is-mobile" href="#함수와-Ownership"><span class="level-left"><span class="level-item">5</span><span class="level-item">함수와 Ownership</span></span></a></li><li><a class="level is-mobile" href="#참조와-소유권-대여"><span class="level-left"><span class="level-item">6</span><span class="level-item">참조와 소유권 대여</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Mutable-Reference-Data-Race-방지"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Mutable Reference Data Race 방지</span></span></a></li><li><a class="level is-mobile" href="#Dangling-Reference"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Dangling Reference</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">7</span><span class="level-item">Reference</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a><p class="is-size-7"><span>&copy; 2025 changhoi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="external nofollow noopener noreferrer" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>