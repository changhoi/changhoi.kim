<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Go GC - Changhoi Kim</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="white"><meta name="application-name" content="Changhoi Kim"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="white"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Changhoi Kim"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Go는 메모리 관리를 런타임에서 해주는 프로그래밍 언어이다. 메모리 관리라고 하면 일반적으로 힙 영역에 할당하는 메모리들 더이상 스택에서 접근할 수 없는 상태가 되면, 할당 해제하는 가비지 콜렉팅을 의미한다. 이번 글에서는 GC에 대한 전반적인 이야기와 함께, Go에서는 구체적으로 어떤지 알아보았다."><meta property="og:type" content="blog"><meta property="og:title" content="Go GC"><meta property="og:url" content="https://changhoi.kim/posts/go/go-gc/"><meta property="og:site_name" content="Changhoi Kim"><meta property="og:description" content="Go는 메모리 관리를 런타임에서 해주는 프로그래밍 언어이다. 메모리 관리라고 하면 일반적으로 힙 영역에 할당하는 메모리들 더이상 스택에서 접근할 수 없는 상태가 되면, 할당 해제하는 가비지 콜렉팅을 의미한다. 이번 글에서는 GC에 대한 전반적인 이야기와 함께, Go에서는 구체적으로 어떤지 알아보았다."><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://changhoi.kim/images/2022-03-25-go-gc/thumbnail.png"><meta property="article:published_time" content="2022-03-24T15:00:00.000Z"><meta property="article:modified_time" content="2022-03-24T15:00:00.000Z"><meta property="article:author" content="changhoi"><meta property="article:tag" content="gc"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://changhoi.kim/images/2022-03-25-go-gc/thumbnail.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://changhoi.kim/posts/go/go-gc/"},"headline":"Go GC","image":["https://changhoi.kim/images/2022-03-25-go-gc/thumbnail.png"],"datePublished":"2022-03-24T15:00:00.000Z","dateModified":"2022-03-24T15:00:00.000Z","author":{"@type":"Person","name":"changhoi"},"publisher":{"@type":"Organization","name":"Changhoi Kim","logo":{"@type":"ImageObject","url":"https://changhoi.kim/img/logo.jpg"}},"description":"Go는 메모리 관리를 런타임에서 해주는 프로그래밍 언어이다. 메모리 관리라고 하면 일반적으로 힙 영역에 할당하는 메모리들 더이상 스택에서 접근할 수 없는 상태가 되면, 할당 해제하는 가비지 콜렉팅을 의미한다. 이번 글에서는 GC에 대한 전반적인 이야기와 함께, Go에서는 구체적으로 어떤지 알아보았다."}</script><link rel="canonical" href="https://changhoi.kim/posts/go/go-gc/"><link rel="alternate" href="/rss2.xml" title="Changhoi Kim" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-QBSLW6WTZW" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-QBSLW6WTZW');</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/2022-03-25-go-gc/thumbnail.png" alt="Go GC"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2022-03-24T15:00:00.000Z" title="2022. 3. 24. 오전 8:00:00">2022-03-25</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2022-03-24T15:00:00.000Z" title="2022. 3. 24. 오전 8:00:00">2022-03-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/go/">go</a></span><span class="level-item">한 시간안에 읽기 (약 7270 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">Go GC</h1><div class="content"><p>Go는 메모리 관리를 런타임에서 해주는 프로그래밍 언어이다. 메모리 관리라고 하면 일반적으로 힙 영역에 할당하는 메모리들 더이상 스택에서 접근할 수 없는 상태가 되면, 할당 해제하는 가비지 콜렉팅을 의미한다. 이번 글에서는 GC에 대한 전반적인 이야기와 함께, Go에서는 구체적으로 어떤지 알아보았다.</p>
<span id="more"></span>

<blockquote>
<p>💡 우선 글은 1.17 버전의 코드를 보면서 작성되었다.<br>💡 글에서 <code>GC</code>라는 말은 “가비지 콜렉터”를 의미하기도 하고 “가비지 콜렉터의 동작”을 의미하기도 한다. 동사로 사용되었으면 콜렉터의 동작, 명사면 콜렉터라고 이해하면 좋을 것 같다.</p>
</blockquote>
<h1 id="흔히-알려진-설명"><a href="#흔히-알려진-설명" class="headerlink" title="흔히 알려진 설명"></a>흔히 알려진 설명</h1><p>GC에 대한 아주 개략적인 Overview이다. 현대 많은 언어는 GC와 함께 메모리 관리를 도와주고 있다. 일반적으로 프로그램에서 동적 할당을 하게 되면 프로세스의 힙(Heap) 영역에 메모리를 할당하게 되어있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 힙 사용</span></span><br></pre></td></tr></table></figure>

<p>이때, 힙 영역에 할당된 메모리를 할당 해제 해줘야 하는데, 이 과정을 개발자가 직접 하는 경우가 있고, 언어의 런타임 레벨에서 자동으로 해주는 경우가 있다. 이때 자동으로 해주는 컴포넌트의 이름이 GC이다.</p>
<p>GC는 대략 다음과 같은 흐름을 갖는다.</p>
<ol>
<li>GC 수행 시간 동안 GC 스레드를 제외하고 모든 스레드 정지</li>
<li>GC는 참조할 수 없는 객체를 확인하고 메모리 할당 해제</li>
<li>GC가 끝난 후 정지된 애플리케이션 스레드를 다시 재개</li>
</ol>
<p>1번의 정지되는 순간을 <strong>STW</strong> (<code>Stop The World</code>)라고 부른다. 이때 STW가 발생하는 순간은 GC 수행의 전체 과정이 아닐 수 있다. 어떤 알고리즘을 사용하는지에 따라 어떤 구간에서 STW가 발생할지 달라진다. 아무튼 GC가 발전하는 과정은 이 STW 시간을 줄이는 과정이고 GC를 튜닝하는 이유도 대부분 STW를 줄이기 위함이다.</p>
<h1 id="알려진-방법들"><a href="#알려진-방법들" class="headerlink" title="알려진 방법들"></a>알려진 방법들</h1><p>GC의 핵심적인 동작을 수행하는 두 가지 알고리즘을 가져왔다. 첫 번째는 <strong>Mark &amp; Sweep</strong> 방식이고, 두 번째는 <strong>Reference Counting</strong>이다.</p>
<h2 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark &amp; Sweep"></a>Mark &amp; Sweep</h2><p>이름이 아주 직관적인데, 말 그대로 지워야 하는 오브젝트를 마킹하고 청소하는 방법이다. 스택에서 힙을 참조하고 있는 루트 포인터를 찾아서 해당 루트 노드부터 체이닝 하면서 접근할 수 있는 오브젝트를 제거 대상에서 제외한다. 모두 순회하고 나서는 아직 제거 대상에 있는 오브젝트를 할당 해제하는 방식이다. Go와 JVM, JS에서 이 알고리즘을 사용한다.</p>
<p><img src="/images/2022-03-25-go-gc/marksweep.gif?style=centerme" alt="Mark &amp; Sweep"><br><small style="center">이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://deepu.tech/memory-management-in-programming/">링크</a></small></p>
<h2 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h2><p>모든 오브젝트들이 참조 횟수 카운터를 갖고, 카운터가 0이 되는 오브젝트를 GC가 지우는 방식이다. 이 방법은 Python, PHP에서 사용 중인데, 근본적으로 순환 참조하고 있는 오브젝트에 대한 GC가 이루어질 수 없다. 이를 처리하기 위한 추가적인 컴포넌트와 함께 동작해야 한다.</p>
<hr>
<p>여기 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">링크</a>에서 여러 GC들의 할당과 해제 모습을 시각화해서 보여주고 있다. 여기 작성된 알고리즘 외, 추가로 몇 가지가 더 설명되어 있으니 궁금하다면 위에서 간략하게 소개된 방법들에 대해 알아보면 좋을 것 같다.</p>
<h1 id="GC를-구성하는-것들"><a href="#GC를-구성하는-것들" class="headerlink" title="GC를 구성하는 것들"></a>GC를 구성하는 것들</h1><p>아! Go, JVM, JS는 Mark &amp; Sweep! 끄덕 끄덕, 하고 끝나면 좋겠지만 편한 프로그래밍의 뒷면은 그렇게 단순하지는 않다. 위에서 “<strong>알려진 방법들</strong>“로 소개한 방법들은 핵심적인 콜렉터의 동작 알고리즘에 관한 내용이고, GC를 구현한 언어에 따라 추가적인 기술이나 컴포넌트가 존재한다. Java의 GC가 굉장히 대표적이고 유명하다는 생각이 들어서, Go의 GC에 대한 구체적인 내용을 설명하기 전에 JVM에서 사용하고 있는 GC의 구성을 조금 더 살펴보고 이를 Go와 비교해보려고 한다.</p>
<h2 id="세대별-GC"><a href="#세대별-GC" class="headerlink" title="세대별 GC"></a>세대별 GC</h2><p>Generational GC라고 불리는 GC 방법이다. 세대별이라는 말은 힙 영역을 세대별로 나눠 관리한다는 것을 의미한다. “세대”는 오래 살아남은 객체와 그렇지 않은 객체를 구분 짓는 것을 의미한다. 이 GC는 다음과 같은 대전제를 바탕으로 설계되었다.</p>
<ol>
<li>대부분의 객체는 금방 접근 불가능 상태가 된다.</li>
<li>오래된 객체에서 새로운 객체를 참조하는 일은 드물게 발생한다.</li>
</ol>
<p>위 대전제의 이름은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html">Weak Generational Hypothesis</a>라고 한다. 이 가설을 이용해 <code>Old</code> 객체를 담는 영역과 <code>Young</code> 영역의 객체를 담는 영역으로 힙을 나눈다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;---- Tenured ----&gt;</span><br><span class="line">+----------+---+---+---------+---------+</span><br><span class="line">|   Eden   | S | S |         | Virtual |</span><br><span class="line">+----------+---+---+---------+---------+</span><br><span class="line">&lt;----- Young ------&gt;</span><br><span class="line"></span><br><span class="line">S: Survivor</span><br></pre></td></tr></table></figure>

<ul>
<li>Young 영역: 새롭게 생성된 객체가 위치한다. 가설대로 많은 객체가 이곳에서 새로 만들어졌다가 사라진다. 이곳에서 발생하는 GC는 <strong>Minor GC</strong>라고 불린다.</li>
<li>Old 영역: Young 영역에서 살아남은 객체가 여기 복사된다. Young 영역에 비해 크기가 크고, GC는 덜 자주 발생한다. 이곳에서 발생하는 GC는 <strong>Major GC</strong> 또는 <strong>Full GC</strong>라고 한다.</li>
</ul>
<p>이 방법을 통해 일반적인 상황에서는 Minor GC로 간단하게 GC를 수행하게 된다. 큰 힙 영역을 다 확인할 필요 없이 일부만 확인할 수 있으므로 GC 속도가 빠르다.</p>
<blockquote>
<p>💡 따라서 넓은 범위를 확인해야하는 Full GC가 자주 발생하는 상황은 문제가 있는 상황일 수 있다.</p>
</blockquote>
<p>만약 2번 전제 상황이 발생하였을 때 GC가 어떻게 Old 영역이 참조하고 있는 Young 영역의 객체를 할당 해제하지 않을 수 있을까? 이를 위해 Old 영역에서 Young 영역의 객체를 참조하고 있는지 기록하는 Card Table을 사용한다. 이 테이블은 512 바이트의 청크로, Old 영역을 모두 확인하지 않고도 이 부분을 확인함으로써 Young 영역의 객체가 지워지는 것을 방지할 수 있다.</p>
<h2 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h2><p>힙 영역에 메모리를 할당하고 해제하는 과정이 반복되면 단편화 문제가 발생할 수 있다. 짧게 단편화에 대해 설명하자면, 전체적인 메모리 양은 요청된 메모리를 할당하기에 충분한 양인데, 연속되지 않아서 할당할 수가 없는 상황을 <strong>외부 단편화</strong>라고 부른다. 메모리가 비효율적으로 사용되고 있는 상황이고, 이런 파편화된 메모리 상태에서는 메모리 할당을 위해 메모리 공간을 찾는 시간도 늘어난다.</p>
<blockquote>
<p>💡 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Mark-compact_algorithm">Mark-Compact 방식</a>을 쉽게 찾아볼 수 있었는데, 위에서 간단히 설명한 Mark &amp; Sweep 방식에서 컴팩팅을 추가한 방식이다. 마킹 페이즈 이후 컴팩팅 페이즈가 존재해서 데이터들을 압축하고 이동한 오브젝트의 포인터를 업데이트 하는 과정을 거치게 된다.</p>
</blockquote>
<h1 id="Go의-GC"><a href="#Go의-GC" class="headerlink" title="Go의 GC"></a>Go의 GC</h1><p>이제 Go에서 어떻게 GC를 구성하고 있는지 확인해보자. <a target="_blank" rel="external nofollow noopener noreferrer" href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.8:src/runtime/mgc.go">Go의 코드</a> 주석으로 설명된 바에 따르면 Go는 비세대별, 비압축, Concurrent Tri-color Mark &amp; Sweep이라고 한다.</p>
<ul>
<li>비세대별: 힙 영역을 세대별로 관리하지 않는다.</li>
<li>비압축: 힙 영역의 Compaction을 수행하지 않는다.</li>
<li>Concurrent Tri-color Mark &amp; Sweep: 마킹과 해제 과정이 STW 없이 애플리케이션과 동시에 동작하고, 삼색 마킹 알고리즘으로 구현되어 있다.</li>
</ul>
<h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p>Go GC는 세 개의 페이즈를 수행한다. 이 페이즈들 중 두 개는 STW를 유발하고, 다른 한 페이즈는 애플리케이션의 CPU 처리량을 느리게 만든다. 세 개의 페이즈는 다음과 같다.</p>
<ul>
<li>Mark 준비 - STW</li>
<li>Marking - Concurrent</li>
<li>Mark 종료 - STW</li>
</ul>
<h3 id="Mark-준비-STW"><a href="#Mark-준비-STW" class="headerlink" title="Mark 준비 - STW"></a>Mark 준비 - STW</h3><p>GC가 시작되면서 가장 먼저 해야 할 일은 <strong>Write Barrier</strong>가 동작하도록(Enabled) 만드는 것이다. Go에서 Write Barrier는 동시적인 GC 마킹 과정에서도 힙 영역의 데이터 정합성을 유지해주는 장치이다. 위에서 살짝 써놨는데, 마킹 단계는 애플리케이션 고루틴과 GC 고루틴이 동시에 동작한다. 마킹을 하던 도중 애플리케이션 고루틴에서 힙 영역에 대한 변경 작업을 하게 되면 GC도 이를 인지하고 적절한 조치를 취해야 한다. 이것을 가능하게 해주는 것이 Write Barrier이다. 구체적으로 어떻게 해주는지는 이후 설명한다.</p>
<blockquote>
<p>💡 Write Barrier라는 용어나 컴포넌트가 Go GC의 특수한 개념은 아니다. 동시적인 힙 영역에 대한 접근을 하기에 앞서 필요한 전처리 작업을 해주는 장치 정도로 사용이 되는 것 같은데, Java에서는 Old 영역에서 Young 영역을 참조할 때 Card Table에 기록하는 역할을 Write Barrier가 한다.</p>
</blockquote>
<p>Write Barrier가 시작되려면 모든 애플리케이션의 고루틴들이 멈춰야 한다. 일반적으로 이 동작은 아주 빨라서 STW가 거의 발생하지 않는 것처럼 보인다.</p>
<h3 id="Marking-Concurrent"><a href="#Marking-Concurrent" class="headerlink" title="Marking - Concurrent"></a>Marking - Concurrent</h3><p>Write Barrier가 켜지고 나면 마킹이 시작된다. GC가 이 단계에서 처음 하는 일은 25% 정도의 CPU 처리량을 가져오는 것이다. 예를 들어 4개의 P가 있으면 그중 하나는 GC를 수행하기 위해 점유(dedicated)된다.</p>
<p><img src="/images/2022-03-25-go-gc/gc-dedicated.png?style=centerme" alt="Dedicated Goroutine"></p>
<blockquote>
<p>💡 위 이미지는 Go의 고루틴 스케줄링에 대해 알고 있으면 이해가 편한데, 만약 모른다면 사용 중인 스레드 중 하나가 점유된 이미지라고 이해하자. 그러나 엄밀히 말하면 틀린 소리기 때문에 시간이 된다면 Go GMP 구조에 대해 알아보자.</p>
</blockquote>
<p>그다음 진짜 마킹을 하게 된다. 일단 현재 존재하는 모든 애플리케이션 고루틴 스택을 확인하면서 힙을 참조하고 있는 포인터를 확인한다. 스택을 스캔하는 과정은 해당 고루틴을 멈추게 한다. 하지만 그 이후 힙 안에서 오브젝트들을 따라가는 과정은 애플리케이션 고루틴과 동시에 동작한다. 다만 25%가량의 CPU 처리량을 사용하지 못하기 때문에 그만큼의 성능 저하가 발생한다.</p>
<p>만약 할당 속도가 너무 빨라서 고루틴이 사용 중인 힙 메모리 한계에 도달 전에 마킹 작업이 완료되지 못한다면 어떻게 될까? 할당이 지속되어 해당 오브젝트를 마킹 하느라 마킹 작업이 끝나지 않는다면? 이 상황이면 고루틴의 할당 속도를 낮출 필요가 있다.</p>
<p>GC가 힙 할당 속도를 제어해야 하는 상황이 되면 애플리케이션 고루틴 중에서 마킹 작업을 도와줄 어시스트 고루틴을 선정한다. 이를 <strong>Mark Assist</strong>라고 부른다. 애플리케이션 고루틴이 Mark Assist 역할을 하는 시간은 힙 영역에 추가되는 데이터 양에 비례한다. Mark Assist가 선정되면 그만큼 애플리케이션의 할당 속도는 줄고, 마킹 작업 속도가 빨라지는 효과가 있다. 그러나 애플리케이션 로직을 수행하는 비율이 더 줄어드는 것이기 때문에 속도 저하의 원인이 되기도 한다.</p>
<hr>
<p>Tri-color Mark &amp; Sweep에 대해 자세히 알아보자. 아래 이미지가 알고리즘 방식이다.</p>
<p><img src="/images/2022-03-25-go-gc/tricolor.gif?style=centerme" alt="Tri-color Mark &amp; Sweep"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://programming.vip/docs/deep-understanding-of-go-garbage-recycling-mechanism.html">링크</a></small></p>
<ol>
<li>먼저 모든 오브젝트는 하얀색 집합에서 시작한다.</li>
<li>루트 오브젝트를 회색 마킹한다.</li>
<li>회색으로 마킹된 오브젝트를 순회하면서 참조하고 있는 오브젝트들을 회색으로 칠한다.</li>
<li>순회를 마친 회색 오브젝트는 검은색으로 마킹한다.</li>
<li>3, 4번 스탭을 회색 오브젝트가 없어질 때까지 반복한다.</li>
<li>여전히 흰색 집합에 있는 오브젝트를 할당 해제한다.</li>
</ol>
<p>위 과정은 STW 상태가 아니기 때문에 동시에 오브젝트 변경이 지속해서 발생한다. 위에서 언급한 것처럼 GC가 동작하는 도중에 애플리케이션 고루틴이 힙에 변경을 가하면 Write Barrier가 적절한 조치를 취한다. 예를 들어서 GC 도중 스택에서 새롭게 할당하는 오브젝트는 바로 검은색으로 마킹한다.</p>
<p>이미 존재하는 오브젝트 트리 구조에서 변경점이 생기면 Write Barrier에서는 변경이 생기기 전 <code>Original Pointer</code>와 변경이 생긴 <code>New Pointer</code>를 기록하고 두 포인터 모두 마킹 처리를 한다.</p>
<p><code>Original Pointer</code>에 마킹처리를 하는 이유는 포인터 값을 스택이나 레지스터에 복사해두는 경우, Write Barrier를 거치지 않기 때문이다. Write Barrier는 힙 영역을 대상으로 발생하는 변경 점에 대한 전처리 작업을 하는 것이기 때문에, 로컬 스택이나 레지스터에 복사가 발생했는지 알 수 없다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">go</span>] b = obj</span><br><span class="line">[<span class="keyword">go</span>] oldx = <span class="literal">nil</span></span><br><span class="line">[gc] scan oldx...</span><br><span class="line">[<span class="keyword">go</span>] oldx = b.x <span class="comment">// b.x를 Write Barrier를 거치지 않고 로컬 변수 oldx에 복사한다.</span></span><br><span class="line">[<span class="keyword">go</span>] b.x = ptr <span class="comment">// Write Barrier는 원래 b.x 값 역시 체크한다.</span></span><br><span class="line">[gc] scan b...</span><br><span class="line"><span class="comment">//만약 Write Barrier가 원래 값을 마킹하지 않는다면 oldx가 스캔 되지 않는다.</span></span><br></pre></td></tr></table></figure>

<p>위와 같은 상황처럼, 스택에 복사된 상태로 사용할 때, 스캔하면서 할당 해제되는 상황을 막아준다.</p>
<p><code>New Pointer</code> 역시 마킹 처리하는 이유는 다른 고루틴에서 포인터의 위치를 바꿀 수 있기 때문이다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">go</span>] a = ptr</span><br><span class="line">[<span class="keyword">go</span>] b = obj</span><br><span class="line">[gc] scan b...</span><br><span class="line">[<span class="keyword">go</span>] b.x = a <span class="comment">// Write Barrier는 새로운 b.x 값을 마킹하도록 한다.</span></span><br><span class="line">[<span class="keyword">go</span>] a = <span class="literal">nil</span></span><br><span class="line">[gc] scan a...</span><br><span class="line"><span class="comment">//만약 새로운 값을 마킹하지 않는다면, ptr 값은 스캔 되지 않는다.</span></span><br></pre></td></tr></table></figure>
<p>위 상황처럼 만약 Write Barrier가 없다면 이미 스캔을 진행한 오브젝트에 아직 스캔을 진행하지 않은 포인터가 붙고 기존의 포인터를 담던 변수에서 제거되면 해당 힙 오브젝트가 스캔 되지 않을 수 있다.</p>
<p>이런 이유로 Write Barrier가 <code>Original Pointer</code>, <code>New Pointer</code> 모두 마킹 작업을 수행하도록 만들어주고, 동시적인 상황에서도 안전하게 힙 마킹을 유지할 수 있다.</p>
<h3 id="Mark-종료-STW"><a href="#Mark-종료-STW" class="headerlink" title="Mark 종료 - STW"></a>Mark 종료 - STW</h3><p>마킹 작업이 끝나면 Write Barrier와 Mark Assist를 종료하고 다음 GC가 동작할 목표치를 계산하게 된다. 이 과정은 STW 없이 동작할 수 있는데, 구현 시 코드 복잡성이 과하게 증가하는 반면 그에 비해 얻는 이점이 너무 작아 STW 상태로 진행된다고 한다.</p>
<p>다음 GC 수행을 위한 목표치 계산 알고리즘을 <strong>Pacing Algorithm</strong>이라고 부른다. 알고리즘은 콜렉터가 실행 중인 애플리케이션의 힙 사이즈 정보와, 힙에 가해지는 강도(Stress)에 의해 정의된다. Go에서는 GC Percent 값을 Go 환경 변숫값으로 설정해 GC가 동작하는 속도를 조절할 수 있다. 이 환경 변수 이름은 <code>GOGC</code>인데, 기본값은 100이다. 이는 현재 정리된 이후 힙 메모리보다 100% 커지면 다시 GC가 동작한다는 것을 의미한다. 즉, 기본값으로는 대략 2배 사이즈가 될 때마다 GC가 동작한다.</p>
<h3 id="Sweep-과정"><a href="#Sweep-과정" class="headerlink" title="Sweep 과정?"></a>Sweep 과정?</h3><p>어떤 글에서는 Sweep 페이즈에 대해 따로 페이즈로 나눠서 설명하기도 하는데, 이는 GC 사이클과 조금 독립적으로 동작하기 때문에 GC의 페이즈로 설명하지 않았다. Sweep은 애플리케이션과 함께 동시적으로 동작하는데, 애플리케이션에서 힙 영역에 할당을 요청했을 때 필요한 경우 삭제 처리된 오브젝트를 게으르게 할당 해제한다. 즉, 할당 시점에 Sweep이 발생하고 GC 수행 시간과는 무관하다. 그리고 다음 GC가 수행되기 전까지 아직 청소되지 않은 메모리 영역이 있다면, 모두 클린업 처리해주면서 다음 GC가 시작된다.</p>
<h2 id="비압축-방식"><a href="#비압축-방식" class="headerlink" title="비압축 방식"></a>비압축 방식</h2><p>압축을 통해 단편화 문제를 해결할 수 있는데, Go는 이 방법을 사용하고 있지 않다. 그렇다면 이 문제는 어떻게 해결하고 있을까? 이 문제는 현대 메모리 할당 방식에서 많이 해결해주고 있다고 한다. 전통적으로 프로세스 안에서 힙을 공유해 메모리를 할당해주는 방식은 멀티 스레드 프로그래밍에서는 그다지 적합한 방식이 아니다. 힙에 접근해 할당하는 과정에 Lock이 필요하기 때문이다. Go는 Google에서 만든 <strong>TCMalloc</strong>이라는 메모리 할당 방식을 활용하고 있다.</p>
<blockquote>
<p>💡 “TCMalloc Like”라고 표현하던데, <a target="_blank" rel="external nofollow noopener noreferrer" href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a> 방법을 사용했다고 이해해도 무방할 것 같다.</p>
</blockquote>
<h3 id="메모리-할당-방법-Overview"><a href="#메모리-할당-방법-Overview" class="headerlink" title="메모리 할당 방법 Overview"></a>메모리 할당 방법 Overview</h3><p>조금 개괄적으로 설명하자면, TCMalloc은 중앙 힙과 함께 스레드마다 로컬 스레드 캐시를 가지고 있고, 작은 할당은 로컬 스레드 캐시에서 해결한다. 필요에 따라 로컬 스레드 캐시에 새로운 메모리 영역을 할당해주거나, 중앙 힙에서 직접 큰 메모리 덩어리를 떼어 사용하기도 한다. 로컬 스레드 캐시로 인해 Lock이 필요 없는 할당이 빠르게 진행되기도 하고, 힙의 파편화된 영역을 최소화할 수 있는 원리로 작용하는 것 같다.</p>
<hr>
<p>아래 구체적인 내용은 몰라도 남은 내용들을 이해하는 데 문제가 없다. 궁금한 사람들은 보기로 하자.</p>
<h3 id="작은-메모리-할당"><a href="#작은-메모리-할당" class="headerlink" title="작은 메모리 할당"></a>작은 메모리 할당</h3><p>위에서 짧게 설명했지만, 작은 메모리를 할당하는 전략과 큰 메모리를 할당하는 전략이 다르다. 작은(32kb 이하) 할당을 할 때는 로컬 캐시인 <code>mcache</code>라고 불리는 메모리를 가져오려고 한다. 이 캐시는 32kb 짜리 청크 리스트인 <code>mspan</code> 리스트를 가지고 있다.</p>
<p><img src="/images/2022-03-25-go-gc/mcache.png?style=centerme" alt="mcache &amp; mspan"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">링크</a></small></p>
<p>고루틴 G를 처리하는 P에서 물고 있는 <code>mspan</code> 중 하나의 캐시를 사용해서 작은 범위의 할당을 한다. 이 과정은 힙 영역이 아니라서 Lock이 불필요하다. <code>mspan</code>은 32kb를 여러 사이즈로 나눈 여러 종류로 가지고 있다. 8bytes부터 32kb까지 클래스가 나눠진다.</p>
<p><img src="/images/2022-03-25-go-gc/mspan-class.png?style=centerme" alt="mspan 클래스"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">링크</a></small></p>
<p>그럼 만약 할당하려고 할 때 이 <code>mspan</code> 리스트에 충분한 슬롯이 없다면 어떻게 될까? Go는 중앙에 <code>mcentral</code>이라고 하는 메모리 공간을 관리한다. <code>mcentral</code>에는 두 가지 종류의 스판 리스트가 있다. 하나는 꽉 찬 스판과 다른 하나는 그렇지 않은 스판 리스트이다.</p>
<p><img src="/images/2022-03-25-go-gc/mcentral.png?style=centerme" alt="mcentral"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">링크</a></small></p>
<p><code>mcentral</code>에서는 스판 리스트가 양방향 연결 리스트로 되어있다. <code>mcache</code>에서 <code>mspan</code>이 꽉차게 되면 <code>mcentral</code>에서 빈 스판 리스트를 가져온다.</p>
<p><img src="/images/2022-03-25-go-gc/new-mspan.png?style=centerme" alt="새로운 mspan"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">링크</a></small></p>
<p>만약 <code>mcentral</code>에서 제공할 수 있는 리스트가 없으면 힙에서 새로 할당받는다.</p>
<p><img src="/images/2022-03-25-go-gc/new-mcentral.png?style=centerme" alt="새로운 mcentral 스판 리스트"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">링크</a></small></p>
<p>힙이 메모리가 더 필요한 경우 OS로부터 메모리를 가져온다. 이때 새롭게 할당하는 영역은 <code>arena</code>라고 불리는 커다란 메모리 덩어리이다. 64bits 아키텍처일 때 64MB를 할당받고, 32bits인 경우 4MB를 할당받는다.</p>
<h3 id="큰-메모리-할당"><a href="#큰-메모리-할당" class="headerlink" title="큰 메모리 할당"></a>큰 메모리 할당</h3><p>32kb보다 큰 메모리를 할당하게 되면 로컬 캐시를 사용하지 않는다. 할당되는 메모리 사이즈는 페이즈 사이즈로 올림 처리해 힙에 직접 할당한다.</p>
<hr>
<p>대략적인 전체 흐름 이미지는 다음과 같다.<br><img src="/images/2022-03-25-go-gc/memory-overview.png?style=centerme" alt="Overview"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">링크</a></small></p>
<h2 id="비세대별-GC"><a href="#비세대별-GC" class="headerlink" title="비세대별 GC"></a>비세대별 GC</h2><p>힙 메모리를 스캔하는 범위를 좁히는 방법으로 비세대별 GC에 관해 설명했었다. Go에서는 이 부분이 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU/m/wdBUH1mHCAAJ">도입되면 충분히 장점이 있을 것이라고 하지만</a>, 현재는 도입된 상태가 아니라고 한다.</p>
<p>Go에서는 컴파일 최적화 과정인 Escape Analysis 단계에서 다른 언어와 다르게 실제 동적 할당하는 많은 부분을 스택에 할당하도록 한다. 세대별 알고리즘의 대전제인 “많은 오브젝트들은 수명이 짧다”에 해당하는 부분을 스택에 할당함으로써 GC의 대상이 아니게 만들어준다. 따라서 다른 언어에 비해 세대별 GC를 사용하는 것으로 생길 수 있는 장점이 비교적 작다.</p>
<hr>
<p>일단 여기까지 내용이 Go의 GC가 어떻게 동작하는지, 그리고 왜 이런지에 관한 내용이다. 이후는 GC를 컨트롤하려는 케이스를 예시로 가져왔다. 위 내용을 모두 포함하고 있어서, 잘 이해했다면 아래 내용이 재밌다.</p>
<h1 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h1><h2 id="GC-Tuning-옵션에-관한-이야기"><a href="#GC-Tuning-옵션에-관한-이야기" class="headerlink" title="GC Tuning 옵션에 관한 이야기"></a>GC Tuning 옵션에 관한 이야기</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://youtu.be/uyifh6F_7WM">dotGo 2019 컨퍼런스</a>에서 Go GC를 어떻게 쓸 수 있는지 설명한 얘기가 있다. Go는 GC 관련 설정을 할 수 있는 방법이 위에서 언급한 <code>GOGC</code> 환경 변숫값 하나뿐이다. 다음 두 가지 상황에서 <code>GOGC</code>가 어떻게 될지 설명하고 있다.</p>
<ul>
<li><p>상황 1: 안정적인 큰 데이터셋이 있다면?<br>예를 들어서 20GB가 고정된 사이즈의 데이터라고 해보자. <code>GOGC=100</code>이라면 다음 GC는 40GB가 될 때 발생한다. 메모리 낭비가 굉장히 심한 상황인데 <code>GOGC=50</code>으로 바꾸면 30GB에 동작하게 바뀐다.</p>
</li>
<li><p>상황 2: 고정된 데이터 사이즈가 없는 애플리케이션 (작은 힙을 가지고 시작)<br>10MB의 힙 사이즈를 들고 시작했다고 가정해보자. GC는 20MB에 발생할 것이고, 정리되고 나서도 금방 다음 GC 사이클이 돌아온다. 이런 경우 <code>GOGC</code> 사이즈를 조금 여유있게 잡아주면 GC가 덜 발생한다.</p>
</li>
</ul>
<hr>
<p>위 컨퍼런스의 내용을 대충 요약하면 고정 메모리 소비량이 많으면 메모리 효율성을 위해 <code>GOGC</code> 값을 줄이고, 그 반대 상황에서는 GC 사이클을 줄이기 위해 <code>GOGC</code> 값을 크게 만들자는 내용이다. 굉장히 단순한 방법.</p>
<h2 id="Twitch에서-Go-애플리케이션의-힙-사이즈를-수동으로-조절해-GC-OPS를-줄인-이야기"><a href="#Twitch에서-Go-애플리케이션의-힙-사이즈를-수동으로-조절해-GC-OPS를-줄인-이야기" class="headerlink" title="Twitch에서 Go 애플리케이션의 힙 사이즈를 수동으로 조절해 GC OPS를 줄인 이야기"></a>Twitch에서 Go 애플리케이션의 힙 사이즈를 수동으로 조절해 GC OPS를 줄인 이야기</h2><p>Twitch는 Visage라는 프론트앤드가 바라보고 있는 API Gateway 앱을 가지고 있다. 이 앱은 EC2 + LoadBalancer 위에서 돌고있는 Go 애플리케이션이다. AWS 컴포넌트로 기본적인 스케일링 처리가 가능하지만, 애플리케이션 자체적으로 CPU 처리량이 급격히 떨어지는 상황이 있었다고 한다. Twitch에서는 이를 “리프레시 스톰”이라고 불렀다. 인기 있는 방송인의 인터넷 상태가 안 좋아지는 경우 시청자들이 다 같이 새로고침을 연타하는 경우 생기는 문제이기 때문이다. 이 경우에는 평소보다 약 20배가 넘는 트래픽을 유발한다고 한다.</p>
<p>트위치는 Go 프로파일링 옵션을 프로덕션에서도 켜놔서 쉽게 프로파일링 결과를 얻을 수 있었는데, 다음과 같은 보고를 얻었다고 한다.</p>
<ul>
<li>안정적인 상태에서는 GC가 초당 8 - 10회 발생 (8 ~ 10 OPS)</li>
<li>30%의 CPU 사이클이 GC와 유관한 함수를 호출하기 위해 사용</li>
<li>리프래시 스톰 상황에서는 GC OPS 급증</li>
<li>평균적인 힙 사이즈는 450MiB</li>
</ul>
<blockquote>
<p>💡 프로파일링 옵션을 켜두는 것이 그렇게 오버헤드가 있지는 않다고 한다. Excution tracer는 오버헤드가 있을 수 있는데 시간당 몇 초 정도 수행할 정도로 수행 빈도가 별로 안된다고 한다.</p>
</blockquote>
<p>GC OPS를 줄이고 STW 시간을 줄일 목적으로 밸러스트(바닥짐, Ballast)를 수동으로 만들어줬다. 앱이 시작할 때 아주 큰 메모리 사이즈를 힙에 할당해버리는 방법이었다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 10 GiB 할당 해버리기</span></span><br><span class="line"> ballast := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>&lt;&lt;<span class="number">30</span>)</span><br><span class="line"> <span class="comment">// 앱 실행 진행</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>기본 <code>GOGC</code>를 유지한 상태였기 때문에, 밸러스트를 만듦으로써 약 10GB의 할당이 더 발생해야 GC가 동작했다. 결과적으로는 GC OPS가 99% 감소했다.</p>
<p><img src="/images/2022-03-25-go-gc/twitch-gc-rate.png?style=centerme" alt="GC Rate"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/">링크</a></small></p>
<p>CPU 활용도 30%가량 내려갔다.</p>
<p><img src="/images/2022-03-25-go-gc/twitch-cpu-util.png?style=centerme" alt="CPU Utilization"><br><small>이미지 출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/">링크</a></small></p>
<p><code>GOGC</code>를 설정하지 않고 직접 밸러스트를 만든 이유는 다음과 같다.</p>
<ul>
<li>GC 발생 비율은 관계가 없고, 총 메모리 사용량이 더 중요한 상황</li>
<li>밸러스트와 같은 효과를 발생시키려면 아주 큰 <code>GOGC</code>가 필요한데, 그렇게 하면 힙에 유지되는 메모리의 크기 변경에 아주 민감해짐</li>
<li>라이브 메모리와 변화하는 비율을 추론하는 것 보다, 전체 메모리를 추론하는 것이 훨씬 쉬움</li>
</ul>
<p>그렇다면 소중한 10GiB 메모리가 그대로 소비되는 것은 아닐까? 실제 시스템 메모리는 OS에 의해 페이지 테이블을 통해 가상 주소가 지정되고 물리 메모리와 매핑된다. 위 밸러스트를 설정하는 코드가 실행되면 가상 메모리에 배열이 할당되고 실제 읽기 쓰기를 시도하면 페이지 폴트가 발생하면서 실제 메모리에 적재하는 과정이 발생한다. 따라서, 밸러스트가 물리 메모리를 차지하고 있지는 않다.</p>
<p>API 레이턴시 역시 많이 향상되었는데, Twitch는 처음에는 STW 자체가 줄어서라고 생각했지만, 실제로 STW가 줄어든 절대적인 시간 자체는 아주 짧았다. 실제로 성능 향상에 많은 영향을 줬던 것은 Mark Assist가 줄었기 때문이다. 위에서 언급했던 것처럼 Mark Assist가 동작하면 애플리케이션 입장에서는 CPU 처리량을 더 뺏기는 것이기 때문에 처리량이 줄어든다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://deepu.tech/memory-management-in-programming/">https://deepu.tech/memory-management-in-programming/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/">https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://d2.naver.com/helloworld/1329">https://d2.naver.com/helloworld/1329</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Mark-compact_algorithm">https://en.wikipedia.org/wiki/Mark-compact_algorithm</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.8:src/runtime/mgc.go">https://cs.opensource.google/go/go/+/refs/tags/go1.17.8:src/runtime/mgc.go</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://programming.vip/docs/deep-understanding-of-go-garbage-recycling-mechanism.html">https://programming.vip/docs/deep-understanding-of-go-garbage-recycling-mechanism.html</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU/m/wdBUH1mHCAAJ">https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU/m/wdBUH1mHCAAJ</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Escape_analysis">https://en.wikipedia.org/wiki/Escape_analysis</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://youtu.be/uyifh6F_7WM">https://youtu.be/uyifh6F_7WM</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/">https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Go GC</p><p><a href="https://changhoi.kim/posts/go/go-gc/">https://changhoi.kim/posts/go/go-gc/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>changhoi</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-03-25</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-03-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/gc/">gc</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="title is-5">관련 글</h3><article class="media"><figure class="media-left"><a class="image" href="/posts/go/go-pkg-architecture-theory/"><img src="/images/2023-07-13-go-pkg-architecture/thumbnail.png" alt="Go Package Architecture - 이론편"></a></figure><div class="media-content"><p class="date"><time datetime="2023-07-12T15:00:00.000Z">2023-07-13</time></p><p class="title"><a href="/posts/go/go-pkg-architecture-theory/">Go Package Architecture - 이론편</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/go/go-scheduler/"><img src="/images/2021-10-18-about-go-range/logo.png" alt="Go Scheduler"></a></figure><div class="media-content"><p class="date"><time datetime="2022-05-24T15:00:00.000Z">2022-05-25</time></p><p class="title"><a href="/posts/go/go-scheduler/">Go Scheduler</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/go/about-go-range/"><img src="/images/2021-10-18-about-go-range/logo.png" alt="Go에서 range의 모든 것"></a></figure><div class="media-content"><p class="date"><time datetime="2021-10-17T15:00:00.000Z">2021-10-18</time></p><p class="title"><a href="/posts/go/about-go-range/">Go에서 range의 모든 것</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article></div></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/books/learning-go/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Learning Go 간단 리뷰</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/backend/grpc-internals/"><span class="level-item">gRPC를 지탱하는 기술</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="fb-comments" data-width="100%" data-href="https://changhoi.kim/posts/go/go-gc/" data-num-posts="5"></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ko/sdk.js#xfbml=1&version=v12.0";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/34329147?s=400&amp;u=9d1b1dc88bc8ee5965f35b0160780264c3619eb6&amp;v=4" alt="Changhoi Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Changhoi Kim</p><p class="is-size-6 is-block">Co-Founder of Bayesians</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives/"><p class="title">73</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories/"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags/"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/changhoi/" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn" href="https://www.linkedin.com/in/changhoi/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/changhoi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Email" href="mailto:changhoi0522@gmail.com"><i class="fas fa-envelope-square"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="English" href="https://jayce.kim"><i class="fas fa-language"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/backend/"><span class="level-start"><span class="level-item">backend</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/books/"><span class="level-start"><span class="level-item">books</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/logs/"><span class="level-start"><span class="level-item">logs</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">os</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/serverless/"><span class="level-start"><span class="level-item">serverless</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#흔히-알려진-설명"><span class="level-left"><span class="level-item">1</span><span class="level-item">흔히 알려진 설명</span></span></a></li><li><a class="level is-mobile" href="#알려진-방법들"><span class="level-left"><span class="level-item">2</span><span class="level-item">알려진 방법들</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Mark-Sweep"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Mark &amp; Sweep</span></span></a></li><li><a class="level is-mobile" href="#Reference-Counting"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Reference Counting</span></span></a></li></ul></li><li><a class="level is-mobile" href="#GC를-구성하는-것들"><span class="level-left"><span class="level-item">3</span><span class="level-item">GC를 구성하는 것들</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#세대별-GC"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">세대별 GC</span></span></a></li><li><a class="level is-mobile" href="#Compaction"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Compaction</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Go의-GC"><span class="level-left"><span class="level-item">4</span><span class="level-item">Go의 GC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Collector"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Collector</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Mark-준비-STW"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">Mark 준비 - STW</span></span></a></li><li><a class="level is-mobile" href="#Marking-Concurrent"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">Marking - Concurrent</span></span></a></li><li><a class="level is-mobile" href="#Mark-종료-STW"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">Mark 종료 - STW</span></span></a></li><li><a class="level is-mobile" href="#Sweep-과정"><span class="level-left"><span class="level-item">4.1.4</span><span class="level-item">Sweep 과정?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#비압축-방식"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">비압축 방식</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#메모리-할당-방법-Overview"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">메모리 할당 방법 Overview</span></span></a></li><li><a class="level is-mobile" href="#작은-메모리-할당"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">작은 메모리 할당</span></span></a></li><li><a class="level is-mobile" href="#큰-메모리-할당"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">큰 메모리 할당</span></span></a></li></ul></li><li><a class="level is-mobile" href="#비세대별-GC"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">비세대별 GC</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Case-Study"><span class="level-left"><span class="level-item">5</span><span class="level-item">Case Study</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#GC-Tuning-옵션에-관한-이야기"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">GC Tuning 옵션에 관한 이야기</span></span></a></li><li><a class="level is-mobile" href="#Twitch에서-Go-애플리케이션의-힙-사이즈를-수동으로-조절해-GC-OPS를-줄인-이야기"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">Twitch에서 Go 애플리케이션의 힙 사이즈를 수동으로 조절해 GC OPS를 줄인 이야기</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">6</span><span class="level-item">Reference</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a><p class="is-size-7"><span>&copy; 2025 changhoi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="external nofollow noopener noreferrer" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>