<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Go Scheduler - Changhoi Kim</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="white"><meta name="application-name" content="Changhoi Kim"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="white"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Changhoi Kim"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Go는 많은 것들을 “알아서” 해준다. 그래서 Go는 빌드 또는 실행 옵션이 다른 언어에 비해서 적은 편이다. Go의 가장 핵심적인 부분이라고 할 수 있는 고루틴 역시 Go의 런타임에서 알아서 관리해주고 있다. Go를 사용하면서 Go의 스케줄러를 알고 있어야만 하는 경우는 많지 않지만, 더 잘 쓰기 위해 조금 디테일한 런타임 동작에 대해 알아보자."><meta property="og:type" content="blog"><meta property="og:title" content="Go Scheduler"><meta property="og:url" content="https://changhoi.kim/posts/go/go-scheduler/"><meta property="og:site_name" content="Changhoi Kim"><meta property="og:description" content="Go는 많은 것들을 “알아서” 해준다. 그래서 Go는 빌드 또는 실행 옵션이 다른 언어에 비해서 적은 편이다. Go의 가장 핵심적인 부분이라고 할 수 있는 고루틴 역시 Go의 런타임에서 알아서 관리해주고 있다. Go를 사용하면서 Go의 스케줄러를 알고 있어야만 하는 경우는 많지 않지만, 더 잘 쓰기 위해 조금 디테일한 런타임 동작에 대해 알아보자."><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://changhoi.kim/images/2021-10-18-about-go-range/logo.png"><meta property="article:published_time" content="2022-05-24T15:00:00.000Z"><meta property="article:modified_time" content="2022-05-24T15:00:00.000Z"><meta property="article:author" content="changhoi"><meta property="article:tag" content="programming"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://changhoi.kim/images/2021-10-18-about-go-range/logo.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://changhoi.kim/posts/go/go-scheduler/"},"headline":"Go Scheduler","image":["https://changhoi.kim/images/2021-10-18-about-go-range/logo.png"],"datePublished":"2022-05-24T15:00:00.000Z","dateModified":"2022-05-24T15:00:00.000Z","author":{"@type":"Person","name":"changhoi"},"publisher":{"@type":"Organization","name":"Changhoi Kim","logo":{"@type":"ImageObject","url":"https://changhoi.kim/img/logo.jpg"}},"description":"Go는 많은 것들을 “알아서” 해준다. 그래서 Go는 빌드 또는 실행 옵션이 다른 언어에 비해서 적은 편이다. Go의 가장 핵심적인 부분이라고 할 수 있는 고루틴 역시 Go의 런타임에서 알아서 관리해주고 있다. Go를 사용하면서 Go의 스케줄러를 알고 있어야만 하는 경우는 많지 않지만, 더 잘 쓰기 위해 조금 디테일한 런타임 동작에 대해 알아보자."}</script><link rel="canonical" href="https://changhoi.kim/posts/go/go-scheduler/"><link rel="alternate" href="/rss2.xml" title="Changhoi Kim" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-QBSLW6WTZW" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-QBSLW6WTZW');</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/2021-10-18-about-go-range/logo.png" alt="Go Scheduler"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2022-05-24T15:00:00.000Z" title="2022. 5. 24. 오전 8:00:00">2022-05-25</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2022-05-24T15:00:00.000Z" title="2022. 5. 24. 오전 8:00:00">2022-05-25</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/go/">go</a></span><span class="level-item">30분안에 읽기 (약 4427 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">Go Scheduler</h1><div class="content"><p>Go는 많은 것들을 “알아서” 해준다. 그래서 Go는 빌드 또는 실행 옵션이 다른 언어에 비해서 적은 편이다. Go의 가장 핵심적인 부분이라고 할 수 있는 고루틴 역시 Go의 런타임에서 알아서 관리해주고 있다. Go를 사용하면서 Go의 스케줄러를 알고 있어야만 하는 경우는 많지 않지만, 더 잘 쓰기 위해 조금 디테일한 런타임 동작에 대해 알아보자.</p>
<span id="more"></span>

<h1 id="Go-Runtime-Scheduler"><a href="#Go-Runtime-Scheduler" class="headerlink" title="Go Runtime Scheduler"></a>Go Runtime Scheduler</h1><p>고루틴은 런타임 스케줄러에 의해 관리된다. 아래 원칙을 기준으로 고루틴을 적절히 스케줄링 한다.</p>
<ul>
<li>OS Thread는 비싸기 때문에 되도록 적은 수를 유지한다.</li>
<li>많은 수의 고루틴을 실행해 높은 동시성을 유지한다.</li>
<li>N 코어의 머신에서 N개의 고루틴이 병렬적으로 동작할 수 있게 한다.</li>
</ul>
<p>스케줄러가 동작하는 4가지 이벤트가 있다. 이 이벤트를 마주하면 스케줄러가 동작할 기회를 얻게 된다.</p>
<ul>
<li><code>go</code> 키워드를 사용해 새로운 고루틴을 만들고자 할 때</li>
<li>GC가 동작할 때</li>
<li>시스템 콜을 사용할 때</li>
<li>동기화 코드(mutex, atomic, channel)가 동작할 때</li>
</ul>
<blockquote>
<p>GC는 일정 시간마다 트리깅 되도록 되어있기도 하고, 힙 영역을 할당할 때 특정 값을 넘어섰는지 확인하면서 필요한 경우 GC를 트리거 할 수 있다. <a target="_blank" rel="external nofollow noopener noreferrer" href="https://changhoi.github.io/posts/go/go-gc">링크</a></p>
</blockquote>
<h1 id="Goroutine이-관리되는-방식"><a href="#Goroutine이-관리되는-방식" class="headerlink" title="Goroutine이 관리되는 방식"></a>Goroutine이 관리되는 방식</h1><p>Go는 <code>G</code>, <code>M</code>, <code>P</code> 구조체를 가지고 M:N 스레딩 모델을 구현하고 있다. 각각은 다음 의미를 갖고 있다.</p>
<ul>
<li>G: Goroutine</li>
<li>M: Machine (OS Thread)</li>
<li>P: Processor (고루틴을 동작시키는 가상 프로세서)</li>
</ul>
<p>P가 G, M 사이에서 스케줄링 역할을 담당하고 OS Thread가 코드를 동작할 수 있도록 한다. 보통 아래와 같은 이미지로 표현된다.</p>
<p><img src="/images/2022-05-25-go-scheduler/GMP.png?style=centerme" alt="G, M, P 구조체"></p>
<h2 id="Goroutine의-상태"><a href="#Goroutine의-상태" class="headerlink" title="Goroutine의 상태"></a>Goroutine의 상태</h2><p>고루틴의 상태는 크게 세 가지로 나눠진다.</p>
<ol>
<li><strong>Waiting</strong>: 이벤트 대기 상태. 시스템 콜, 동기화 콜(atomic, mutext, channel)에 의한 정지 상태.</li>
<li><strong>Runnable</strong>: 실행할 수 있는 상태. M 위에서 돌아가길 원하는 상태이다.</li>
<li><strong>Executing</strong>: 실행 중 상태. G가 P와 M과 붙어있는 상태를 의미한다.</li>
</ol>
<p>위 그림을 확인해보면 Local RunQueue 안에 들어가 있는 고루틴이 <code>Runnable</code> 상태, M과 연결된 고루틴이 <code>Executing</code> 상태라고 볼 수 있다.</p>
<h2 id="OS-스레드는-필요할-때-만들고-재사용을-위해-남겨둔다"><a href="#OS-스레드는-필요할-때-만들고-재사용을-위해-남겨둔다" class="headerlink" title="OS 스레드는 필요할 때 만들고, 재사용을 위해 남겨둔다."></a>OS 스레드는 필요할 때 만들고, 재사용을 위해 남겨둔다.</h2><p>스케줄러의 목적에 맞게 OS Thread는 최소로 유지된다. 다만 N개의 코어에서 최대 병렬 실행을 위한 수만큼은 생성된다. 그리고 만든 스레드는 스레드 종료 시스템 콜(<code>pthread_exit</code>)을 수행하지 않기 위해 유휴 상태로 남겨둔다. 이를 <code>thread parking</code>이라고 한다. 이렇게 유지되는 스레드를 활용해 빠르게 고루틴을 스레드에 스케줄링할 수 있다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. main-goroutine 실행</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">go</span> g1() <span class="comment">//2. g1-goroutine 실행</span></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">go</span> g2() <span class="comment">//3. g1이 완료되고 나서 g2-goroutine 실행되었다고 가정</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 아래와 같이 동작하게 된다.</p>
<ol>
<li>메인 고루틴을 제외하고는 다른 고루틴이 없는 상태이므로, 현재 OS 스레드 상태는 <code>m-main</code> 한 개</li>
<li><code>g1</code> 고루틴을 생성 후 RunQueue에 담는다.<ol>
<li>런타임은 <code>g1</code>을 실행할 OS Thread인 <code>m1</code> 스레드를 만든다.</li>
<li>P는 RunQueue에 있는 <code>g1</code>을 <code>m1</code>과 붙여준다.</li>
<li><code>m1</code>은 <code>g1</code> 프로세스가 종료되더라도 사라지지 않고 Parking(idle) 상태가 된다.</li>
</ol>
</li>
<li>새로 <code>g2</code> 고루틴이 RunQueue에 올라간다. (이 시점에서 <code>g1</code>은 종료되었다고 가정한다. 만약 종료되지 않았다면 <code>m2</code>를 생성하고 붙여주는 위와 동일한 작업을 수행함.)<ol>
<li>런타임은 Parking 상태인 <code>m1</code>을 Unparking 후 <code>g2</code>를 붙여준다.</li>
</ol>
</li>
</ol>
<blockquote>
<p>이때 2-2의 P는 처음 고루틴을 만들고 RunQueue에 담아준 P일 수도 있고, M이 만들어진 다음 새롭게 붙은 P일 수도 있다. 일단 여러 P 구조체가 접근할 수 있는 Global Level의 RunQueue처럼 이해하고, 이후 P의 Work Stealing을 이해한 다음 다시 생각해보자.</p>
</blockquote>
<p>그런데 위에 잠깐 언급된 것처럼, 동시 실행되는 고루틴이 아주 많이 생기면 계속해서 OS Thread를 만드는 상황이 생길 수 있다. 이 문제를 해결하기 위해서는 RunQueue가 접근하는 스레드 수를 제한할 필요가 있다.</p>
<h2 id="스레드-수를-제한한다"><a href="#스레드-수를-제한한다" class="headerlink" title="스레드 수를 제한한다."></a>스레드 수를 제한한다.</h2><p>스레드 수를 제한하지 않으면 스레드를 계속 생성하는 문제가 발생할 수 있다. 그래서 만약 스레드 수 제한에 도달하면 더 이상 스레드를 생성하지 않고 고루틴을 런큐에서 대기하도록 한다. Go에서는 이 제한값을 설정할 수 있는데 <code>GOMAXPROCS</code>라는 환경 변숫값을 사용한다. 최근 버전에서는 이 값이 머신의 CPU 코어 수로 설정되어 있다. 임의로 수정할 수도 있고 런타임에서는 <code>runtime.GOMAXPROCS</code> 함수를 사용해 설정할 수 있다.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ GOMAXPROCS=10 go run main.go</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> runtime.GOMAXPROCS(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="예를-들어-GOMAXPROCS-값이-2인-상황에서-g1이-m1-위에서-돌고-있고-g2가-생성되어-RunQueue에-들어가-있는-상황을-생각해보자-현재-GOMAXPROCS-만큼-M이-있기-때문에-g2는-대기하게-된다-만약-g0-고루틴에서-동기화-블락이-발생하면-ex-동기-채널로-g2가-보낸-데이터를-기다린다든지…-g0은-메인-스레드에서-빠져나오게-되고-g2가-메인-스레드로-가서-실행되게-된다"><a href="#예를-들어-GOMAXPROCS-값이-2인-상황에서-g1이-m1-위에서-돌고-있고-g2가-생성되어-RunQueue에-들어가-있는-상황을-생각해보자-현재-GOMAXPROCS-만큼-M이-있기-때문에-g2는-대기하게-된다-만약-g0-고루틴에서-동기화-블락이-발생하면-ex-동기-채널로-g2가-보낸-데이터를-기다린다든지…-g0은-메인-스레드에서-빠져나오게-되고-g2가-메인-스레드로-가서-실행되게-된다" class="headerlink" title="예를 들어 GOMAXPROCS 값이 2인 상황에서 g1이 m1 위에서 돌고 있고, g2가 생성되어 RunQueue에 들어가 있는 상황을 생각해보자.현재 GOMAXPROCS 만큼 M이 있기 때문에 g2는 대기하게 된다. 만약 g0 고루틴에서 동기화 블락이 발생하면 (ex. 동기 채널로 g2가 보낸 데이터를 기다린다든지…) g0은 메인 스레드에서 빠져나오게 되고 g2가 메인 스레드로 가서 실행되게 된다."></a>예를 들어 <code>GOMAXPROCS</code> 값이 2인 상황에서 <code>g1</code>이 <code>m1</code> 위에서 돌고 있고, <code>g2</code>가 생성되어 RunQueue에 들어가 있는 상황을 생각해보자.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m0 - g0 (메인 고루틴 동작 중) | RQ : [g2]</span><br><span class="line">m1 - g1 (g1 고루틴 동작 중)</span><br></pre></td></tr></table></figure><br>현재 <code>GOMAXPROCS</code> 만큼 M이 있기 때문에 <code>g2</code>는 대기하게 된다. 만약 <code>g0</code> 고루틴에서 동기화 블락이 발생하면 (ex. 동기 채널로 <code>g2</code>가 보낸 데이터를 기다린다든지…) <code>g0</code>은 메인 스레드에서 빠져나오게 되고 <code>g2</code>가 메인 스레드로 가서 실행되게 된다.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m0 - g2 (g2 동작 중) | channel wait queue: [g0]</span><br><span class="line">m1 - g1 (g1 동작 중)</span><br></pre></td></tr></table></figure></h2><p>왜 스레드를 조절하는 이름을 꼭 프로세스 조절 이름처럼 만들었을까? 이유는 이 값의 목적은 위에서 말한 것처럼 “OS Thread 수 조절”이 맞지만 실제 동작은 “<strong>가상 프로세서 P 숫자를 제어</strong>“하기 때문이다. 말 그대로 “최대 프로세서 수”라는 뜻이다. 무슨 차이가 있는 걸까?</p>
<p>위에서 고루틴이 실행 상태이기 위해서는 P와 M이 붙은 상황이어야 한다고 했다. 스케줄러 역할을 해줄 P와 실제 코드를 실행해줄 M이 필요하다는 뜻이다. 즉, 실행 상태인 고루틴은 P의 숫자에 종속적이다. 따라서 스레드 수는 늘어나도 그 스레드 M이 P와 함께 있는 상황이 아니면 코드를 실행할 수 없다는 뜻이다. M과 P가 붙어있을 수 없는 상황은 바로 시스템 콜을 수행 중인 M인 경우이다. 고루틴에서 시스템 콜을 호출해 OS 스레드가 블락되게 되면 해당하는 M과 G는 P 구조체와 분리되고 P는 새로운 M과 연결되면서 RunQueue에 있는 다른 고루틴을 스케줄링한다. 블락된 고루틴은 시스템 콜 작업이 끝나면 RunQueue로 돌아오게 된다. 이렇게 스레드가 블락 되었을 때 P를 M과 G에서 떼어내는 작업을 <code>handsoff</code>라고 한다. 이 특징 덕분에 P가 멈추지 않고 다른 고루틴을 새로운 M에 붙여줄 수 있게 되므로 고루틴이 기아 상태에 빠지지 않도록 해준다.</p>
<p>고 런타임에서는 블락된 고루틴을 확인하기 위해 백그라운드 모니터 스레드를 별도로 사용하고 있다. 이 스레드는 고루틴들이 블락되는 것을 감지했을 때 유휴 상태 스레드가 없다면 새로운 M을 만들어 P에 붙여주고 만약 유휴 상태의 스레드가 있으면 해당 M과 P를 활성화한다</p>
<p>이러한 구조때문에 Go는 M:P:N 멀티 스레딩 모델이라고도 불린다.</p>
<p><img src="/images/2022-05-25-go-scheduler/MPN.png?style=centerme" alt="M:P:N Threading Model"></p>
<blockquote>
<p>위 내용은 <code>src/runtime/proc.go</code> 파일의 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/golang/go/blob/0a1a092c4b56a1d4033372fbd07924dad8cbb50b/src/runtime/proc.go#L2345"><code>handsoffp</code> 함수</a> 주석에서 자세히 확인할 수 있다.</p>
</blockquote>
<p>이런 특징이 코드를 짤 때 어떤 문제를 발생시킬 수 있을까? 우리는 <code>GOMAXPROCS</code>를 가지고 OS Thread 수를 컨트롤할 수 있다고 생각할 수 있지만, 실제로는 그렇지 않다는 점이다. 예를 들어서 파일 100개를 고루틴으로 동시에 열어서 작업을 수행하는 것을 가정해보자. 이 경우 블락된 OS 스레드에서 P를 분리하고 새로운 OS 스레드 M을 만드는 작업을 하므로 이론상 100개가 넘는 스레드가 만들어질 수 있다.</p>
<p>다음 예시 코드는 100개의 고루틴을 돌려서 파일을 만들고 쓰는 작업을 한다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;os&quot;</span>   </span><br><span class="line">   <span class="string">&quot;runtime/pprof&quot;</span>   </span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   threadProfile := pprof.Lookup(<span class="string">&quot;threadcreate&quot;</span>)  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;thread count before start: %d\n&quot;</span>, threadProfile.Count())  </span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup  </span><br><span class="line">   wg.Add(<span class="number">100</span>)  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;  </span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">         <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">         filename := fmt.Sprintf(<span class="string">&quot;files/%d-file&quot;</span>, n)  </span><br><span class="line">         f, err := os.Create(filename)  </span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">            <span class="built_in">panic</span>(err)  </span><br><span class="line">         &#125;  </span><br><span class="line">  </span><br><span class="line">         <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">               fmt.Println(err)  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            err := os.Remove(filename)  </span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">               fmt.Println(err)  </span><br><span class="line">            &#125;  </span><br><span class="line">         &#125;()  </span><br><span class="line">  </span><br><span class="line">         <span class="keyword">var</span> str []<span class="type">byte</span>  </span><br><span class="line">         <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;  </span><br><span class="line">            str = <span class="built_in">append</span>(str, <span class="type">byte</span>(j))  </span><br><span class="line">         &#125;  </span><br><span class="line">         _, err = f.Write(str)  </span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">            <span class="built_in">panic</span>(err)  </span><br><span class="line">         &#125;  </span><br><span class="line">  </span><br><span class="line">      &#125;(i)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   wg.Wait()  </span><br><span class="line">  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;threads count aftre program: %d\n&quot;</span>, threadProfile.Count())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">thread count before start: 5</span><br><span class="line">threads count aftre program: 77</span><br></pre></td></tr></table></figure>

<blockquote>
<p>시스템 콜 중 Non-Blocking I&#x2F;O를 사용하는 경우가 있다. 가장 대표적으로 네트워크 I&#x2F;O의 경우에는 epoll을 사용해 Non-Block으로 응답을 대기한다. 이 경우에는 M이 다른 고루틴을 수행할 수 있다. 네트워크 I&#x2F;O로 블락이 발생한 고루틴은 Net Poller라고 하는 컴포넌트에서 대기하게 된다. Net Poller는 OS의 알림을 받고 고루틴을 다시 RunQueue로(특히, Local RunQueue로) 보낸다.</p>
</blockquote>
<hr>
<h2 id="분산-RunQueue로-Lock-제거"><a href="#분산-RunQueue로-Lock-제거" class="headerlink" title="분산 RunQueue로 Lock 제거"></a>분산 RunQueue로 Lock 제거</h2><p>RunQueue가 Global RunQueue 형태였다면 여러 P에서 고루틴을 가져오기 위해 Lock을 사용해야 한다. Go는 Global RunQueue(GRQ) 역시 사용하기는 하는데 일단 기본적으로 지금까지 설명한 내용은 Local RunQueue(LRQ)를 사용한다. 각 P 구조체마다 RunQueue를 가지고 P와 연결된 스레드의 스택을 최대한 사용한다.</p>
<p>또한 P가 가지고 있는 G 안에서 새로운 고루틴을 만들게 되면 이 고루틴 역시 해당 P의 LRQ에 들어가게 된다. GRQ가 사용되는 시점은 몇 가지 있지만 대표적으로 LRQ가 가득 찬 상태에서 또 새로운 고루틴을 생성하려고 할 대 GRQ로 들어가게 된다.</p>
<p>P가 만약 G를 M에 붙이지 않은 상태라면 M은 현재 놀고 있는 스레드라는 뜻이다. 이 상태에 있는 P와 M은 “<strong>Spinning Thread</strong>“라고 한다. 이 상태에서 P는 M에 붙여줄 고루틴을 찾아야 한다. LRQ를 가장 먼저 확인하는데 만약 P가 LRQ에 고루틴을 가지고 있지 않은 상태가 되면 임의의 P의 LRQ에 있는 작업 절반을 훔친다. 이 과정을 Work Stealing이라고 한다. 이 과정을 통해 전체 작업을 고르게 분산할 수 있게 된다. 만약 Work Steal할 대상도 없는 경우에는 GRQ를 바라본다. 그래도 가져올 게 없으면 M과 P는 Parking 된다.</p>
<p>Work-Stealing은 작업을 고르게 처리하도록 도와주지만, Locality를 떨어뜨린다. 고루틴은 생성 시 사용된 스레드에서 실행되어야 캐시도 활용하고 같은 메모리 스택을 사용하게 되는데 훔쳐지면 이 이점을 살릴 수 없다. 따라서 LRQ의 구조는 단순히 FIFO 구조가 아니라 맨 앞에는 LIFO 형태로 동작하는 버퍼를 사용한다.</p>
<p><img src="/images/2022-05-25-go-scheduler/LRQ.png?style=centerme" alt="LRQ 버퍼"></p>
<p>위 이미지처럼 LIFO 버퍼가 비어있는 경우 그 버퍼에 들어가고 만약 새로운 고루틴이 바로 더 들어오면 버퍼에서 밀려 FIFO 큐로 기존 고루틴이 들어가게 되고 새롭게 Enqueue되는 고루틴이 해당 버퍼 자리를 가져간다.</p>
<p>이 우선순위가 있는 버퍼와 함께 새로운 고루틴이 3ms 가량 Work-Steeling 되지 않는다는 규칙이 있어서 어느 정도 Work-Stealing으로 인한 지역성 저하를 보완한다.</p>
<h2 id="Fairness"><a href="#Fairness" class="headerlink" title="Fairness"></a>Fairness</h2><p>스케줄링의 굉장히 중요한 요소 중 하나인 공평성이 보장되기 위해 여러 기법을 적용하고 있다. 이러한 특징을 Fairness라고 부른다.</p>
<ol>
<li>스레드를 사용하는 고루틴이 10ms 이상 실행되지 않도록 한다. 이 타임 스판을 넘어가면 선점되어 GRQ로 들어가게 된다.</li>
<li>LRQ의 구조를 보면 2개의 고루틴이 계속 반복적으로 스레드를 독차지할 수도 있는 구조라는 것을 알 수 있다. 이를 방지하기 위해 버퍼에 들어간 고루틴은 스레드를 반납하더라도 타임 스판이 초기화되지 않는다. 따라서 한 고루틴이 이 버퍼를 차지할 수 있는 시간은 10ms이다.</li>
<li>P 구조체가 고루틴을 찾는 과정이 LRQ, Work-Stealing, GRQ 순서이기 때문에 GRQ의 고루틴이 기아 상태에 빠질 수 있다. 이를 방지하기 위해서 스케줄러는 61번마다 한 번씩 LRQ보다 GRQ를 우선해서 확인한다. 61이라는 숫자는 소수 중 경험적 테스트를 통해 나온 값이라고 한다.</li>
<li>Net Poller 같은 경우엔 응답을 확인하는 별도의 스레드를 사용한다 이 스레드는 G M P 구조와 별도로 동작하므로 고 런타임에 의한 기아 상태에 빠지지 않는다.</li>
</ol>
<blockquote>
<p>Go 스케줄러는 기본적으로 비선점적 방식이기 때문에 10ms, 3ms 등의 이벤트는 Best-Effort에 해당한다. 완전히 정확한 타이밍으로 동작하는 것은 아니다. 다만 1.12 버전 이후로 무거운 Loop가 돌면서 선점되지 않는 고루틴이 발생하는 것을 막기 위해 선점적 스케줄링 방식이 일부 도입되었다.</p>
</blockquote>
<h2 id="고루틴-재활용"><a href="#고루틴-재활용" class="headerlink" title="고루틴 재활용"></a>고루틴 재활용</h2><p>고루틴이 담고 있던 코드 흐름이 모두 완료되고 나면 고루틴을 보관한다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// Available G&#x27;s (status == Gdead)</span></span><br><span class="line">   gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">    gList</span><br><span class="line">    n <span class="type">int32</span></span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 구조체는 P 구조체인데, <code>gFree</code>에 유휴 상태의 고루틴을 모아둔다. 이 리스트를 유지함으로써 유휴 상태의 고루틴을 저장하거나 뺄 때 Lock같은 동작이 필요 없게 된다.</p>
<p>더 나은 고루틴 관리와 분배를 위해 스케줄러 자체적으로 글로벌하게 관리하는 리스트 두 개가 있는데, 하나는 재활용이 가능한 스택이 할당된 고루틴을 보관하는 리스트와 스택 재활용이 불가능해 스택을 해제한 고루틴을 보관하는 리스트이다. P가 관리하는 유휴 상태의 고루틴이 64개가 넘어가면 고루틴의 절반이 중앙 리스트로 이동하게 된다. 이때 고루틴이 추가적인 메모리를 할당 받아 2KB보다 큰 메모리 사이즈를 가지고 있는 경우가 재활용 불가능한 고루틴으로 판단되어 메모리를 할당 해제 후 보관하고, 그렇지 않은 경우 스택 메모리도 재활용해 사용한다.</p>
<hr>
<p>이렇게 재활용하는 특성은 OS 스레드를 계속 만드는 것처럼 비슷한 문제를 야기할 수 있다. 즉, 고루틴을 계속 만들어내는 문제가 생길 수 있다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(wg *sync.WaitGroup, gid <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// semaphore P() (Wait())</span></span><br><span class="line"> processing() <span class="comment">// long process</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;Done&quot;</span>, gid)</span><br><span class="line"> wg.Done()</span><br><span class="line"> &lt;-sem <span class="comment">// semaphore V() (Signal())</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> wg.Add(<span class="number">100</span>)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> read(&amp;wg, i)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 일단 고루틴이 생성된 다음 실행 흐름을 판단하기 때문에, 고루틴은 무조건 계속 만들어진다. </p>
<p><img src="/images/2022-05-25-go-scheduler/many-goroutine.png?style=centerme" alt="많은 고루틴이 만들어진 모습"></p>
<p>따라서 고루틴이 만들어지는 시점과 흐름을 제어해야 하는 시점을 잘 판단해서 코드를 짜야 한다.</p>
<h1 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h1><p>지금까지의 이야기로 다음 이미지를 이해할 수 있게 되었다. 이 이미지를 이해하기 글에서 각 컴포넌트들을 다시 살펴보자</p>
<p><img src="/images/2022-05-25-go-scheduler/overall.png?style=centerme" alt="전체적인 모습"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://morsmachine.dk/netpoller">https://morsmachine.dk/netpoller</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://ssup2.github.io/theory_analysis/Golang_Goroutine_Scheduling/">https://ssup2.github.io/theory_analysis/Golang_Goroutine_Scheduling/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/watch?v=KBZlN0izeiY&ab_channel=GopherAcademy">https://www.youtube.com/watch?v=KBZlN0izeiY&amp;ab_channel=GopherAcademy</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://rakyll.org/scheduler/">https://rakyll.org/scheduler/</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Go Scheduler</p><p><a href="https://changhoi.kim/posts/go/go-scheduler/">https://changhoi.kim/posts/go/go-scheduler/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>changhoi</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-05-25</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-05-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/programming/">programming</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="title is-5">관련 글</h3><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/system-design-part-1/"><img src="/images/2023-10-05-system-design-part-1/thumbnail.png" alt="대규모 시스템 디자인 Part 1 강의"></a></figure><div class="media-content"><p class="date"><time datetime="2023-10-04T15:00:00.000Z">2023-10-05</time></p><p class="title"><a href="/posts/etc/system-design-part-1/">대규모 시스템 디자인 Part 1 강의</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/go/go-pkg-architecture-theory/"><img src="/images/2023-07-13-go-pkg-architecture/thumbnail.png" alt="Go Package Architecture - 이론편"></a></figure><div class="media-content"><p class="date"><time datetime="2023-07-12T15:00:00.000Z">2023-07-13</time></p><p class="title"><a href="/posts/go/go-pkg-architecture-theory/">Go Package Architecture - 이론편</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/rust/rust-ownership/"><img src="/images/2022-11-21-rust-ownership/thumbnail.jpeg" alt="Rust Ownership"></a></figure><div class="media-content"><p class="date"><time datetime="2022-11-20T15:00:00.000Z">2022-11-21</time></p><p class="title"><a href="/posts/rust/rust-ownership/">Rust Ownership</a></p><p class="categories"><a href="/categories/rust/">rust</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/go/go-gc/"><img src="/images/2022-03-25-go-gc/thumbnail.png" alt="Go GC"></a></figure><div class="media-content"><p class="date"><time datetime="2022-03-24T15:00:00.000Z">2022-03-25</time></p><p class="title"><a href="/posts/go/go-gc/">Go GC</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/go/about-go-range/"><img src="/images/2021-10-18-about-go-range/logo.png" alt="Go에서 range의 모든 것"></a></figure><div class="media-content"><p class="date"><time datetime="2021-10-17T15:00:00.000Z">2021-10-18</time></p><p class="title"><a href="/posts/go/about-go-range/">Go에서 range의 모든 것</a></p><p class="categories"><a href="/categories/go/">go</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/shallow-knowledge-of-funtional-programming/"><img src="/images/2019-12-19-shallow-knowledge-of-functional-programming/thumbnail.png" alt="함수형 프로그래밍에 대한 얕은 지식"></a></figure><div class="media-content"><p class="date"><time datetime="2019-12-18T15:00:00.000Z">2019-12-19</time></p><p class="title"><a href="/posts/etc/shallow-knowledge-of-funtional-programming/">함수형 프로그래밍에 대한 얕은 지식</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article></div></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/books/design-pattern-for-cloud-native-application-review/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">클라우드 네이티브 애플리케이션 디자인 패턴</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/etc/terraform-for-newbie/"><span class="level-item">초보를 위한 테라폼</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="fb-comments" data-width="100%" data-href="https://changhoi.kim/posts/go/go-scheduler/" data-num-posts="5"></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ko/sdk.js#xfbml=1&version=v12.0";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/34329147?s=400&amp;u=9d1b1dc88bc8ee5965f35b0160780264c3619eb6&amp;v=4" alt="Changhoi Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Changhoi Kim</p><p class="is-size-6 is-block">Co-Founder of Bayesians</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives/"><p class="title">73</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories/"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags/"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/changhoi/" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn" href="https://www.linkedin.com/in/changhoi/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/changhoi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Email" href="mailto:changhoi0522@gmail.com"><i class="fas fa-envelope-square"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="English" href="https://jayce.kim"><i class="fas fa-language"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/backend/"><span class="level-start"><span class="level-item">backend</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/books/"><span class="level-start"><span class="level-item">books</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/logs/"><span class="level-start"><span class="level-item">logs</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">os</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/serverless/"><span class="level-start"><span class="level-item">serverless</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Go-Runtime-Scheduler"><span class="level-left"><span class="level-item">1</span><span class="level-item">Go Runtime Scheduler</span></span></a></li><li><a class="level is-mobile" href="#Goroutine이-관리되는-방식"><span class="level-left"><span class="level-item">2</span><span class="level-item">Goroutine이 관리되는 방식</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Goroutine의-상태"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Goroutine의 상태</span></span></a></li><li><a class="level is-mobile" href="#OS-스레드는-필요할-때-만들고-재사용을-위해-남겨둔다"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">OS 스레드는 필요할 때 만들고, 재사용을 위해 남겨둔다.</span></span></a></li><li><a class="level is-mobile" href="#스레드-수를-제한한다"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">스레드 수를 제한한다.</span></span></a></li><li><a class="level is-mobile" href="#예를-들어-GOMAXPROCS-값이-2인-상황에서-g1이-m1-위에서-돌고-있고-g2가-생성되어-RunQueue에-들어가-있는-상황을-생각해보자-현재-GOMAXPROCS-만큼-M이-있기-때문에-g2는-대기하게-된다-만약-g0-고루틴에서-동기화-블락이-발생하면-ex-동기-채널로-g2가-보낸-데이터를-기다린다든지…-g0은-메인-스레드에서-빠져나오게-되고-g2가-메인-스레드로-가서-실행되게-된다"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">예를 들어 GOMAXPROCS 값이 2인 상황에서 g1이 m1 위에서 돌고 있고, g2가 생성되어 RunQueue에 들어가 있는 상황을 생각해보자.12m0 - g0 (메인 고루틴 동작 중) | RQ : [g2]m1 - g1 (g1 고루틴 동작 중)현재 GOMAXPROCS 만큼 M이 있기 때문에 g2는 대기하게 된다. 만약 g0 고루틴에서 동기화 블락이 발생하면 (ex. 동기 채널로 g2가 보낸 데이터를 기다린다든지…) g0은 메인 스레드에서 빠져나오게 되고 g2가 메인 스레드로 가서 실행되게 된다.12m0 - g2 (g2 동작 중) | channel wait queue: [g0]m1 - g1 (g1 동작 중)</span></span></a></li><li><a class="level is-mobile" href="#분산-RunQueue로-Lock-제거"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">분산 RunQueue로 Lock 제거</span></span></a></li><li><a class="level is-mobile" href="#Fairness"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">Fairness</span></span></a></li><li><a class="level is-mobile" href="#고루틴-재활용"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">고루틴 재활용</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Overall"><span class="level-left"><span class="level-item">3</span><span class="level-item">Overall</span></span></a></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">4</span><span class="level-item">Reference</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a><p class="is-size-7"><span>&copy; 2025 changhoi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="external nofollow noopener noreferrer" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>