<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CH DEVLOG</title>
    <link>https://changhoi.github.io/</link>
    
    <atom:link href="https://changhoi.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>개발 과정 기록</description>
    <pubDate>Tue, 08 Feb 2022 15:00:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>RDB 스케일링</title>
      <link>https://changhoi.github.io/posts/database/rdb-scaling/</link>
      <guid>https://changhoi.github.io/posts/database/rdb-scaling/</guid>
      <pubDate>Tue, 08 Feb 2022 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;RDB는 흔히 말하길 스케일링 (스케일 아웃) 하기 까다로운 데이터베이스라고들 한다. NoSQL이 등장하며 내세웠던 차별점 역시 이러한 부분(확장성)이 포함되어있다. 하지만 RDB가 스케일 아웃이 불가능하다는 건 절대 아니다. 많은 거대한 서비스들이 RDB를 사용하고 있고, 이 서비스들은 많은 방법으로 스케일 아웃을 구현하고 있다. 이 방법에 대해서 정리한 글이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>RDB는 흔히 말하길 스케일링 (스케일 아웃) 하기 까다로운 데이터베이스라고들 한다. NoSQL이 등장하며 내세웠던 차별점 역시 이러한 부분(확장성)이 포함되어있다. 하지만 RDB가 스케일 아웃이 불가능하다는 건 절대 아니다. 많은 거대한 서비스들이 RDB를 사용하고 있고, 이 서비스들은 많은 방법으로 스케일 아웃을 구현하고 있다. 이 방법에 대해서 정리한 글이다.</p><span id="more"></span><blockquote><p>우선 글 내용에서 구체적인 부분들은 <code>InnoDB</code> 스토리지 엔진의 케이스를 다루고 있다. 핵심적인 원리에 대해서는 사실 모든 RDB에서 같다고 생각된다.</p></blockquote><h2 id="거대한-테이블의-문제점"><a href="#거대한-테이블의-문제점" class="headerlink" title="거대한 테이블의 문제점"></a>거대한 테이블의 문제점</h2><p>스케일 아웃이 필요한 근본적인 이유는 무엇일지 생각해보자. In-memory 데이터베이스가 아니라면 일반적으로 RDB는 정보의 영구적인 저장을 위해 디스크에 파일을 작성하게 된다. 서비스가 성장하면서 메모리 사이즈보다 데이터 용량이 커지면 OS 레벨에서 캐시해주는 범위를 초과하면서 Disk I/O가 급등하게 된다. 인덱스도 마찬가지이다. 인덱스 역시 파일로 관리되게 되는데, 이 인덱스 파일의 사이즈가 커지면 같은 이유로 Disk I/O가 많아지고 속도는 Memory 접근에 비해 백만 배까지 느려진다. CRUD를 할 때 직, 간접적으로 인덱스 파일을 사용하게 되는데, 모든 동작이 이렇게 느려진다.</p><h2 id="해결할-수-있는-원리"><a href="#해결할-수-있는-원리" class="headerlink" title="해결할 수 있는 원리"></a>해결할 수 있는 원리</h2><p>근본적으로 해결하기 위해서는 테이블의 사이즈를 줄여줘야 한다. 이 방법으로는 두 가지를 여기서 언급하는데, 첫 번째는 일반적으로 RDB에서 제공하는 파티셔닝과 엔지니어가 직접 테이블을 분리하는 샤딩에 대해 다룬다. 간단히 말해서 파티셔닝은 하나의 RDB 안에서 테이블 하나를 내부적으로 여러 테이블로 나눠주는 것이고, 샤딩은 여러 RDB 서버를 사용해 데이터를 분할하는 방식이다.</p><h2 id="파티셔닝-Partitioning"><a href="#파티셔닝-Partitioning" class="headerlink" title="파티셔닝 (Partitioning)"></a>파티셔닝 (Partitioning)</h2><p>파티셔닝은 논리적으로는 하나의 테이블인데, 내부에서는 물리적으로 여러 테이블로 나눠 관리하는 방법이다. RDB마다 다를 수 있지만 일반적으로는 <code>PARTITION</code> 키워드를 통해 테이블을 분할할 수 있다. 사용하는 데이터들의 인덱스를 여러 개로 분할해서 사용할 수 있게 된다. 따라서 이전에 발생한 문제를 해결할 수도 있고, 데이터를 목정성에 맞게 나눠 관리하다가 요구에 따라 간단하게 삭제할 수도 있다.</p><blockquote><p>흔히 이 파티셔닝을 “스케일 아웃”이라고 표현하지 않는다. 일종의 기술로 대량의 데이터를 특정 기준별로 데이터베이스에 부하가 적게 생기면서 삭제할 수 있도록 하는 목적이 더 크다. 그렇지만 근본적으로 큰 테이블을 여러 테이블로 나눠주는 과정이 포함되어있어서 큰 테이블에서 발생할 수 있는 문제를 해결해줄 수 있다.</p></blockquote><h3 id="파티션-키"><a href="#파티션-키" class="headerlink" title="파티션 키"></a>파티션 키</h3><p>파티션을 만들 때, 특정 데이터가 어디에 위치하게 될지를 결정하는 키를 파티션 키라고 한다. CRUD를 할 때, 이 키를 활용해(활용할 수 있는 상황이라면) 파티션을 선택한다. 그다음 명령 동작을 수행하는 구조이다. 한 단계를 거치지만 거대한 테이블을 모두 찾아보지 않아도 된다. 이렇게 불필요한 다른 서브 테이블을 배제하는 동작을 프루닝이라고 한다.</p><hr><p>조금 구체적인 얘기인데, 파티션 키를 선택할 때 제한사항이 존재한다. 유니크 키는 논리적인 테이블 안에서 유일해야 하는 값이기 때문에 파티션 키를 통해 해당 유니크 키가 어디에 있는지 결정할 수 있어야 한다. 따라서 <strong>파티션 키는 유니크 인덱스의 일부 또는 전체를 사용해 표현해야 한다.</strong></p><p>예를 들어서 유니크 키가 다음과 같이 설정되어있다고 생각해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> (fd1, fd2) <span class="comment">-- PRIMARY도 유니크 키</span></span><br></pre></td></tr></table></figure><p>파티션 키는 <code>fd1</code>을 사용하거나, <code>fd2</code>를 쓰거나, 둘 다 사용해야 한다. 그래야만 파티션 키가 유니크 값들이 무조건 같은 테이블에 있음을 확인해줄 수 있다.</p><h3 id="파티션에서-쿼리가-발생하는-과정"><a href="#파티션에서-쿼리가-발생하는-과정" class="headerlink" title="파티션에서 쿼리가 발생하는 과정"></a>파티션에서 쿼리가 발생하는 과정</h3><p><img src="/images/2022-02-09-rdb-scaling/partition-query.png"></p><p>우선 먼저 파티션을 구분할 수 있는 조건절이 사용되었는지 확인하고 <strong>파티션 프루닝</strong>을 시도한다. 위에서 살짝 언급했지만, 파티션 프루닝은 찾을 필요가 없는 파티션을 걸러 내는 과정이다. 그다음 일반적인 테이블을 스캔하는 과정이 발생한다.</p><blockquote><p>일반적인 테이블을 스캔하는 과정은 조건절에 인덱스가 포함된 경우 인덱스를 통해 쿼리를 하고, 그렇지 않으면 테이블 풀 스캔을 하는 과정을 말한다.</p></blockquote><p>따라서 쿼리를 하는 방법에서도 어떤 키를 기준으로 파티셔닝을 해야 할지 신중하게 결정해야 한다. 쿼리 패턴에 맞게 파티셔닝을 해야 파티셔닝을 한 효과를 최대화할 수 있다.</p><h3 id="파티션에서-업데이트가-발생하는-과정"><a href="#파티션에서-업데이트가-발생하는-과정" class="headerlink" title="파티션에서 업데이트가 발생하는 과정"></a>파티션에서 업데이트가 발생하는 과정</h3><p>업데이트라고 썼지만 실제로 파티셔닝이 된 데이터베이스에서는 읽기, 삭제, 삽입이 포함될 수 있는 과정이다. 업데이트 동작을 수행하기 위해서는 먼저 테이블에서 해당 데이터를 찾아야 한다. 이 과정에서 위에서 말한 쿼리 과정이 수행된다. 그다음 데이터를 수정하게 되는데, 만약 업데이트한 필드가 파티션 키와 상관없는 필드인 경우엔 값만 수정하고 끝난다. 그런데 만약 파티션 키를 수정하게 되면 해당 데이터를 재배치하는 과정이 필요하다. 즉, 데이터를 삭제 후 알맞은 파티션에 삽입하는 과정이 발생한다. 이런 동작을 하므로 파티션 키는 쉽게 변하지 않는 값으로 설정하는 것이 퍼포먼스 측면에서 좋다.</p><h3 id="파티션-프루닝"><a href="#파티션-프루닝" class="headerlink" title="파티션 프루닝"></a>파티션 프루닝</h3><p>지금까지 이 글을 따라오다 보면 파티션 프루닝을 몇 차례 만날 수 있다. 파티션 프루닝은 파티셔닝의 핵심이다. 이 작업은 <code>EXPLAIN</code> 명령으로 확인할 수 있다.</p><p><img src="/images/2022-02-09-rdb-scaling/explain-pruning.png"><br><small>해시 파티셔닝을 한 다음 쿼리를 <code>EXPLAIN</code>으로 확인한 모습. <code>p0</code> 파티션만 사용되고 나머지는 사용되지 않음</small></p><p>테이블을 분리해서 인덱스의 크기를 줄이는 것이 파티셔닝의 외적으로 드러나는 장점이지만, 사실 프루닝을 잘 할 수 있도록 쿼리를 하지 않으면 오히려 안 좋은 퍼포먼스를 발생시킨다. 따라서 무턱대고 파티션을 많이 만들어서 인덱스 사이즈를 줄이기보단 파티션 프루닝이 최적으로 발생하도록 만들고, 인덱스 서치를 한 번만 발생하도록 하는 것이 더 중요한 파티셔닝 전략이다.</p><h3 id="방법"><a href="#방법" class="headerlink" title="방법"></a>방법</h3><p>이 글에서는 파티셔닝 방법 4가지를 설명한다. 구체적인 내용에 대해서는 <code>MySQL</code>, 특히 <code>InnoDB</code> 스토리지 엔진을 기준으로 설명하고 있다.</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p><img src="/images/2022-02-09-rdb-scaling/partition01.png"></p><p>범위를 기반으로 데이터를 나누기 쉬운 경우 사용할 수 있는 방법이다. 로그 데이터를 예로 들어볼 수 있다. 데이터가 시간에 따라 쌓이기 때문에 필요에 따라 월 단위나 연 단위로 테이블을 나눌 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_logs (</span><br><span class="line"> ...</span><br><span class="line"> reg_date DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (id, reg_date)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(reg_date)) (</span><br><span class="line"> <span class="keyword">PARTITION</span> p2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2020</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p2020 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p9999 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>위 SQL을 보면 파티션 키로 내부 함수가 사용된 것을 볼 수 있다. 모든 내장 함수가 가능한 것은 아니고, <code>InnoDB</code>인 경우에는 이 <a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-limitations-functions.html">링크</a>에 있는 내장함수들이 가능하다. 그리고 범위 마지막 부분은 <code>MAXVALUE</code> 키워드가 사용된 것을 확인할 수 있다. 위 SQL대로면 <code>p9999</code> 파티션에 2021년도 이후 로그가 쌓이고 있다고 보면 된다. 이 때 2021년도 이후 파티션을 구성하려고 하면 단순히 <code>ADD PARTITION</code> 키워드로는 동작하지 않는다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_logs <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>)</span><br><span class="line">); <span class="comment">-- ERROR</span></span><br></pre></td></tr></table></figure><p>맨 처음 <code>CREATE TABLE</code>을 한 <code>SQL</code>에서 알 수 있듯, 파티션으로 나눠질 때 위에서부터 차례대로 파티션 위치를 판단해 나누는 것을 알 수 있는데, <code>ADD PARTITION</code>을 하게 되면 이미 만들어진 파티션들 뒤에 파티션을 추가하기 때문에 마지막에 <code>MAXVALUE</code>를 사용하지 않는 상황이 된다. 따라서 파티션에 범위를 추가하기 위해서는 <code>REORGANIZE</code>를 사용해야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_logs REORGANIZE <span class="keyword">PARTITION</span> p9999 <span class="keyword">INTO</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p9999 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>다만 <code>REORGANIZE</code> 작업은 기본적으로 그 전 파티션을 복사하는 작업이다. 따라서 데이터가 많은 경우 오래 걸릴 수도 있다. 이런 문제를 해결하기 위한 일반적인 패턴 중 하나로 <code>MAXVALUE</code> 키워드를 쓰지 않고, 미래에 사용될 범위의 파티션을 미리 만들어두는 방법이 있다. 이렇게 하면 <code>ADD PARTITION</code>을 통해 간단하게 범위를 늘릴 수 있다. 당연히 문제가 발생할 여지가 있다. 이 작업이 모종의 이유로 생략되거나 문제가 생겨 생성되지 못한 상태로 해당 테이블을 사용하게 되면 파티션에 들어가야 할 데이터의 <code>INSERT</code> 작업이 동작하지 않는다.</p><hr><p>이렇게 만들어진 파티션은 간단하게 드랍할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_logs <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> p2017;</span><br></pre></td></tr></table></figure><p>위 코드로 2017년 로그를 삭제할 수 있다. 조건절을 통해 삭제하는 것보다 데이터베이스에 생기는 부하도 적고 빠르게 데이터를 삭제할 수 있다.</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>리스트 방식은 파티션 키가 어떤 케이스에 속하는지 직접 지정해주는 방법이다. <code>IN (...)</code> 안에 파티션으로 선택되는 리스트를 만들어주어야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> posts (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">        ...</span><br><span class="line">    category_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> LIST(category_id) (</span><br><span class="line">    <span class="keyword">PARTITION</span> fleamarket <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> town <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> etc <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">3</span>, <span class="keyword">NULL</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>당연히 리스트 안의 값은 겹치면 안 되고, 만약 겹치게 되면 에러를 발생시킨다. 파티션 키의 값이 지정된 코드나 값일 때 사용할 수 있다. 위 예시에서는 포스트의 카테고리에 따라 테이블을 나눠 구성한 모습이다. 또한 키 값이 오름차순이나 내림차순의 의미가 없는 경우라면 <code>Range</code>를 사용할 수 없으므로 <code>List</code> 방법이 적합한지 생각해볼 수 있다.</p><p>위에서 파티션을 추가하는 방법처럼 <code>ADD</code> 키워드를 통해 파티션을 추가할 수 있고, <code>DROP PARTITION</code>을 통해 파티션을 지울 수 있다. 또 하나의 파티션을 분리 및 병합할 때는 <code>REORGANIZE PARTITION</code>을 사용할 수 있다.</p><blockquote><p><code>List</code>, <code>Range</code> 파티션의 경우 <a href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-subpartitions.html"><code>Subpartition (Composite Partition)</code></a>을 구성할 수 있다.</p></blockquote><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>해시 함수에 의해 파티션을 결정할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> accounts (</span><br><span class="line">    ...</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH(id) PARTITIONS <span class="number">4</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>PARTITIONS 4</code>는 4개의 파티션에 의해 분할되는 것을 의미한다. 해시 작업이라고 하는 것은 쉽게 말해서 모듈러 연산하는 작업이다. 따라서 파티션 키로 사용되는 값은 정수값을 반환해줘야 한다. 파티션 이름을 지정하려면 위에서처럼 직접 이름을 정해줄 수도 있는데, 만약 정의하지 않으면 <code>p0</code>, <code>p1</code>, … 이런 식으로 지정된다.</p><p>데이터를 균일하게 파티션에 분배되어야 잘 파티셔닝 된 것이라 볼 수 있는데, 해시의 경우 아주 균일하게 파티션을 분배한 것이라 볼 수 있다. 자원을 효율적으로 사용할 수 있지만, 데이터 목적이나 유형을 고려해서 파티션을 나눈 것은 아니다. 따라서 모든 데이터에 대해 용도가 비슷하고 사용 빈도도 비슷한 큰 데이터를 파티셔닝 해야할 때 사용하기 좋다. 예를 들어서 계정 정보는 오래 전에 가입했든 최근에 가입했든 지속해서 사용하는 사람들의 정보가 계속해서 사용된다.</p><p>하지만 이 방법으로 파티션을 분할하면 파티션을 구성을 변경하는 과정의 비용이 많이 들거나 불가능하다. 예를 들어서 하나의 파티션을 더 넣는다는 것은 해시 함수를 바꿔주는 것과 같은 의미이다. 따라서 바뀐 해시 함수로 기존 데이터를 모두 재배열 해줘야 한다. 또한 해시로 나눠진 파티션을 삭제할 일도 사실상 없다. 해시 파티션을 했을 때, 각 파티션에 어떤 데이터가 있는지에 대한 의미가 없기 떄문이다. 따라서 특정 파티션을 삭제할 이유가 없고, 실제로 삭제한려고 한다 하더라도 <code>DROP PARTITION</code>은 에러를 발생시킨다. 그리고 병합하거나 분할하는 작업도 불가능하다. 이 과정은 그냥 파티션을 늘려주거나 줄여주는 작업을 해야 한다. 예상할 수 있겠지만 파티션을 늘이고 줄이는 작업은 아주 비싼 작업이다.</p><blockquote><p><code>COALESCE PARTITION 1</code>과 같은 방법으로 파티션을 줄여줄 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example COALESCE PARTITIONS <span class="number">1</span>;</span><br></pre></td></tr></table></figure></blockquote><p>파티셔닝 이후의 유연성이 부족한 방법이기 때문에, 설계할 때 몇 개의 파티션이 적합할지 생각해보는 것이 중요하다. 하지만 해시로 사용하는 컬럼값이 조건절에 사용되면 아주 효율적으로 파티션 프루닝이 가능하다.</p><blockquote><p>유연성이 부족한 해시 파티션 문제를 해결하기 위해서 <a href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html"><code>Linear Hash</code></a>를 사용할 수 있다. 그러나 사용되는 특정한 알고리즘으로 인해 데이터의 분배가 덜 균등해질 수 있다.</p></blockquote><h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>키 파티션 방법은 해시와 거의 비슷한데 해시 함수의 모듈러를 위해 정수형 타입을 사용해야 했던 해시와는 다르게, 대부분의 타입을 파티션 키로 사용할 수 있다. 파티션 키를 <code>MD5</code>를 통해 해시값을 계산하고 그 값을 모듈러 연산해서 파티셔닝을 해주는 구조이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k1 (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> KEY() <span class="comment">-- 괄호가 비어있으면, 프라이머리 키 모든 칼럼을 사용함</span></span><br><span class="line">PARTITIONS <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 프라이머리 키가 따로 없으면 유니크 키를 사용</span></span><br></pre></td></tr></table></figure><p>해시 파티션에 비해서 더 균등하게 나눠질 수 있다. 따라서 보다 효율적이고, 파티션 키로 사용되는 필드가 정수형이 아니어도 되기 때문에 <code>Hash</code> 방법이 사용될 수 없는 상황에서 고려해볼 수 있다.</p><h3 id="파티셔닝-정리"><a href="#파티셔닝-정리" class="headerlink" title="파티셔닝 정리"></a>파티셔닝 정리</h3><p>파티션 키와 파티셔닝 방법을 선택하는 기준은 데이터 접근 패턴, 어떤 유형의 데이터인지, 등 고려해볼 만한 상황이 많이 있다. 그리고 단순히 인덱스를 작게 만드는 것보다 효율적인 DML을 쓰기 위해 어떻게 설계하는 것이 좋을지도 고민해봐야 한다.</p><h2 id="샤딩-Sharding"><a href="#샤딩-Sharding" class="headerlink" title="샤딩 (Sharding)"></a>샤딩 (Sharding)</h2><p>단일 서버에서 효율적으로 테이블을 나눈다고 하더라도 물리적인 한계는 반드시 존재한다. 예를 들어서 데이터베이스의 디스크 크기를 늘리기 어렵다든지, 늘릴 수 있더라도 근본적인 문제 해결 방법이 아니라든지(Network 부하, 꾸준하고 급격하게 증가하는 데이터들, 서버 자체의 부하), 이러한 이유로 결국 서버를 물리적으로 여러 대를 사용해서 해결해야 한다. 이렇게 수평적인 방식으로 파티셔닝을 하는 것을 샤딩이라고 한다.</p><blockquote><p>위에서 언급한 것처럼 파티셔닝은 스케일 아웃이라고 보기 어렵다. 스케일 아웃은 결국 “수평적 확장”을 의미한다. 수평적 파티셔닝 방법이 일반적인 데이터베이스의 스케일링 방법이다. 그런데 “수평적 방식의 파티셔닝”이라는 말처럼 방법 측면에서 파티셔닝의 방법과 유사하다.</p></blockquote><hr><p>샤딩이라고 하는 것은 RDB의 기본적인 기능은 아니다. 즉, 개발자의 엔지니어링이 요구되는 부분이다. 어떤 데이터가 어떤 노드에 들어가 있는지 판단하는 것을 개발자가 엔지니어링을 통해 라우팅 처리 해줘야 한다. 이렇게 데이터를 저장하거나 가져올 때 적절한 노드를 찾아주는 흐름을 <strong>샤딩 로직</strong> 이라고 하는데, 이 로직은 애플리케이션 사이드에 존재할 수도 있고 스토리지 시스템의 미들웨어로 존재할 수도 있다. 애플리케이션 사이드에 이 로직이 있는 것을 <strong>Application-level 샤딩</strong>이라는 이름으로 보통 불린다. 이는 애플리케이션의 로직에서 라우팅 처리를 해준다는 것을 의미한다. ORM에서 이를 설정한다든지, 직접 데이터값에 따라 어떤 데이터베이스와 연결할지 선택하는 흐름 등을 예로 들 수 있다. 반대로 스토리지 시스템 미들웨어는 <strong>솔루션</strong>, <strong>샤딩 플랫폼</strong>, <strong>프록시</strong> 등 여러 이름으로 불리고 있다. 이 방법을 사용하면 어떤 미들웨어인지에 따라 다를 수 있지만, 일반적으로 애플리케이션에서는 데이터베이스의 라우팅 처리에 신경쓰지 않고 마치 하나의 데이터베이스와 상호작용하는 것처럼 동작하게 된다.</p><hr><p>샤딩을 하게되면 그 전처럼 RDB를 사용하지 못 할 수 있다. 여러 RDB의 특징들에 제약이 생긴다는 것을 의미한다. 대표적으로 다음과 같은 문제들이 있다.</p><ul><li>물리적으로 다른 노드의 데이터베이스와 <code>JOIN</code> 연산을 수행할 수 없는 문제</li><li>Auto Increment가 샤드별로 달라지는 문제</li><li>하나의 트랜잭션이 두 개 이상의 샤드에 접근할 수 없는 문제</li></ul><p>이런 문제가 발생할 수 있으므로 샤딩을 설계하는 과정에서 이 문제들을 고려해서 샤딩을 진행해야 한다.</p><h3 id="샤드-키"><a href="#샤드-키" class="headerlink" title="샤드 키"></a>샤드 키</h3><p>파티셔닝에서도 각 파티션이 어떤 데이터를 가져갈지 결정할 파티션 키가 있었던 것처럼, 분할된 노드(분리된 데이터베이스 서버)는 각각이 가져갈 데이터를 결정해야 한다. 이 기준을 샤드 키라고 부른다. 위에서 파티션 키가 변하지 않는 값으로 설정하는 것이 좋다고 했던 것과 같은 이유로 샤드 키는 변경되지 않는 값을 기준으로 설정해야 한다.</p><h3 id="방법-1"><a href="#방법-1" class="headerlink" title="방법"></a>방법</h3><p>샤드 키를 어떻게 설계했는지에 따라 어떻게 라우팅할지도 달라진다. 여러 방법이 있지만 여러 곳에서 소개되고 있는 두 가지 방법을 가져왔다.</p><h4 id="Range-Based-Sharding"><a href="#Range-Based-Sharding" class="headerlink" title="Range Based Sharding"></a>Range Based Sharding</h4><p><img src="/images/2022-02-09-rdb-scaling/range-sharding.png"><br><small>출처: <a href="https://techblog.woowahan.com/2687/">우아한 형제들 기술 블로그</a></small></p><p>특정 키의 범위에 따라 샤드에 배분해주는 방법이다. 이름에서 알 수 있듯, 위 파티셔닝 방법 중 <code>Range</code> 방식과 유사하다. 특징은 샤드를 추가하는 과정이 비교적 간단하고 라우팅도 간단하다. 다만 데이터 접근 패턴이나 범위별 데이터양을 고려한 방법은 아니기 때문에 컴퓨팅 자원을 불균형하게 소비하는 케이스가 발생할 수도 있다.</p><h4 id="Modulus-Key-Hash-Based-Sharding"><a href="#Modulus-Key-Hash-Based-Sharding" class="headerlink" title="Modulus (Key, Hash Based) Sharding"></a>Modulus (Key, Hash Based) Sharding</h4><p><img src="/images/2022-02-09-rdb-scaling/modular-sharding.png"><br><small>출처: <a href="https://techblog.woowahan.com/2687/">우아한 형제들 기술 블로그</a></small></p><p>특정 키를 모듈러 연산으로 특정하는 방식이다. 이 방법의 다른 이름에서 알 수 있듯, 위에서 파티셔닝 방법 중 <code>Hash</code> 방식과 유사하다는 점을 알 수 있다. 특징도 <code>Hash</code> 방식의 특징과 유사하다. 데이터가 샤드에 균일하게 분산된다는 장점이 있지만, 샤드를 추가할 때 데이터를 재배열해야 하는 비용이 있다는 단점이 있다.</p><hr><h3 id="케이스-스터디"><a href="#케이스-스터디" class="headerlink" title="케이스 스터디"></a>케이스 스터디</h3><p>샤딩같은 경우는 아무래도 RDB의 자체적인 기능이 아니라서 케이스를 찾아보면 굉장히 다양한 방법으로 샤딩을 진행한 것을 볼 수 있다. 예시로 세 가지 케이스를 확인해보자.</p><h4 id="Notion-샤딩"><a href="#Notion-샤딩" class="headerlink" title="Notion 샤딩"></a>Notion 샤딩</h4><p>노션은 애플리케이션 레벨의 샤딩을 결정했다. <code>Vitess</code>, <code>Citus</code>와 같은 미들웨어 서비스를 알아보긴 했는데, 그 솔루션들의 동작이 불투명하다고 판단했고, 본인들 데이터를 직접 컨트롤하길 원했기 때문에 이러한 선택을 했다고 한다. 그 결정 이후에는 어떻게 데이터를 나눌지 결정하는 과정이 있었다.</p><ol><li>어떤 데이터를 샤드해야 할까? → 노션의 블록과 FK로 연관된 모든 데이터를 같이 묶어 하나의 샤드에 포함될 수 있도록 함으로써 데이터 부정확성 문제를 방지</li><li>어떻게 데이터를 나눠야 할까? → 워크스페이스의 ID를 기준으로 샤딩 함으로써 한 워크스페이스의 데이터들이 같은 데이터베이스 안에 들어갈 수 있도록 분할</li></ol><p>더 자세한 내용은 <a href="https://www.notion.so/blog/sharding-postgres-at-notion">이 링크</a>에서 확인할 수 있다.</p><h4 id="LINE"><a href="#LINE" class="headerlink" title="LINE"></a>LINE</h4><p>LINE Manga 서비스의 <a href="https://engineering.linecorp.com/ko/blog/line-manga-server-side/">서버 엔지니어링 스토리</a>를 보면 애플리케이션 샤딩을 한 것으로 추측된다. 몇 단계를 거쳐 샤딩을 진행했는데, 4단계에서 코드를 수정해서 샤딩을 적용한다는 얘기가 나온다. 라인 망가의 경우에는 RDB 부하 문제를 초기엔 스케일 업으로 대응했으나, 근본적인 해결책이 아니라고 판단하여 샤딩을 진행했다고 한다. 검토 과정은 생략되었는데, 새로운 컬럼을 구성하고 <code>Range Based Sharding</code>을 진행했다고 한다.</p><h4 id="NHN"><a href="#NHN" class="headerlink" title="NHN"></a>NHN</h4><p>NHN의 경우 게임 서버 얘기였는데, 여러 서버로 샤딩을 한 상태에서 애플리케이션 레벨의 샤딩을 했을 때 컨넥션과 관련한 문제가 생길 수 있었다고 한다. 애플리케이션 서버가 200대, DB에 컨넥션이 서버당 300개씩 각자 거는 상황이면, 하나의 DB마다 최대 6만 개의 컨넥션이 생기게 된다. 이 문제를 해결하기 위해 미들웨어를 두고 프록시를 사용하고 있다고 한다. 여기서 사용된 미들웨어는 <code>ProxySQL</code>이고, 이 솔루션을 사용하게 되면 애플리케이션 레벨에서는 하나의 데이터베이스와 통신하는 것과 같이 구성할 수 있었다고 한다. 동시 접속의 개념이 있는 게임 서버에서 컨넥션을 Demultiplexing 하는 과정에 대해 더 자세히 알아보고 싶다면 <a href="https://www.youtube.com/watch?v=8Eb_n7JA1yA&ab_channel=NHNCloud">이 영상</a>을 보자.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 애플리케이션의 사용자가 증가하면서 부하를 견디는 설계를 할 때 애플리케이션이 데이터베이스와 접근할 때뿐만 아니라 고려해야 할 사항이 많이 있다. 데이터베이스의 부하를 분산하는 방법으로 미들웨어를 사용한 샤딩을 결정했다면, 이 미들웨어가 애플리케이션으로부터 오는 부하를 강하게 견디는지도 확인해봐야 한다. 이런 전반적인 이야기는 <code>Database HA</code> (<code>High Availability</code>)라는 키워드로 몇 가지 더 알아봐야 한다. 그리고 Replication과 관련된 얘기도 이 글에서는 빠져있는데, 데이터베이스를 복제해 읽기 전용 슬레이브 레플리카를 만들거나, 데이터 분석용, 백업용, 등 여러 이유로 사용할 수도 있다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/database/">database</category>
      
      
      <category domain="https://changhoi.github.io/tags/cs/">cs</category>
      
      <category domain="https://changhoi.github.io/tags/rdb/">rdb</category>
      
      
      <comments>https://changhoi.github.io/posts/database/rdb-scaling/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>모던 자바스크립트 핵심 가이드 간단 리뷰</title>
      <link>https://changhoi.github.io/posts/books/complete-guide-to-modern-javascript-book-review/</link>
      <guid>https://changhoi.github.io/posts/books/complete-guide-to-modern-javascript-book-review/</guid>
      <pubDate>Sat, 18 Dec 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번년도에도 한빛 미디어의 나는 리뷰어다에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 12월달 미션으로 나온 책 중에 하나인 모던 자바스크립트 핵심 가이드를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번년도에도 한빛 미디어의 나는 리뷰어다에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 12월달 미션으로 나온 책 중에 하나인 모던 자바스크립트 핵심 가이드를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.</p><p>이 책은 자바스크립트의 핵심 기술에 대한 명확한 설명과, 그에 대한 쉬운 예시로 문법의 이해를 돕고, 기술의 이해도를 확인 할 수 있는 문제들로 구성되어있다. 필자는 이 문제 풀이 부분이 특히 가장 마음에 들었다. 문제를 풀어봄으로써 스스로 어디까지 이해 했는가 확인 하고, 부족한 부분들을 알게 해주기 때문이다.<br>필자는 이 책이 자바스크립트를 처음 접하는 사람들은 물론이고 어느정도 지식을 가지고 있는 사람들에게도 추천 하고싶다. 그 이유는 앞서 말한 구성이 잘 짜여있고, 책의 부족한 설명은 중간에 스스로 학습할 수 있게 링크를 알려주는 방식으로 보완하여 입문자가 아니더라도 충분히 읽을만 하다고 생각했기 때문이다. 또한 문법의 다양한 쓰임을 알려주기 때문에 이미 알고 있다 하더라도 다시 한 번 기본 지식을 단단히 다지는데 좋을 것 같다고 생각했다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/books/">books</category>
      
      
      <category domain="https://changhoi.github.io/tags/review/">review</category>
      
      
      <comments>https://changhoi.github.io/posts/books/complete-guide-to-modern-javascript-book-review/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Go에서 range의 모든 것</title>
      <link>https://changhoi.github.io/posts/go/about-go-range/</link>
      <guid>https://changhoi.github.io/posts/go/about-go-range/</guid>
      <pubDate>Sun, 17 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;Go 언어의 내장 함수들은 많지 않지만, 각각이 일당백 역할을 한다. &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;는 Go 프로그램을 작성할 때 넓은 범위에서 사용되는 내장 함수이다. 이번 포스팅에서는 &lt;code&gt;range&lt;/code&gt; 활용에 대해서 정리해두었다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Go 언어의 내장 함수들은 많지 않지만, 각각이 일당백 역할을 한다. <code>make</code>, <code>new</code>, <code>range</code>는 Go 프로그램을 작성할 때 넓은 범위에서 사용되는 내장 함수이다. 이번 포스팅에서는 <code>range</code> 활용에 대해서 정리해두었다.</p><span id="more"></span><p><code>range</code>는 <code>for</code>와 함께 사용된다. <code>range</code>의 뒷 부분으로 배열, 슬라이스, 맵, 또는 채널(특히, 값을 받는 역할을 하는)이 들어올 수 있다. 이터레이션 값들 (<code>iteration values</code>라고 표현함)이 있는 경우 그 값을 할당해주고 반복문의 블록으로 진입하게 된다.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> intSlice &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 가장 많이 사용되는 슬라이스 순환</span></span><br></pre></td></tr></table></figure><p><code>range</code> 문의 오른쪽 영역을 <code>range expression</code>이라고 하는데, 이 영역에는 다음 표현들이 들어올 수 있다.</p><ul><li>배열, 배열 포인터</li><li>슬라이스</li><li>문자열</li><li>맵</li><li>채널 (받기 동작을 할 수 있어야 한다.)</li></ul><p><code>range</code> 왼쪽의 <code>=</code> 또는 <code>:=</code> 기준으로 그 다음 왼쪽 영역은 이터레이션 변수(<code>iteration variables</code>)라고 하는데, <code>range expression</code>이 채널인 경우는 최대 1개의 이터레이션 변수가 가능하고, 나머지는 최대 2개까지 가능하다.</p><blockquote><p>0개 부터 2개까지 사용이 가능하다, 1개만 사용하면, 첫 번째 이터레이션 값이 할당된다.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> [<span class="string">`iteration variables`</span>] := <span class="keyword">range</span> <span class="string">`range expression`</span></span><br><span class="line"><span class="comment">// `range`는 `range expression`에 맞게 `iteration values`를 반복 생성</span></span><br><span class="line"><span class="comment">// `iteration variables`에 할당한다.</span></span><br></pre></td></tr></table></figure><p><code>range expression</code>를 <code>x</code>라고 했을 때, <code>x</code>는 루프가 시작할 때 딱 한 번 평가된다. 하나의 예외가 있는데, 최대 하나의 이터레이션 변수가 있는 상황에서 <code>len(x)</code> 값이 상수인 경우 <code>range expression</code>은 평가 되지 않는다.</p><blockquote><p><code>len(x)</code>가 상수인 경우라는 뜻은, <code>x</code>가 상수 문자열이거나, 배열이거나 배열 포인터 이면서, 그 배열에 받는 쪽 채널이나 함수 호출등이 없는 경우에 해당한다. 자세한 내용은 이 <a href="https://golang.org/ref/spec#Length_and_capacity">링크</a>에 나온다.</p></blockquote><blockquote><p><code>range expression</code>을 평가한다는 것은, 어떤 표현식인지를 판단하는 과정이다. 공부하면서 든 생각인데, 슬라이스 중간에 값을 추가하는 동작을 하더라도 이터레이션 횟수가 변하지 않는데, 이유가 표현식을 첫 루프 시작할 때만 평가하기 때문이 아닐까 싶다.</p></blockquote><hr><p>왼쪽에 이터레이션 변수가 있다면, 각 값에 대해 이터레이션 값이 생성된다.</p><table><thead><tr><th align="center">Range Expression</th><th align="center">1st value</th><th align="center">2nd value</th></tr></thead><tbody><tr><td align="center">배열, 슬라이스, 배열 포인터</td><td align="center">인덱스</td><td align="center">값</td></tr><tr><td align="center">문자열</td><td align="center">인덱스</td><td align="center">룬</td></tr><tr><td align="center">맵</td><td align="center">키</td><td align="center">값</td></tr><tr><td align="center">채널</td><td align="center">요소</td><td align="center">-</td></tr></tbody></table><ol><li>배열, 슬라이스, 배열 포인터인 <code>a</code>가 <code>range expression</code>으로 사용된 경우: 첫 번째 값으로는 인덱스(<code>i</code>) 값이 0부터 오름차순으로 생성된다. 만약 이터레이션 변수가 하나만 제공된 경우, 0부터 <code>len(a) - 1</code> 까지의 값을 생성하게 된다. 두 번째 값으로는 <code>a[i]</code> 값을 생성한다. <code>nil</code> 슬라이스는 이터레이션 횟수가 0이다.</li><li>문자열의 경우, 바이트 인덱스 0부터 시작해서 유니코드 절을 반복한다. 연속 반복할 때 인덱스 값은 문자열에서 UTF-8 인코딩 된 코드 포인트의 첫 번째 바이트 인덱스가 되고, 두 번째 값은 해당 코드 포인트의 값이 된다. 반복 과정 중 잘못된 UTF-8 시퀀스를 만나면, 두 번째 값이 <code>0xFFFD</code>가 되고, 다음 반복에서는 바이트 단위로 진행되게 된다.</li><li><code>map[K]V</code> 타입의 맵 <code>m</code>의 경우, 첫 번째 값은 <code>K</code> 타입인 키 <code>k</code>이다. 두 번째 값은 <code>V</code> 타입인 값 <code>m[k]</code>이다. 반복 순서는 보장되지 않는다. 반복 도중에 도달하지 않은 엔트리가 제거된다면, 이터레이션 값이 생성되지 않는다. 만약 맵의 값이 반복 중 생성되는 경우엔 이터레이션 값을 만들 수도 있고 생략될 수도 있다. 만들어져 있던 엔트리들과 반복마다 다를 수 있다. 만약 맵이 <code>nil</code>인 경우 이터레이션 횟수는 0이다.</li><li>채널의 경우, 이터레이션 값은 채널이 닫히기 까지 받은 연속된 값이다. 만약 채널이 <code>nil</code>이라면, <code>range expression</code>이 영원히 블락되어버린다.</li></ol><hr><p>아래는 문자열의 경우 예시이다.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> <span class="string">&quot;→👍👎🌮🗂HelloWorld!안녕세상아!😊🚀🔥📝.&quot;</span> &#123;</span><br><span class="line">  fmt.Print(i, <span class="string">&quot; &quot;</span>)</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(r))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> <span class="string">&quot;string, just string&quot;</span> &#123;</span><br><span class="line">  fmt.Print(i, <span class="string">&quot; &quot;</span>)</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래 문자열을 보면, 룬을 잘라 넣고 이동한 바이트 만큼 인덱스가 이동하는 것을 확인할 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0 →</span><br><span class="line">3 👍</span><br><span class="line">7 👎</span><br><span class="line">11 🌮</span><br><span class="line">15 🗂</span><br><span class="line">19 H</span><br><span class="line">20 e</span><br><span class="line">21 l</span><br><span class="line">22 l</span><br><span class="line">23 o</span><br><span class="line">24 W</span><br><span class="line">25 o</span><br><span class="line">26 r</span><br><span class="line">27 l</span><br><span class="line">28 d</span><br><span class="line">29 !</span><br><span class="line">30 안</span><br><span class="line">33 녕</span><br><span class="line">36 세</span><br><span class="line">39 상</span><br><span class="line">42 아</span><br><span class="line">45 !</span><br><span class="line">46 😊</span><br><span class="line">50 🚀</span><br><span class="line">54 🔥</span><br><span class="line">58 📝</span><br><span class="line">62 .</span><br><span class="line">0 s</span><br><span class="line">1 t</span><br><span class="line">2 r</span><br><span class="line">3 i</span><br><span class="line">4 n</span><br><span class="line">5 g</span><br><span class="line">6 ,</span><br><span class="line">7  </span><br><span class="line">8 j</span><br><span class="line">9 u</span><br><span class="line">10 s</span><br><span class="line">11 t</span><br><span class="line">12  </span><br><span class="line">13 s</span><br><span class="line">14 t</span><br><span class="line">15 r</span><br><span class="line">16 i</span><br><span class="line">17 n</span><br><span class="line">18 g</span><br></pre></td></tr></table></figure><p>다음은 맵에서 값을 추가하는 경우이다.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">  m[k+<span class="string">&quot;next&quot;</span>] = v + <span class="number">1</span></span><br><span class="line">  fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래 결과를 보면, 임의로 추가된 엔트리가 출력되기도 하고, 안되기도 한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go run main. go</span><br><span class="line">map[key:10 keynext:11]</span><br><span class="line"></span><br><span class="line">$ go run main.go</span><br><span class="line">map[key:10 keynext:11]</span><br><span class="line">map[key:10 keynext:11 keynextnext:12]</span><br><span class="line"></span><br><span class="line">$ go run main.go</span><br><span class="line">map[key:10 keynext:11]</span><br><span class="line">map[key:10 keynext:11 keynextnext:12]</span><br><span class="line">map[key:10 keynext:11 keynextnext:12 keynextnextnext:13]</span><br><span class="line">map[key:10 keynext:11 keynextnext:12 keynextnextnext:13 keynextnextnextnext:14]</span><br><span class="line">map[key:10 keynext:11 keynextnext:12 keynextnextnext:13 keynextnextnextnext:14 keynextnextnextnextnext:15]</span><br><span class="line">map[key:10 keynext:11 keynextnext:12 keynextnextnext:13 keynextnextnextnext:14 keynextnextnextnextnext:15 keynextnextnextnextnextnext:16]</span><br><span class="line">map[key:10 keynext:11 keynextnext:12 keynextnextnext:13 keynextnextnextnext:14 keynextnextnextnextnext:15 keynextnextnextnextnextnext:16 keynextnextnextnextnextnextnext:17]</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://golang.org/ref/spec#For_statements">https://golang.org/ref/spec#For_statements</a></li><li><a href="https://golang.org/ref/spec#Length_and_capacity">https://golang.org/ref/spec#Length_and_capacity</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/go/">go</category>
      
      
      <category domain="https://changhoi.github.io/tags/programming/">programming</category>
      
      
      <comments>https://changhoi.github.io/posts/go/about-go-range/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NAT에 대하여</title>
      <link>https://changhoi.github.io/posts/network/about-nat/</link>
      <guid>https://changhoi.github.io/posts/network/about-nat/</guid>
      <pubDate>Wed, 06 Oct 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;NAT은 클라우드 환경에서 인프라를 구성하다 보면 쉽게 보이는 단어들이다. 사설망을 유지하면서 외부 인터넷과 단방향으로 연결하려면 어떻게 할지?와 같은 상황에서 NAT 인스턴스를 통해 외부와 연결하는 방법이 있다. NAT이 어떻게 동작하는 건지 간단하게 정리했다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>NAT은 클라우드 환경에서 인프라를 구성하다 보면 쉽게 보이는 단어들이다. 사설망을 유지하면서 외부 인터넷과 단방향으로 연결하려면 어떻게 할지?와 같은 상황에서 NAT 인스턴스를 통해 외부와 연결하는 방법이 있다. NAT이 어떻게 동작하는 건지 간단하게 정리했다.</p><span id="more"></span><h2 id="동작-방식"><a href="#동작-방식" class="headerlink" title="동작 방식"></a>동작 방식</h2><p>일단 네트워크를 활용해야 하는 장비는 모두 IP가 필요하다. 그런데, 모든 장비에게 각각의 IP를 부여하면, 하나의 작은 오피스에도 넓은 범위의 IP 주소 범위를 할당해야 한다. 이런 문제를 해결하는 방법이 네트워크 주소 변환(NAT, Network Address Translation)이다.</p><p>NAT 역할을 하는 라우터는 실제로 외부에서 보기엔 라우터처럼 보이지 않고, 하나의 IP 주소를 갖는 장비로서 동작한다.</p><p><img src="/images/2021-10-07-about-nat/nat.jpg"></p><p>위 이미지를 보면, NAT 안쪽으로는 192.168.1.0/24 에 해당하는 서브넷을 사용하고 있다. 이 주소는 <strong>사설망</strong>이라고 하고, 전세계적으로 사용되는 사설망 IP 대역이 있다.</p><ul><li>10.0.0.0/8 (10.0.0.0 ~ 10.255.255.255)</li><li>172.16.0.0/12 (172.16.0.0 ~ 172.31.255.255)</li><li>192.168.0.0/16 (192.168.0.0 ~ 192.168.255.255)</li></ul><p>위 주소는 수많은 네트워크들이 동일하게 부여받기 때문에, NAT을 넘어서 외부에서는 사용할 수가 없다.</p><blockquote><p>NAT 안쪽을 LAN 밖을 WAN 방향이라고 표현할 수 있다.</p></blockquote><p>192.168.1.2 PC에서 173.194.67.102 호스트로 요청을 보내기 위해서는 192.168.1.1을 할당받은 NAT 인터페이스로 들어가서 NAT이 ISP의 DHCP를 통해 부여받은 IP를 사용해 요청을 보내게 된다.</p><blockquote><p>각 PC가 사설망의 IP 주소를 얻는 과정도 NAT의 [[DHCP]] 서버를 통해 얻게 된다.</p></blockquote><p>구체적인 예시를 생각해보자. 192.168.1.2 PC는 173.194.67.102:80 으로 요청을 보내고 있다. 출발지 PC는 요청에 임의의 포트 번호를 달아 보내게 된다. 여기서는 3345를 할당했다고 가정해보자. 192.168.1.2:3345 형태로 LAN에 데이터그램을 보내면, NAT은 이 데이터그램을 받아, NAT 출발 IP 주소를 NAT의 WAN쪽에 있는 인터페이스의 IP로 바꾸고, 포트번호도 NAT에서 할당 할 수 있는 새로운 출발지 번호로 다시 변경한다. 즉, 192.168.1.2:3345를 67.210.97.1:5505로 바꾼다는 뜻이다. 이 때, 변환된 정보를 저장하기 위해 NAT 변환 테이블(NAT Translation Table)을 사용한다. 이런 TCP 요청을 보내면, 다음과 같은 엔트리가 추가된다.</p><table><thead><tr><th>Protocol</th><th>LAN</th><th>WAN</th></tr></thead><tbody><tr><td>TCP</td><td>192.168.1.2:3345</td><td>67.210.97.1:5505</td></tr></tbody></table><p>서버는 다시 67.210.971:5505에게 응답을 보내게 되고, NAT는 NAT 변환 테이블을 사용해서 다시 원래 IP와 포트번호로 바꿔 LAN 네트워크로 보낸다.</p><blockquote><p>NAT의 포트 번호와 LAN의 장비를 연결해 테이블 엔트리를 작성하기 때문에, 결국 포트 숫자 만큼 동시접속을 허용한다. 2^16, 약 6만개의 동시접속을 허용하는 것이다.</p></blockquote><blockquote><p>위 방식은 NAT 종류 중 PAT(Port Address Translation) 방식에 해당한다.</p></blockquote><h2 id="사용-이유"><a href="#사용-이유" class="headerlink" title="사용 이유"></a>사용 이유</h2><ol><li>IP 주소 절약: 처음 언급한 것처럼, 하나의 공인 IP를 가지고 여러 사설망을 운영함으로써 IP 소비를 줄일 수 있다.</li><li>보안: NAT의 특성상, 요청을 보낸 측의 IP를 숨기는 효과가 있다. 라우터 안쪽의 최종 목적지를 외부에서는 알 수 없다. 따라서, 내부에서 외부로의 요청은 가능하지만, 외부에서 내부로 요청은 불가능하다.</li></ol><blockquote><p>단, NAT에서 포트포워딩을 통해 특정 포트에 대해서 내부로 라우팅을 처리한다면 가능하다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/network/">network</category>
      
      
      <category domain="https://changhoi.github.io/tags/cs/">cs</category>
      
      <category domain="https://changhoi.github.io/tags/network-layer/">network_layer</category>
      
      
      <comments>https://changhoi.github.io/posts/network/about-nat/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DHCP에 대하여</title>
      <link>https://changhoi.github.io/posts/network/about-dhcp/</link>
      <guid>https://changhoi.github.io/posts/network/about-dhcp/</guid>
      <pubDate>Wed, 22 Sep 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;DHCP란&quot;&gt;&lt;a href=&quot;#DHCP란&quot; class=&quot;headerlink&quot; title=&quot;DHCP란&quot;&gt;&lt;/a&gt;DHCP란&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;DHCP&lt;/strong&gt;(&lt;strong&gt;Dynamic Host Configuration Protocol&lt;/strong&gt;)은 호스트 IP에 주소를 동적으로 자동 할당하는 방식이다. 호스트에게 IP를 할당하는 작업은 수동으로도 할 수 있지만, 일반적으로 DHCP을 사용한다. 관리자는 수동으로 IP를 설정하지 않고, 특정 호스트가 들어왔을 때 이 호스트가 특정 IP를 받도록 하거나, 임시 IP 주소를 받도록 DHCP를 설정해두면 된다. 아래 이미지는 공유기 설정에 있는 DHCP 설정 화면이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="DHCP란"><a href="#DHCP란" class="headerlink" title="DHCP란"></a>DHCP란</h2><p><strong>DHCP</strong>(<strong>Dynamic Host Configuration Protocol</strong>)은 호스트 IP에 주소를 동적으로 자동 할당하는 방식이다. 호스트에게 IP를 할당하는 작업은 수동으로도 할 수 있지만, 일반적으로 DHCP을 사용한다. 관리자는 수동으로 IP를 설정하지 않고, 특정 호스트가 들어왔을 때 이 호스트가 특정 IP를 받도록 하거나, 임시 IP 주소를 받도록 DHCP를 설정해두면 된다. 아래 이미지는 공유기 설정에 있는 DHCP 설정 화면이다.</p><span id="more"></span><p><img src="/images/2021-09-23-about-dhcp/01.png" alt="공유기 설정의 DHCP"></p><blockquote><p>호스트에게 동적으로 IP를 할당해주는 것 말고도, 서브넷 마스크 첫 번째 홉 라우터 (Default Gateway)의 IP 주소나, 로컬 DNS 서버 주소를 얻게 해준다.</p></blockquote><p>이 기능은 호스트가 빈번하게 들어왔다 나갔다 하는 환경에 아주 유용하다. 예를 들어 도서관과 같은 곳에서 사람들이 IP를 얻기 위해 매번 네트워크 관리자를 찾아갈 필요가 없다.</p><hr><p>DHCP는 클라이언트/서버 구조의 프로토콜이다. 여기서 클라이언트는 네트워크 설정을 위한 정보를 얻기 위해 도착한 새로운 호스트이다. 서브넷에는 일반적으로 하나의 DHCP 서버를 갖는다. 만약 없다면, 해당 네트워크에서 사용할 DHCP 서버 주소를 알려줄 DHCP 연결 에이전트(일반적으로 라우터)가 필요하다.</p><p><img src="/images/2021-09-23-about-dhcp/02.png" alt="DHCP가 포함된 서브넷 구조"></p><p><code>223.1.2.0/24</code> 서브넷에 연결된 DHCP 서버가 있고 나머지 두 서브넷에는 없기 때문에, 라우터가 DHCP 연결 에이전트 역할을 한다.</p><h2 id="DHCP-동작"><a href="#DHCP-동작" class="headerlink" title="DHCP 동작"></a>DHCP 동작</h2><p>새로 들어온 클라이언트는 4단계 과정을 거쳐 IP를 할당받는다.</p><h3 id="1-DHCP-서버-발견-DHCP-server-discovery"><a href="#1-DHCP-서버-발견-DHCP-server-discovery" class="headerlink" title="1. DHCP 서버 발견 (DHCP server discovery)"></a>1. DHCP 서버 발견 (DHCP server discovery)</h3><p>새롭게 도착한 호스트는 상호 동작될 DHCP를 찾아야 한다. 이 과정은 <strong>DHCP 발견 메시지</strong>(<strong>DHCP discover message</strong>)를 통해 수행된다. 클라이언트는 서버의 67번 포트로 UDP 패킷을 보낸다. 현재 호스트는 자신이 접속될 네트워크 주소도 모르고 DHCP 서버의 주소도 모른다. 이런 상황이기 때문에 DHCP 발견 메시지를 포함하는 IP 데이터그램으로 UDP 패킷을 캡슐화 하는데, 이 메시지 내의 목적지 IP 주소는 브로드캐스팅 IP 주소인 <code>255.255.255.255</code>를 사용한다. 출발지 주소는 <code>0.0.0.0</code>으로 설정한다. 이 데이터그램은 링크 계층에 의해 서브넷 안에서 연결된 모든 노드로 브로드캐스팅 된다.</p><h3 id="2-DHCP-서버-제공-DHCP-server-offer"><a href="#2-DHCP-서버-제공-DHCP-server-offer" class="headerlink" title="2. DHCP 서버 제공 (DHCP server offer)"></a>2. DHCP 서버 제공 (DHCP server offer)</h3><p>DHCP 발견 메시지를 받은 서버는 <strong>DHCP 제공 메시지</strong>를 보내 응답한다. 이 때에도 다시 IP 브로드캐스팅 주소 <code>255.255.255.255</code>를 사용해 서브넷의 모든 노드로 보낸다. 제공 메시지에는 다음 정보들이 포함되어있다.</p><ul><li>수신된 메시지의 트랜잭션 ID</li><li>클라이언트에게 제공된 IP 주소</li><li>네트워크 마스크</li><li>IP 주소 임대 기간 (IP 주소가 유효한 시간)</li></ul><h3 id="3-DHCP-요청-DHCP-request"><a href="#3-DHCP-요청-DHCP-request" class="headerlink" title="3. DHCP 요청 (DHCP request)"></a>3. DHCP 요청 (DHCP request)</h3><p>서브넷에는 도달할 수 있는 DHCP 서버가 복수일 수 있으므로, 클라이언트는여러 응답 중 하나를 선택해 파라미터 설정을 통해 DHCP 요청 메시지를 만들어 응답한다.</p><h3 id="4-DHCP-ACK"><a href="#4-DHCP-ACK" class="headerlink" title="4. DHCP ACK"></a>4. DHCP ACK</h3><p>서버는 DHCP 요청 메시지에 대해 요청된 파라미터를 확인하는 DHCP ACK 메시지로 응답한다.</p><p><img src="/images/2021-09-23-about-dhcp/03.png" alt="DHCP Handshake"></p><hr><p>클라이언트가 ACK를 받으면 상호 동작은 종료되고 IP 주소를 임대 기간 동안 사용할 수 있다. </p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/network/">network</category>
      
      
      <category domain="https://changhoi.github.io/tags/cs/">cs</category>
      
      <category domain="https://changhoi.github.io/tags/network-layer/">network_layer</category>
      
      
      <comments>https://changhoi.github.io/posts/network/about-dhcp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>처음 시작하는 마이크로서비스 간단 리뷰</title>
      <link>https://changhoi.github.io/posts/books/microservices-up-and-running-review/</link>
      <guid>https://changhoi.github.io/posts/books/microservices-up-and-running-review/</guid>
      <pubDate>Tue, 21 Sep 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;이번년도에도 한빛 미디어의 &lt;strong&gt;나는 리뷰어다&lt;/strong&gt;에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 9월달 미션으로 나온 책 중에 하나인 &lt;strong&gt;처음 시작하는 마이크로서비스&lt;/strong&gt;를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번년도에도 한빛 미디어의 <strong>나는 리뷰어다</strong>에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 9월달 미션으로 나온 책 중에 하나인 <strong>처음 시작하는 마이크로서비스</strong>를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.</p><span id="more"></span><p>기술적인 내용을 기대한다면, 사실 이 책은 추천도서로 오를 수 없다. 이 책은 마이크로서비스를 도입하고자 하는 팀에게 기술 외적인 부분에서부터 팀 구성과 팀의 규칙, 그리고 경계를 설정하는 등 비 개발적인 영역에서 고민해야 하는 점들부터 시작한다. 그러나 간단하게나마 기술에 대한 구체적인 이야기도 나오기 때문에, Up &amp; Running이라는 말이 정말 딱 어울린다. 어떻게 팀을 구성할 수 있는지, 어떤 팀이 있고 어떤 역할을 하는지에 대한 일반적인 이야기가 궁금한 사람들에게 정말 필요한 도서이다. 필자도 마이크로서비스에 대해 아는 바가 없었기 때문에 이런 이야기들이 반가웠다.<br>이 책이 마이크로서비스를 접해본 적 없는 초보자에게 만큼은 아주 좋은 책이라고 생각했는데, 책 전반적인 내용에서 CI/CD를 다루는 내용과, IaC에 대한 내용, 그리고 결과적으로 핸즈온 성격으로 항공편 관련 애플리케이션을 마이크로서비스로 구성해볼 수 있도록 책을 구성했다. 마이크로서비스는 꽤 거대한 영역이라는 생각이 많이 드는데, 그 영역을 공부하는 물꼬를 틀 수 있는 좋은 책이라고 생각했다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/books/">books</category>
      
      
      <category domain="https://changhoi.github.io/tags/review/">review</category>
      
      
      <comments>https://changhoi.github.io/posts/books/microservices-up-and-running-review/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>메모리 할당과 매핑</title>
      <link>https://changhoi.github.io/posts/os/memory-allocation-and-mapping/</link>
      <guid>https://changhoi.github.io/posts/os/memory-allocation-and-mapping/</guid>
      <pubDate>Wed, 08 Sep 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;우리는 코드를 짤 때, 실제 메모리 위치를 알고 코드를 쓰지 않는다. &lt;code&gt;count := 10&lt;/code&gt; 이라는 코드를 쓰면, &lt;code&gt;count&lt;/code&gt;라는 변수가 메모리 어디에 위치하는지를 알고 짜는 것은 아니다. 프로그램을 동작시키려면 메모리에 올려야 하는데, 이 과정에서 발생하는 우리가 짠 코드가 실제 메모리에는 어떻게 올라가고, 어떻게 주소를 찾아가는지에 대한 이야기이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>우리는 코드를 짤 때, 실제 메모리 위치를 알고 코드를 쓰지 않는다. <code>count := 10</code> 이라는 코드를 쓰면, <code>count</code>라는 변수가 메모리 어디에 위치하는지를 알고 짜는 것은 아니다. 프로그램을 동작시키려면 메모리에 올려야 하는데, 이 과정에서 발생하는 우리가 짠 코드가 실제 메모리에는 어떻게 올라가고, 어떻게 주소를 찾아가는지에 대한 이야기이다.</p><span id="more"></span><h1 id="Continuous-Memory-Allocation"><a href="#Continuous-Memory-Allocation" class="headerlink" title="Continuous Memory Allocation"></a>Continuous Memory Allocation</h1><p>연속 메모리 할당 방식은 초기 버전의 메모리 할당 방식에 해당한다. 가장 쉬운 방법으로는 고정된 크기로 메모리를 나눠 프로세스에게 할당해주는 방식이 있고, 효율적인 메모리 분배를 위해 파티션을 프로세스 크기에 따라 나누는 방법이 있다.</p><h2 id="Fixed-Partition-FPM-고정-분할"><a href="#Fixed-Partition-FPM-고정-분할" class="headerlink" title="Fixed Partition (FPM, 고정 분할)"></a>Fixed Partition (FPM, 고정 분할)</h2><p>이름대로, 고정된 크기로 메모리를 나누는 방식이다. 각 분할마다 한 프로세스를 가지게 되며, 이때 분할의 개수를 <strong>다중 프로그래밍 정도</strong>(Multiprogarmming Degree)라고 한다. 한 분할이 비게 되면 프로세스가 입력 큐(<code>input queue</code>)에서 선택되어 빈 분할로 들어오게 된다. 이 방식은 내부 단편화와 외부 단편화 모두 발생할 수 있다.</p><h2 id="Variable-Partition-VPM-가변-분할"><a href="#Variable-Partition-VPM-가변-분할" class="headerlink" title="Variable Partition (VPM, 가변 분할)"></a>Variable Partition (VPM, 가변 분할)</h2><p>가변 분할 방식에서는 어떤 부분이 사용되었는지를 파악하는 테이블을 사용해야 한다. 초기에는 하나의 큰 사용 가능한 블록, <strong>hole</strong>이 있는 상태라고 한다. 프로세스가 <code>input queue</code>에 들어오면 프로세스가 사용할 메모리를 확인하고, 남은 공간이 있다면 필요한 메모리만큼 할당해준다. 이 방식에서는 내부 단편화가 발생할 수 없지만, 여러 프로세스에 메모리를 할당하고 빼주는 과정을 거치다 보면 외부 단편화 문제는 발생할 수 있다. 예를 들어, 다음 시나리오를 생각해보자.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">매모리 공간 55MB</span><br><span class="line"></span><br><span class="line">1. P1 적재 -&gt; 20MB</span><br><span class="line">2. P2 적재 -&gt; 10MB</span><br><span class="line">3. P3 적재 -&gt; 10MB</span><br><span class="line">3. P4 적재 -&gt; 10MB</span><br><span class="line">4. P1, P3, P4 종료</span><br><span class="line">5. P5 적재 -&gt; 30MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>위 시나리오에서 초기 상태, 메모리 사용 상태를 파악하는 <strong>파티션 테이블</strong>은 다음과 같다.  </p><img src="/images/2021-09-09-memory-allocation-and-mapping/01.png?style=centerme" width="500" height="200"><p><code>P4</code>까지 적재된 후의 상태는 다음과 같다.  </p><img src="/images/2021-09-09-memory-allocation-and-mapping/02.png?style=centerme" width="500" height="200">    <p>이제 <code>P1</code>, <code>P3</code>, <code>P4</code>가 종료 되고 나면 Partition 1, 3, 4는 빈 공간이 되고, 3, 4번 파티션이 합쳐진다.  </p><blockquote><p>이렇게 빈 영역을 하나의 파티션으로 합치는 것을 <code>Coalescing holes</code>(공간 통합)라고 한다.</p></blockquote><img src="/images/2021-09-09-memory-allocation-and-mapping/03.png?style=centerme" width="500" height="200"><p>현재 남은 공간은 총 45MB이지만, 이는 연속되지 않았기 때문에 <code>P5</code>를 적재할 수 없는 상태이다. 즉, 외부 단편화가 발생하는 상황인 것이다.</p><hr><h2 id="메모리-배치-전략"><a href="#메모리-배치-전략" class="headerlink" title="메모리 배치 전략"></a>메모리 배치 전략</h2><p>위와 같은 예시 상태에서, <code>P5</code>가 10MB라고 가정해보자. 현재 남은 파티션은 1, 3이고 두 파티션 모두 적재할 수 있는 크기이다. 그렇다면 어디에 배치할 수 있을까? 이것을 결정하는 문제의 해결책은 대표적으로 <strong>최초 적합</strong>(<strong>First-fit</strong>), <strong>최적 적합</strong>(<strong>Best-fit</strong>), <strong>최악 적합</strong>(<strong>Worst-fit</strong>)이 있다.</p><h3 id="최초-적합-First-fit"><a href="#최초-적합-First-fit" class="headerlink" title="최초 적합 (First-fit)"></a>최초 적합 (First-fit)</h3><p>메모리 가용 파티션 중 첫 번째로 사용 가능한 공간을 할당해준다. 검색 시작은 집합의 시작에서부터 하거나, 지난 번에 검색이 끝났던 위치부터 시작할 수 있다.</p><blockquote><p>지난 번에 검색이 끝났던 위치부터 시작하는 경우를 <strong>Next-fit</strong>으로 구분하기도 한다. 이 방식을 사용하면 메모리가 한 쪽만 지나치게 사용되는 문제를 해결할 수 있다.</p></blockquote><h3 id="최적-적합-Best-fit"><a href="#최적-적합-Best-fit" class="headerlink" title="최적 적합 (Best-fit)"></a>최적 적합 (Best-fit)</h3><p>사용 가능한 공간들 중에서 가장 작은 것을 선택한다. 리스트가 크기 순서로 되어있지는 않으므로 모든 리스트를 탐색해야 하는 오버해드가 존재한다. 이 방식은 아주 작은 파티션을 만들어낸다.</p><h3 id="최악-적합-Worst-fit"><a href="#최악-적합-Worst-fit" class="headerlink" title="최악 적합 (Worst-fit)"></a>최악 적합 (Worst-fit)</h3><p>가장 큰 가용 공간을 선택한다. 마찬가지로 리스트가 크기 순서로 정렬되어있지 않다면 모두 탐색해야 한다. 이 방식은 남게 되는 공간이 비교적 클 확률이 높다.</p><blockquote><p>이 세 가지 방식 중 어떤 것이 더 낫다는 이론적으로 확정할 수는 없지만 모의 실험을 해봤을 때, 시간과 메모리 이용 효율 측면에서 최악 적합이 가장 안 좋았고, 최초 적합과 최적 적합이 공간 효율성은 비슷했지만 속도 면에서 최초 적합이 더 빠르게 나타났다고 한다.</p></blockquote><hr><h1 id="Non-Continuous-Memory-Allocation"><a href="#Non-Continuous-Memory-Allocation" class="headerlink" title="Non-Continuous Memory Allocation"></a>Non-Continuous Memory Allocation</h1><p>어떻게 하면 외부 단편화 문제를 완화할 수 있을까? 가변 분할 방식에서 외부 단편화는 프로세스가 메모리에 적재 되었다가, 빠지는 과정을 반복하면서, 불연속적인 공간이 남는 것으로 인해 발생했다. 그렇다면, 이런 불연속한 부분을 사용 중인 영역을 밀어 올려 없애는 걸 생각해볼 수 있을 것 같다. 이 방식을 <code>Storage Compaction</code>(메모리 압축)이라고 한다. 프로세스 처리에 필요한 적재 공간을 확보해야 할 때 사용할 수 있다. 예를 들어서, 위 테이블을 재배치 하면 다음과 같이 변경된다.  </p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/04.png?style=centerme"></p><p>그러나 이 방식은, 프로세스를 모두 중지 해야 하고, 많은 시스템 자원을 소비하는 방식이다.<br>이 문제를 해결하는 다른 접근 방식은 한 프로세스의 논리 주소 공간을 여러 비연속적인 공간으로 나눠 필요한 크기의 공간을 사용할 수 있을때 메모리에 할당해주는 방식이다. 이를 <code>Non-Continuous Memory Allocation</code>이라고 한다. 정확하게는, 사용자 프로그램을 여러개의 블록으로 분할하고, <code>swap-device</code>에 모두 두고, 실행시 필요한 블록만 메인 메모리에 적재하는 방식이다. 이를 구현한 방식이 페이징(<code>Paging</code>)과 세그먼테이션(<code>Segmentation</code>)이다. 두 방식은 결합되어 사용될 수도 있다</p><h2 id="Address-Mapping"><a href="#Address-Mapping" class="headerlink" title="Address Mapping"></a>Address Mapping</h2><p>Address Mapping은, 연속 할당 방식에서는, 상대 주소를 물리 주소로 “재배치”하는 작업을 뜻했다. 불연속 메모리 할당 방식에서는 <code>Virtual Address</code> (가상 주소) 개념이 등장한다. 이는 연속 메모리 할당 방식의 “상대 주소”와 같다고 볼 수 있다. <code>Real Address</code>는 물리 주소와 같은 소리이고, 실제 메모리 주소를 뜻한다. 불연속 메모리 할당 방식의 메모리 매핑은 가상 주소를 실제 주소로 바꿔주는 과정이다.  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User process의 Virtual Address] -&gt; (Address Mapping) -&gt;[Real Address]</span><br></pre></td></tr></table></figure><blockquote><p>논리적, 가상적의 뉘앙스의 메모리는 프로그램이 가지고 있는 연속을 가정한 가상의 주소 형태라고 볼 수 있다. 대체적으로, <strong>시작점을 찾을 수 있는 단서</strong>와 <strong>시작점으로부터 얼마나 많이 떨어져 있는가</strong>와 같은 튜플로 구성된다. 물리적, 실제의 뉘앙스의 메모리는 메인 메모리의 위치이다.  </p></blockquote><h3 id="Block-Mapping"><a href="#Block-Mapping" class="headerlink" title="Block Mapping"></a>Block Mapping</h3><p>사용자 프로그램을 블록 단위로 분할하고 관리하는 시스템에서의 매핑 방식이다. 가상 주소를 <strong>블록 숫자</strong>와 얼마나 <strong>시작점에서 떨어져있는지</strong>에 대한 정보를 가지고 표현한다.  </p><p>즉, <code>V = (b, d)</code>로 표현하는데, <code>b</code>는 <code>block number</code>를 뜻하고, <code>d</code>는 <code>displacement</code>를 의미한다.  </p><blockquote><p><code>displacement</code>는 쉽게 말해 <code>offset</code>이다. <code>block number</code>로부터 블록의 실제 메모리 주소를 가지고, 해당 Instruction이 시작점으로부터 얼마나 떨어진 명령인지 알려주는 역할을 한다.  </p></blockquote><p>Address Mapping 정보는  <code>Block Map Table</code>(<code>BMT</code>)에서 관리된다. 프로세스마다 하나의 <code>BMT</code>를 커널 공간에 가지고 있다. <code>BMT</code>가 관리하는 정보는 대략 다음과 같다.  </p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/05.png?style=centerme"></p><blockquote><p><code>residence bit</code>는 해당 블록이 메모리에 올라간 상태인지를 나타내주는 비트이다.  </p></blockquote><p><code>V = (b, d)</code>로 표현되면, 먼저 <code>BMT</code>에서 <code>b</code>에 해당하는 열을 찾는다. 해당 열에서는 블록이 메모리에 적재된 상태인지 아닌지 확인 후, 적재된 상태라면 <code>Real Address</code>를 받아와서 <code>d</code>와 함께 명령어 주소를 찾는다. 적재되지 않은 상태라면 해당 블록을 메모리에 올리고 <code>BMT</code>를 업데이트 하고 <code>Real Address</code>를 받아와 명령어 주소를 계산한다.<br>사용자 프로그램을 여러 개의 블록으로 분할하고, <code>swap-device</code>에 모두 두고, 실행 시 필요한 블록만 메인 메모리에 적재하는 방식이다.  </p><blockquote><p>이 방식은 구체적인 구현이라기 보단, <code>Non-continuous Memory Allocation</code>에서 주로 사용하는 메모리 매핑 방법이다. 이후, 구체적으로 페이징 방식이나, 세그먼테이션 방식에서 어떻게 주소를 찾아주는지 나온다.</p></blockquote><hr><h2 id="Paging-System"><a href="#Paging-System" class="headerlink" title="Paging System"></a>Paging System</h2><p>프로그램을 같은 크기의 블록으로 분할하는 방식이다. 나누어진 블록을 <code>Page</code>(페이지)라고 부르고, 메모리의 분할 영역을 <code>Page Frame</code>(페이지 프레임)이라고 부른다. 페이지와 페이지 프레임은 같은 크기이다. 프로세스는 분할된 페이지로 나눠져 예비 저장 장치 또는 파일 시스템에 놓여진다. 나눠진 페이지 중 사용되는 페이지를 메모리에 올리는 방식이다.  </p><blockquote><p>교과서와 다르게, 강의에서는 예비 저장 장치, 파일 시스템은 <code>Secondary Storage</code> / <code>Swap Device</code>로 지칭되었는데 같은 의미로 봐도 될 것 같다.  </p></blockquote><p>우선 가장 큰 특징은 논리적 분할이 아니라 크기에 따른 분할이다. 이러한 특징으로 인해, 이후 세그먼테이션에서 확인할 수 있겠지만, 페이지 공유나 보호 과정이 복잡하다. 그러나 단순한 설계 방식으로 효율적으로 관리할 수 있다. 또한 외부 단편화는 발생할 수 없지만, 내부 단편화는 발생할 수 있다.  </p><blockquote><p>OSX의 기본 페이지 사이즈는 4096Bytes인 것 같다. <code>vm_stat</code> 명령어로 터미널에서 현재 가상 메모리 상태를 확인할 수 있다. 나타내는 구체적인 정보는 <a href="https://www.oreilly.com/library/view/mac-os-x/0596003560/ch08s01s05.html">이 링크</a>에서 확인할 수 있다.</p></blockquote><p><img src="/images/2021-09-09-memory-allocation-and-mapping/vmstat.png?style=centerme" alt="vm_stat 명령어 결과"></p><h3 id="Address-Mapping-1"><a href="#Address-Mapping-1" class="headerlink" title="Address Mapping"></a>Address Mapping</h3><p>위의 블록 매핑 방식과 유사하다. 블록이라는 이름 대신 페이지를 사용하는 것이라고 볼 수 있다. 가상 주소를 다음과 같이 표현할 수 있다.   </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = (p, d)</span><br><span class="line">p: page number</span><br><span class="line">d: displacement</span><br></pre></td></tr></table></figure><p>위 정보와 함께, 물리 주소를 찾기 위해 페이지 <code>PMT</code>(<code>Page Map Table</code>)를 사용한다. 페이지 테이블은 대략 다음과 같이 생겼다.  </p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/06.png?style=centerme"></p><p>페이지 맵 테이블은 커널 안에(메모리 안에) 있다. 다음과 같은 프로세스를 따른다고 볼 수 있다.  </p><ol><li>프로세스의 PMT가 저장된 주소 <code>b</code>에 접근</li><li>PMT에서 page p의 엔트리를 찾는다. (<code>b + p * entrySize</code>)</li><li>찾아진 entry의 <code>residence bit</code> 검사<ol><li><code>residence bit == 0</code>인 경우, <code>page fault</code>라고 부른다.<pre><code> swap device에서 해당 page를 메모리에 적재하고 PMT를 갱신 후 3-2 수행 이 과정은 컨텍스트 스위칭이 발생하고, 오버해드가 크다.</code></pre></li><li><code>residence bit == 1</code>인 경우, 해당 entry에서 <code>page frame number</code> p’를 확인</li></ol></li><li>p’의 가상 주소의 <code>d</code>를 사용해 실제 주소 <code>r</code>을 만든다. (<code>r = p&#39; * pageSize + d</code>)</li></ol><hr><p>지금까지 소개한 방법은 <code>Directed Mapping</code>이라는 이름으로 불린다. 커널 위의 매핑 테이블을 메모리에서 찾아오는 방식인데, 이 방식에서는 한 가지 문제점이 있다. 실제 주소를 얻기까지 메모리 접근을 두 번 해야한다는 것이다. 첫 번째는 <code>PMT</code>에 접근하기 위해서, 두 번째는 실제 메모리에 접근하기 위해서. 이 문제를 해결하기 위해서 <code>Associative Mapping</code>이라는 방법을 사용하는데, 간단히 말해서 <code>TLB</code>를 사용하는 방식이다.  </p><p><code>TLB</code>(Translation Look-aside Buffer)라는 특수한 캐시 하드웨어를 사용해, 이곳에 <code>PMT</code>를 적재하는 방식이다. <code>TLB</code>는 <code>page number</code>를 받으면, 페이지 테이블을 병렬적으로 탐색해 굉장히 빠르게 <code>page frame number</code>를 가져올 수 있다. 다만, <code>TLB</code>는 아주 비싸기 때문에, 작은 크기이다. 따라서, 큰 <code>PMT</code>를 다루기는 어렵다. 따라서, 일반적으로 <code>PMT</code>와 <code>TLB</code>를 함꼐 사용한다. <code>PMT</code>는 그대로 메모리 공간에 올려두고, <code>PMT</code> 일부만 <code>TLB</code>에 올리는 방식이다.  </p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/07.png?style=centerme"></p><p>만약 찾고자 하는 Page가 <code>TLB</code>에 없다면, <code>PMT</code>에서 가져와야 한다. 이때, 이미 <code>TLB</code>가 모두 차있다면, 대체해야 하는데 이 정책 중 일반적인 것이 최근에 가장 적게 사용된 엔트리를 빼는 것이다. 이는 메모리 지역성과 유관하다.  </p><h2 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h2><p>페이징 시스템은 논리적 단위가 아닌, 크기에 따라 프로세스를 나누기 때문에, 페이징을 공유하고 보호하는 것에서 어려움이 있다. 세그멘테이션 시스템은 프로세스를 논리적 블록으로분할한다. 즉, 프로그래머가 생각하는 모양대로 메모리를 분할해 적재해준다. 따라서, 블록의 크기는 서로 다를 수 있고 페이징 시스템에서 처럼 메모리를 미리 분할할 수도 없다.  </p><p>이 방식은 내부 단편화가 발생할 일이 없지만, 외부 단편화는 발생할 수 있다. 또한 세그멘트를 공유하거나 보호하는 작업을 하기 쉽지만, Address Mapping이나, 메모리 관리에서 오버헤드가 비교적 크다.  </p><h3 id="Address-Mapping-2"><a href="#Address-Mapping-2" class="headerlink" title="Address Mapping"></a>Address Mapping</h3><p>Non-continuous Allocation 방식의 Address Mapping의  방식과 마찬가지로, 가상 주소를 다음과 같이 표현한다.  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = (s, d)</span><br><span class="line">s: segment-number</span><br><span class="line">d: displacement (offset)</span><br></pre></td></tr></table></figure><p>페이징 시스템에서 사용한 것처럼 <code>SMT</code>(Segment Map Table)라는 매핑 테이블을 사용한다. 매커니즘도 <code>PMT</code>와 유사하다. <code>PMT</code>와 비교하자면, <code>segment length</code>와 <code>protection bits</code>가 추가되어있다.  </p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/08.png?style=centerme"></p><p>위와 같은 형태라고 볼 수 있는데, 추가된 두 필드는 다음과 같은 역할을 한다.  </p><ul><li><code>segment length</code>: 세그먼트의 크기를 기록한다. 실제 주소를 찾을때, 세그먼트 사이즈를 초과해 접근하지 않도록 만들어준다.</li><li><code>protection bits</code>: 세그먼트(예를 들어 함수나 데이터)에 대한 프로세스의 권한을 적는다.</li></ul><blockquote><p>읽기: R / 쓰기: W / 실행: X / 추가: A 비트가 있다고 한다. 위에서는 추가된 두 필드라고는 하지만, 실제로 페이징 시스템에도 <code>protection bits</code>는 있는 것으로 설명한다.</p></blockquote><hr><p>매핑을 할때는 다이렉트 매핑 과정을 거친다.  </p><ol><li><code>V = (s, d)</code>와 함께 <code>SMT</code>가 저장된 주소 <code>b</code>에 접근해 필요한 entry를 계산해낸다. (<code>b + s * entrySize*</code>)</li><li><code>SMT</code>의 entry에 대해 다음 단계를 순차적으로 수행한다.<ol><li><code>residence bit</code>가 0인 경우 (<strong>segment fault</strong>), <code>swap-device</code>로부터 해당 segment를 메모리에 적재하고, <code>SMT</code>를 갱신한다.</li><li><code>d</code>가 <code>segment length</code>의 길이보다 크다면, <strong>segment overflow exception</strong> 처리 모듈을 호출한다.</li><li><code>protection bits</code>를 확인해, 허가 되지 않은 연산인 경우 <strong>segment protection exception</strong> 처리 모듈을 호출한다.</li></ol></li><li>실제 주소 <code>r</code>을 찾아 명령어를 처리한다.</li></ol><blockquote><p>Paging System에서 처럼 TLB를 사용해서 메모리에 두 번 접근하는 오버헤드를 줄일 수 있다.  </p></blockquote><h3 id="Memory-Manangement"><a href="#Memory-Manangement" class="headerlink" title="Memory Manangement"></a>Memory Manangement</h3><p><code>VPM</code>과 유사하게, 세그먼트를 적재할 때, 그 크기에 맞춰 동적으로 메모리를 분할한 후 적재한다. 이를 관리하는 <strong>파티션 테이블</strong>이 요구된다. 아래 구성과 같이 파티션 테이블을 관리한다.  </p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/09.png?style=centerme"></p><hr><h2 id="Hybrid-System"><a href="#Hybrid-System" class="headerlink" title="Hybrid System"></a>Hybrid System</h2><p>페이징 시스템과 세그멘테이션 시스템의 장점을 결합한 시스템이다. 프로그램을 다음과 같이 분할한다.  </p><ol><li>논리 단위의 Segment로 분할</li><li>각 Segment를 고정된 크기의 Page들로 분할</li></ol><p>메모리에 적재할 때는 페이지 단위로 적재하게 된다.</p><h3 id="Address-Mapping-3"><a href="#Address-Mapping-3" class="headerlink" title="Address Mapping"></a>Address Mapping</h3><p>가상 주소는 다음과 같은 형태로 주워진다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V = (s, p, d)</span><br><span class="line">s: segment number</span><br><span class="line">p: page number</span><br><span class="line">d: offset</span><br></pre></td></tr></table></figure><p>매핑을 위해 <code>SMT</code>와 <code>PMT</code>를 모두 사용해야 한다. 각 <strong>프로세스마다</strong> 하나의 <code>SMT</code>가 존재하고, 하나의 <strong>세그먼트마다</strong> 하나의 <code>PMT</code>를 갖는 구조이다. <code>SMT</code> 테이블은 마지막에 실제 주소 대신, <code>PMT</code>의 베이스 주소를 알려준다. 아래는 하이브리드 시스템에서의 <code>SMT</code>이다.  </p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/10.png?style=centerme"></p><p>이전 <code>SMT</code>테이블과 다른 모습은, 첫 번째로 <code>resident bit</code>가 없다는 점이다. 실제 메모리에 올라가는 것은 Page이기 때문에 <code>residence bit</code>는 불필요하다. 두 번째는, 위에서 언급한 것처럼 실제 주소를 매핑하고 있지 않고, 해당 세그먼트의 <code>PMT</code> 메모리 주소를 매핑한다.  </p><p><code>PMT</code>는 페이징 시스템에서 봤던 것과 동일한 모습이다.</p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/11.png?style=centerme"></p><p>이런 형태의 테이블 구조로, 아래와 같이 프로세스를 나눈다.</p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/12.png?style=centerme"></p><p>아래는 다이렉트 매핑 방식에서의 메모리 매핑 플로우이다.</p><p><img src="/images/2021-09-09-memory-allocation-and-mapping/13.png?style=centerme"></p><p>이런 시스템을 사용했을 때, 실제 메모리에 접근하는 것을 포함해서 <strong>세 번을</strong> 접근해야 한다. 또한, 테이블 수도 증가하므로, 메모리 소모도 비교적 커지고, 매핑 과정 자체가 길어진다.  </p><blockquote><p>이런 오버헤드가 있지만, 사용함으로써 얻는 장점이 크기 때문에 사용되는 것이라고 볼 수 있다고 한다. Page sharing, protection에 강점이 있고, 메모리 할당 및 관리에 드는 오버헤드가 작다.</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN">https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a></li><li>운영체제 교과서</li></ul>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/os/">os</category>
      
      
      <category domain="https://changhoi.github.io/tags/cs/">cs</category>
      
      <category domain="https://changhoi.github.io/tags/memory/">memory</category>
      
      
      <comments>https://changhoi.github.io/posts/os/memory-allocation-and-mapping/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HTTPS 설명하기</title>
      <link>https://changhoi.github.io/posts/backend/https-dive/</link>
      <guid>https://changhoi.github.io/posts/backend/https-dive/</guid>
      <pubDate>Thu, 12 Aug 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;HTTPS를 잘 이해해보자. HTTP는 TCP 연결 이후 평문으로 요청을 전달한다. 즉, 중간에 탈취되었을 때 내용이 모두 노출된다는 것이다. 이런 문제를 해결하기 위해서 HTTPS를 사용한다. 어떻게 암호화 하는 건지 정리해봤다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>HTTPS를 잘 이해해보자. HTTP는 TCP 연결 이후 평문으로 요청을 전달한다. 즉, 중간에 탈취되었을 때 내용이 모두 노출된다는 것이다. 이런 문제를 해결하기 위해서 HTTPS를 사용한다. 어떻게 암호화 하는 건지 정리해봤다.</p><span id="more"></span><p>HTTP Over Secure Socket Layer 의 약자이다. 평문을 암호화 해서 보내는 것이 핵심 기술이다. 여기에 사용되는 방식은 비대칭키, 대칭키 암호화 방식이 사용된다.</p><h2 id="비대칭키-공개키-암호-방식"><a href="#비대칭키-공개키-암호-방식" class="headerlink" title="비대칭키 (공개키 암호 방식)"></a>비대칭키 (공개키 암호 방식)</h2><p>공개키 암호화 방식이라고도 하는 비대칭키 방식은, 두 개의 키를 가지고 암호화 및 복호화가 이루어진다. 하나는 공개키, 다른 하나는 비밀키라고 불린다. 공개키는 누구나 알아도 되지만, 비밀키는 소유자만이 알고 있어야 한다. 공개키 암호 방식은 두 가지 역할을 할 수 있다. 첫 번째는 암호화, 두 번째는 인증이다. 암호화는 암호화 방식이라는 이름에 맞게, 컨텐츠를 암호화 하고, 그 내용을 특정 사람만 확인할 수 있게 하는 방식이다. 공개키로 암호화 한 내용은 개인키로 복호화 할 수 있고, 개인키로 암호화 한 내용은 공개키로 복호화 할 수 있다. 인증은 해당 내용을 특정 대상이 맞음을 확인하는 것이다. 비밀키로 암호화 한 내용은 공개키로만 복호화 가능하기 때문에, 이 내용을 특정인이 보냈음을 확신할 수 있다. 이 두 가지 기능이 HTTPS에서 모두 적절하기 잘 활용된다.</p><blockquote><p>대칭키 방식은 암호화 하는 키와 복호화 하는 키가 같다.</p></blockquote><h2 id="인증"><a href="#인증" class="headerlink" title="인증"></a>인증</h2><p>HTTPS에서 인증이란, 자신이 받은 정보가, 올바른 사람이 전송한 것이 맞는지 확인하는 것을 인증이라고 할 수 있다. 공개키 방식은 누구나 공개키를 획득할 수 있기 때문에, 비밀키로 암호화한 정보는 암호화의 의미가 없다. 그러나 비밀키로 암호화한 정보를 공개키로 복호화 할 수 있다는 것은, 다시 말해 암호화 한 주체가 틀림없이 비밀키를 가지고 있음을 인증한다고 말할 수 있다. 이것이 “인증서”의 원리이다.</p><p><img src="/images/2021-08-13-https-dive/02.png?style=centerme"></p><h3 id="SSL-인증서"><a href="#SSL-인증서" class="headerlink" title="SSL 인증서"></a>SSL 인증서</h3><p>인증서는 다음 두 가지 역할을 하게 된다.</p><ol><li>클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다.</li><li>SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.</li></ol><h3 id="CA-Certificate-Authority"><a href="#CA-Certificate-Authority" class="headerlink" title="CA (Certificate Authority)"></a>CA (Certificate Authority)</h3><p>클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 하기 위해서, 특정 민간 기업이 이 역할을 해준다. 이런 기업들을 CA, 혹은 Root Certificate라고 한다. 이 CA는 브라우저에 탑재되어 있다. 브라우저는 CA의 리스트와 함께 인증서를 복호화 하기 위한 CA의 공개키를 가지고 있다.</p><blockquote><p>사설 인증 기관<br>개발이나 사적인 목적을 위해, SSL의 암호화 기능을 이용할 때, 직접 CA 역할을 할 수 있다. 이 경우에는 브라우저가 경고를 표시한다.</p></blockquote><h3 id="서비스의-보증"><a href="#서비스의-보증" class="headerlink" title="서비스의 보증"></a>서비스의 보증</h3><p>인증서 안에는 다음과 같은 내용이 포함되어있다.</p><ul><li>서비스의 정보(CA, 서비스 도메인 등)</li><li>서버의 공개키 (공개키 내용 및 암호화 방법 등)</li></ul><p>브라우저는 처음 서버에 접근할 때, 인증서를 받게 되고, 해당 인증서가 공인된 (브라우저에 저장된) CA 리스트 안에 있는 회사의 인증서임을 확인한다면, 알고 있는 공개키로 인증서를 복호화한다. 복호화가 가능하다는 것은 해당 인증서를 발급한 기관이 틀림 없이 보증된 회사임을 증명하는 것이다.</p><p>그렇다면 이제 브라우저는 위 “서비스의 정보”와 “서버의 공개키”가 생겼다. 이제 브라우저는 서버의 공개키를 통해 HTTP 평문을 암호화 할 수 있게 되었다. 이하 내용은 구체적으로 SSL이 어떻게 동작하게 되는 것인지를 담고 있다.</p><h2 id="SSL-동작"><a href="#SSL-동작" class="headerlink" title="SSL 동작"></a>SSL 동작</h2><p>실제로는 HTTP 내용을 비대칭키 방식으로 데이터를 암호화 하는 것이 아니다. 공개키 방식으로 암, 복호화 하는 과정은 컴퓨팅 파워의 소비가 필요하기 때문에, 실제 내용은 비교적 컴퓨팅 파워가 덜 소모되는 대칭키를 통해  암, 복호화 하게 된다.</p><p>우선 서버와 클라이언트가 연결되면서, Handshake 과정을 거치게 된다. 다음과 같은 과정을 지난다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/1/14/Abbreviated_TLS_1.2_Handshake.svg?style=centerme"></p><ol><li><p>Client Hello<br> 클라이언트가 서버에 접속하고 다음 정보를 가져온다.</p><ul><li>클라이언트에서 생성한 랜덤 데이터</li><li>클라이언트가 지원하는 암호화 방식: 클라이언트와 서버측이 사용할 암호화 방식에 대한 협상을 위해 클라이언트가 사용 가능한 암호화 방식을 전송한다.</li><li>세션 아이디: 이미 SSL Handshaking이 이루어진 상태라면, 기존 세션을 재활용하게 된다. 이때 사용할 세션 아이디를 서버에 전송한다.</li></ul></li><li><p>Server Hello<br> 서버는 클라이언트 Hello를 받고 다음 응답을 보내준다.</p><ul><li>서버측에서 생성한 렌덤 데이터</li><li>서버가 선택한 클라이언트 암호방식: 클라이언트가 전달한 암호화 방식 중, 서버에서도 사용할 수 있는 암호화 방식을 선택해 클라이언트로 전달한다.</li><li>인증서</li></ul></li><li><p>클라이언트가 가지고 있는 CA 리스트에서 인증서를 확인한다. CA 리스트 중에 있다면, 가지고 있는 해당 CA의 공개키를 통해 복호화한다.<br> 클라이언트는 서버의 랜덤 데이터와 클라이언트의 랜덤 데이터를 조합해 <code>pre master secret</code>이라는 키를 생성한다. 이 키는 이후 데이터를 암호화 하기 위해 사용된다. 위에서 언급했듯, 데이터를 암호화 하는 기법은 대칭키이므로 외부에 노출되어선 안된다.<br> 이제 만든 <code>pre master secret</code>을 전달해야 한다. 이 값을 안전하게 전달하기 위해서 인증서에서 획득한 공개키로 암호화해 서버로 전송하게 된다. </p></li><li><p>서버는 <code>pre master secret</code>을 개인키로 복호화한다. 이제 클라이언트와 서버 모두 <code>pre master secret</code> 키 값을 가지고 있는데, 일련의 과정을 통해 <code>master secret</code>을 만든다. 그리고 이 키값을 통해 세션 키를 만들게 된다. 이 세션 키를 이용해 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화한 후 주고 받는다. </p></li><li><p>클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.</p></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://brunch.co.kr/@sangjinkang/38">https://brunch.co.kr/@sangjinkang/38</a></li><li><a href="https://commons.wikimedia.org/wiki/File:Full_TLS_1.3_Handshake.svg">https://commons.wikimedia.org/wiki/File:Full_TLS_1.3_Handshake.svg</a></li><li><a href="https://opentutorials.org/course/228/4894">https://opentutorials.org/course/228/4894</a></li><li><a href="https://ko.wikipedia.org/wiki/%EB%8C%80%EC%B9%AD_%ED%82%A4_%EC%95%94%ED%98%B8">https://ko.wikipedia.org/wiki/%EB%8C%80%EC%B9%AD_%ED%82%A4_%EC%95%94%ED%98%B8</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/backend/">backend</category>
      
      
      <category domain="https://changhoi.github.io/tags/cs/">cs</category>
      
      
      <comments>https://changhoi.github.io/posts/backend/https-dive/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>이더리움 디앱 개발 간단 리뷰</title>
      <link>https://changhoi.github.io/posts/books/building-ethurium-dapp/</link>
      <guid>https://changhoi.github.io/posts/books/building-ethurium-dapp/</guid>
      <pubDate>Fri, 23 Jul 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;이번년도에도 한빛 미디어의 &lt;strong&gt;나는 리뷰어다&lt;/strong&gt;에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 7월달 미션으로 나온 책 중에 하나인 &lt;strong&gt;이더리움 디앱 개발&lt;/strong&gt;을 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번년도에도 한빛 미디어의 <strong>나는 리뷰어다</strong>에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 7월달 미션으로 나온 책 중에 하나인 <strong>이더리움 디앱 개발</strong>을 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.</p><span id="more"></span><p>블록체인에 관심을 갖기 시작한지는 조금 됐지만, 공부를 시작하기 참 막막한 감이 있었다. 갓빛미디어는 이런 내 상태를 어찌 알고 감사하게도 이 책을 후보로 만들어주셨고 좋은 책을 받아 읽게 되었다. 이 책은, 대상 독자를 지정해두었다. 깊게 읽어볼 시간은 없어서 내용만 따라가며 읽었을 때는, 이 대상 독자가 잘 설정 된 편이라고 생각되므로 말하자면, “이더리움을 이해하고, 활용하려는 소프트웨어 개발자, 아키텍트, 중급 프로그래밍 경험이 있는 개발자를 대상으로 한다.”고 되어있다. 또한 내용 중 Node를 사용하는 내용이 포함되어있어, 해당 부분에 이해도가 있다면 더 쉽게 책을 이해할 수 있다. 우선 본인은 블록체인이 무엇인지 알지 못했으며, 위에 해당하는 개발자라고 생각된다. 먼저 내용은 탈 중앙화 앱에 대한 소개로 시작한다. 그러면서 간단한 디앱을 만들 수 있도록 하며, 디앱에 대한 느낌을 알 수 있게 해준다. 점차 블록체인과, 그를 위해 사용하는 구체적인 기술들에 대해 나오는데, 이더리움, 스마트 컨트랙트, 솔리디티 등을 다룬다. 스마트 컨트랙트는 특히 새로운 챕터로 분리되어 복잡하고, 추상적인 컨트랙트에 대한 내용도 학습할 수 있게 되어있다. 필자는 아직 파트2까지만 읽어봤는데, 내용이 술술 읽히는 건 아니다. 그렇지만, 원래 조금은 복잡한 새로운 기술을 맞이하는 것이 쉽게 술술 읽혀질 리가 없다고 생각한다. (된다면? 나는 천재?) 그 뒷 부분은 핵심에서 조금은 벗어난, 배포와 생태계에 대한 내용들이다. 그러나 빠지면 미완성인 부분들이 맞기 때문에 책을 마저 다 보고 싶다. 좋은 책이고, 블록체인에 대한 실체를 느낄만한 개론서, 입문서라고 생각이 들었다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/books/">books</category>
      
      
      <category domain="https://changhoi.github.io/tags/review/">review</category>
      
      
      <comments>https://changhoi.github.io/posts/books/building-ethurium-dapp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Red-Black Tree</title>
      <link>https://changhoi.github.io/posts/algorithm/red-black-tree/</link>
      <guid>https://changhoi.github.io/posts/algorithm/red-black-tree/</guid>
      <pubDate>Wed, 30 Jun 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;알고리즘 문제를 해결하다가, &lt;a href=&quot;https://www.acmicpc.net/problem/7662&quot;&gt;이중 우선순위 큐&lt;/a&gt; 문제를 만났다. 문제 시간 제한이 6초라고 되어있길래, Binary Search Tree(BST)로 구현하려고, &lt;code&gt;HashMap&lt;/code&gt;을 사용했다. 다만 만든 트리 구조가 최악의 경우 더하는 연산이 O(n)이기 때문에, 시간 초과가 났다. AVL이 생각이 났는데, 어떻게 구현하는지를 알지 못해 알아보던 도중 자바에 TreeMap 구조가 Red-Black Tree(RBT)라는 걸 알게되었다. TreeMap 이전에 RBT를 더 자세히 공부하고 싶어 위키트리 내용을 최대한 풀어서 정리했다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>알고리즘 문제를 해결하다가, <a href="https://www.acmicpc.net/problem/7662">이중 우선순위 큐</a> 문제를 만났다. 문제 시간 제한이 6초라고 되어있길래, Binary Search Tree(BST)로 구현하려고, <code>HashMap</code>을 사용했다. 다만 만든 트리 구조가 최악의 경우 더하는 연산이 O(n)이기 때문에, 시간 초과가 났다. AVL이 생각이 났는데, 어떻게 구현하는지를 알지 못해 알아보던 도중 자바에 TreeMap 구조가 Red-Black Tree(RBT)라는 걸 알게되었다. TreeMap 이전에 RBT를 더 자세히 공부하고 싶어 위키트리 내용을 최대한 풀어서 정리했다.</p><span id="more"></span><h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p>RBT는 자료의 추가, 삭제, 검색에서 최악의 경우도 일정한 Worst Case를 보장한다. 이런 특성은, 실행 시간이 중요한 경우, 일정 시간 실행을 보장해야 하는 경우 등 유용하게 쓰인다. 앞서 생각했던 <a href="https://ko.wikipedia.org/wiki/AVL_%ED%8A%B8%EB%A6%AC">AVL Tree</a>는 균형에 대한 더 엄격한 기준이 있어서, 삽입과 삭제시 더 많은 회전이 필요하다 (균형을 위한)</p><h2 id="특성"><a href="#특성" class="headerlink" title="특성"></a>특성</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png?style=centerme"></p><p>RBT는 각각의 노드가 레드, 블랙 속성을 가지고 있는 BST이다. BST의 조건에 추가적으로 다음과 같은 조건을 만족해야 한다.</p><ol><li>노드는 레드 또는 블랙이다.</li><li>루트 노드는 블랙이다.</li><li>모든 리프 노드들(NIL)은 블랙이다.</li><li>레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다. 즉, 레드 노드는 연달아 나타날 수 없고, 블랙 노드만 레드 노드의 부모 노드가 될 수 있다.</li><li>어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.</li></ol><p>네 번째, 다섯 번째 속성때문에, 극단적인 최단 경로의 경우 블랙 노드만 존재하는 경우이고, 극단적인 최장 경로의 경우 레드와 블랙 노드가 섞여 나오는 경우이다. 이 경우를 가정했을 때에도, 최단 경로와 최장 경로의 차이는 최단 경로의 두 배보다 항상 작다.</p><h2 id="동작"><a href="#동작" class="headerlink" title="동작"></a>동작</h2><p>일단, 읽기 작업은 일반적인 BST처럼 진행하면 된다. 다만, 삭제와 삽입은 위 특성을 만족시키기 위해 추가적인 작업이 필요하다. 아래는 위키피디아에서 설명하는 알고리즘을 본인이 읽기 쉽게 정리한 내용이다. 사용된 이미지도, 위키피디아에서 가져왔다.</p><h3 id="삽입"><a href="#삽입" class="headerlink" title="삽입"></a>삽입</h3><p>RBT에서 삽입은, BST의 삽입과 동일한 방식으로 우선 삽입 후, 색을 붉은 색으로 만든다. 그 다음 단계는 그 주위 노드의 색에 따라 다르다. RBT에서는 <code>삼촌노드(uncle node)</code>에 대한 개념이 나온다. 부모 노드의 형제 노드를 뜻한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUncle</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = getGrandparent(node);</span><br><span class="line">    <span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="literal">undefined</span>;    <span class="comment">// 할아버지 노드가 없으면, 형제노드는 당연히 없다.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> uncle = g.left === node.parent ? g.right : g.left;</span><br><span class="line">    <span class="keyword">return</span> uncle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 다음 삽입하는 경우의 수를 살펴보자.</p><ul><li><p>처음 루트에 N이 삽입될 때<br>이 경우, RBT의 첫 번째 속성을 위해 N은 검은색이 된다. 그 이후는 RBT가 유지된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCase1</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node.parent) node.color = BLACK;</span><br><span class="line">    <span class="keyword">else</span> insertCase2(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>새로운 노드의 부모 노드가 검은색인 경우<br>이 경우도 RBT가 유지된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCase2</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.parent.color === BLACK) <span class="keyword">return</span>;</span><br><span class="line">    insertCase3(node);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>부모 노드와 삼촌 노드가 모두 붉은색인 경우<br>레드 블랙 트리의 다섯 번째 특성을 유지하기 위해서 부모 P와 삼촌 U를 검은색으로 바꾸고, 할아버지 G를 붉은 색으로 바꾼다. 이렇게 되면, 새로 추가되는 노드 N은 검은 부모를 갖게 된다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png?style=centerme"></p><p>다만 이 경우에, 할아버지 노드에서 두 번째 속성 또는 네 번째 속성을 만족하지 않을 수 있다. 이를 위해 지금까지 설명한 세 가지 케이스를 할아버지 노드에도 적용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCase3</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> u = getUncle(node);</span><br><span class="line">    <span class="keyword">if</span> (u &amp;&amp; u.color === RED) &#123;</span><br><span class="line">        node.parent.color = BLACK;</span><br><span class="line">        u.color = BLACK;</span><br><span class="line">        <span class="keyword">const</span> g = getGrandparent(node);</span><br><span class="line">        g.color = RED;</span><br><span class="line">        insertCase1(g);</span><br><span class="line">    &#125; <span class="keyword">else</span> insertCase4(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>부모는 붉은색인데, 삼촌은 검은색이고, N이 부모의 오른쪽(왼쪽) 자식 노드이고, 부모는 할아버지의 왼쪽(오른쪽) 자식 노드인 경우<br>조건부터 아주 복잡한데, 위 순서대로 따라와보면 확인해야 하는 조건은 새로운 노드의 위치와 부모 노드의 위치라는 사실을 알 수 있다. 이 경우, N과 P의 역할을 변경하기 위해 왼쪽 회전을 해야한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCase4</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = getGrandparent(node);</span><br><span class="line">    <span class="keyword">if</span> (node === node.parent.right &amp;&amp; node.parent === g.left) &#123;</span><br><span class="line">        rotateLeft(n.parent);</span><br><span class="line">        n = n.left;   <span class="comment">//과거에 부모 노드였던 것을 새로운 노드로 바꿔줌</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n === n.parent.left &amp;&amp; n.parent === g.right) &#123;</span><br><span class="line">        rotateRight(n.parent);</span><br><span class="line">        n = n.right;  <span class="comment">// 위와 마찬가지</span></span><br><span class="line">    &#125;</span><br><span class="line">    insertCase5(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>이런 설명은 없지만, <code>insertCase4</code>는 부모 노드와 새로운 노드의 선을 직선으로 맞추는 느낌이 있다. 이는 다음 케이스로 넘어가기 위한 준비 과정처럼 보인다. </p></blockquote><p><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png?style=centerme"></p><p>그 이후, 부모 노드였던 P가 RBT의 다섯 번째 특성을 어기는 문제를 해결해야 한다. 그런데, 현재 상황이, 부모 노드였던 P를 새로운 노드로 판단한다면, 4번째 조건 중 “N이 부모의 오른쪽 자식 노드이고,” 부분만 바뀌게 되므로, 다음 다섯 번째 조건에서 해결할 수 있다.</p></li></ul><blockquote><p>왼쪽회전은 오른쪽 자식 노드를 그 노드의 부모 노드와 바꾸는 과정이다. 대략 아래와 같은 느낌</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = n.parent;</span><br><span class="line">c = n.right;</span><br><span class="line"><span class="keyword">if</span> (c.left) c.left.parent = p;</span><br><span class="line">n.right = c.left</span><br><span class="line">n.parent = c;</span><br><span class="line">c.left = n;</span><br><span class="line">c.parent = p;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p.left == p) p.left = c;</span><br><span class="line">  <span class="keyword">else</span> p.right = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>오른쪽 회전은 이와 반대 방향으로 돌리는 걸 의미한다.</p></blockquote><ul><li><p>부모 노드가 붉은 색이지만, 삼촌 노드가 검은색이고, 새로운 노드 N이 부모의 왼쪽(오른쪽) 자식 노드이고, 부모 할아버지 노드의 왼쪽(오른쪽) 자식인 경우<br>위의 케이스에서 한 번 왼쪽 회전을 통해 이 케이스로 왔든, 처음부터 부모 노드의 왼쪽으로 들어왔든 이 케이스로 들어오게 된다. 이 경우에는 할아버지 노드 G에 대해서 오른쪽 회전을 진행한다. 이 결과로 이전 부모 노드인 P는 새로운 노드 N과 할아버지 노드 G를 자식으로 갖게 된다. P는 붉은색, G는 검은색일 수 밖에 없으므로 P와 G의 색을 바꾸면, RBT의 네 번째 속성을 만족하게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertCase5</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = getGrandparent(node);</span><br><span class="line">    node.parent.color = BLACK;</span><br><span class="line">    g.color = RED;</span><br><span class="line">    <span class="keyword">if</span> (node === node.parent.left) rotateRight(g);</span><br><span class="line">    <span class="keyword">else</span> rotateLeft(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><br/><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png?style=centerme"/></br><h3 id="삭제"><a href="#삭제" class="headerlink" title="삭제"></a>삭제</h3><p>아주 복잡한 삽입 과정이 끝났다. 이제 삭제 작업을 보자. 삭제 방식 역시 BST의 삭제 방법을 기본적으로 따른 후, 색을 맞춘다. BST에서 노드 N을 삭제할 때, N의 자식이 둘이라면, 왼쪽 자손 중 최대 또는 오른쪽 자손 중 최소 노드를 N 위치로 옮긴다. 이때 문제가 되는 것은, 옮긴 주변의 레드 블랙 특성을 위반하는지이다. 옮긴 노드는 해당 트리에서 최소 또는 최대라는 특성때문에 최대 1개의 자손만을 가질 수 있다. 결국, 삭제 작업은 최대 1개의 자식만 가진 노드를 삭제하는 것과 마찬가지이다. 따라서, 자식이 1개 이하인 상황을 가정하고 삭제를 설명한다.</p><p>삭제할 노드는 M, M의 자식을 C라고 하자. 우선 간단한 상황을 먼저 해결하자. 삭제 대상이 붉은 색이라면, 그냥 M을 삭제한 뒤, C를 M대신 치환하면 된다. 또, M이 검은 노드, C가 붉은 노드라고 가정하자, 검은 노드를 삭제하면 경로의 검은 노드의 수가 같아야 하고, 또는 붉은 노드의 부모는 검은 노드여야 한다는 원칙을 위반할 가능성이 있다. 하지만, C를 검은색으로 바꿔주면 모두 해결 가능하다.</p><hr><p>어려운 상황은 M, C가 모두 검은 노드일 때 발생한다. 일단 M을 자식 노드 C로 치환한다. 이 상황에서 C를 N으로 명명하고, N의 형제 노드를 S, 부모 노드를 P라고 명명한다.</p><ul><li><p>N이 새로운 루트가 될 때<br>이전 삭제한 노드가 루트였음을 의미하고, 이는 모든 경로에서 검은색을 하나 줄인 것이다. 이전 특성이 모두 유지되므로 상황은 종료</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCase1</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.parent) <span class="keyword">return</span>;</span><br><span class="line">  deleteCase2(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>S가 붉은 노드인 경우, N이 P의 왼쪽(오른쪽) 자식인 경우<br>현재 상황에서 부모 노드 P가 검은 노드임이 확실한 상황이다. (삼촌 노드가 붉은 색이기 때문에) 이 경우, P와 S의 색을 바꾸고, P에서 왼쪽(오른쪽) 회전하면, S가 N의 할아버지 노드가 된다. 이제 N이 검은색 형제 노드와 붉은 부모 노드를 가지고 있게 된다. 이 상황을 만든 후 다음 케이스에서 나머지 문제(모든 경로에서 검은 노드의 수가 같지 않다.)를 해결하도록 한다. 이후 상황에 대해서 S는 할아버지 노드가 된 기존 S가 아니라, 새롭게 바뀐 N의 형제 노드를 의미한다.</p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Red-black_tree_delete_case_3_as_svg.svg/337px-Red-black_tree_delete_case_3_as_svg.svg.png?style=centerme"/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCase2</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = getSibling(node);</span><br><span class="line">  <span class="keyword">if</span> (s.color == RED) &#123;</span><br><span class="line">    node.parent.color = RED;</span><br><span class="line">    s.color = BLACK;</span><br><span class="line">    <span class="keyword">if</span> (n === n.parent.left) rotateLeft(node.parent);</span><br><span class="line">    <span class="keyword">else</span> rotateRight(node.parent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteCase3(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>P, S, 그리고 S의 자식들이 검은색인 경우<br>S를 붉은 노드로 만들면 된다. S를 지나는 모든 경로에서 검은 노드 수를 하나 줄여, N을 지나는 경로의 검은 노드 수와 맞출 수 있다. 그러나, P 이하의 트리에서 검은 노드의 수가 1개 줄은 것이기 때문에, P를 지나지 않던 경로가 있다면, P를 지나는 경로보다 검은 노드 수가 한 개 더 많게 된다. 따라서, P에 <code>deleteCase1</code>을 재귀적으로 적용할 필요가 있다.</p><br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Red-black_tree_delete_case_3_as_svg.svg/337px-Red-black_tree_delete_case_3_as_svg.svg.png?style=centerme" /><br/><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCase3</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = getSibling(node);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">      node.parent.color === BLACK &amp;&amp; </span><br><span class="line">      s.color === BLACK &amp;&amp;</span><br><span class="line">      s.left.color === BLACK &amp;&amp;</span><br><span class="line">      s.right.color === BLACK) &#123;</span><br><span class="line">       s.color = RED;</span><br><span class="line">       deleteCase1(node.parent);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    deleteCase4(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>S와 S의 자식들은 검은색이지만, P는 붉은색인 경우<br>S와 P의 색을 바꿔주면 된다. 이는 S를 지나는 경로의 검은 노드 개수에 영향을 주지는 않지만, N을 지나는 경로에 대해서는 검은 노드의 개수를 1개 증가시킨다. 이를 통해 삭제된 원래 검은 노드의 개수를 보충한다.</p></li></ul><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Red-black_tree_delete_case_4_as_svg.svg/337px-Red-black_tree_delete_case_4_as_svg.svg.png?centerme"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCase4</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = getSibling(node);</span><br><span class="line">  <span class="keyword">if</span> (node.parent.color === RED &amp;&amp; s.color === BLACK &amp;&amp; s.left.color === BLACK &amp;&amp; s.right.color === BLACK) &#123;</span><br><span class="line">    s.color = RED;</span><br><span class="line">    n.parent.color = BLACK;</span><br><span class="line">  &#125; <span class="keyword">else</span> deleteCase5(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>S가 검정, S의 왼쪽(오른쪽) 자식이 빨강, 오른쪽(왼쪽) 자식이 검정이고, N이 부모의 왼쪽(오른쪽) 자식인 경우<br>S를 오른쪽(왼쪽) 회전시켜 S의 왼쪽 자식이 S의 부모 노드이자, 새로운 S(N의 형제)가 되도록 한다. 그리고 S의 색을 부모 노드와 바꿔준다. 이 상태를 만들고 나서, <code>deleteCase6</code>으로 넘겨준다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/Red-black_tree_delete_case_5_as_svg.svg/243px-Red-black_tree_delete_case_5_as_svg.svg.png?style=centerme"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCase5</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = getSibling(node);</span><br><span class="line">  <span class="keyword">if</span> (s.color === BLACK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === n.parent.left &amp;&amp; s.right.color === BLACK &amp;&amp; s.left.color === RED) &#123;</span><br><span class="line">      s.color = RED;</span><br><span class="line">      s.left.color = BLACK;</span><br><span class="line">      rotateRight(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n === n.parent.right &amp;&amp; s.left.color === BLACK &amp;&amp; s.right.color == RED) &#123;</span><br><span class="line">      s.color = RED;</span><br><span class="line">      s.right.color = BLACK;</span><br><span class="line">      rotateLeft(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">deleteCase6(node);</span><br></pre></td></tr></table></figure></li><li><p>S가 검은색, S의 오른쪽(왼쪽) 자식이 빨강, N이 P의 왼쪽(오른쪽) 자식인 경우<br>P를 왼쪽(오른쪽)으로 회전해서 S가 P와 S의 오른쪽(왼쪽) 자식 노드의 부모 노드가 되도록 한다. 그리고, P와 S의 색을 바꾸고, S의 오른쪽(왼쪽) 자식노드를 검은색으로 만든다. </p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Red-black_tree_delete_case_6_as_svg.svg/337px-Red-black_tree_delete_case_6_as_svg.svg.png?style=centerme"></p><p>이렇게 만들어진 트리에서 N은 하나의 검은 조상 노드를 더 갖게 되었고, 따라서 N을 지나는 경로는 검은색을 하나 더 갖게 된다. 반면, N을 통과하는 케이스는 두 가지 경우의 수를 갖는다.</p><ol><li>N의 새로운 형제 노드를 지나는 경우: 변경되기 전과 같은 순서를 만난다. <code>P -&gt; S -&gt; ...</code> 이던게, <code>S -&gt; P -&gt; ...</code> 로 바뀐 것 뿐</li><li>N의 새로운 삼촌 노드를 지나는 경우: 변형 되기 전에 <code>P -&gt; S -&gt; S 오른쪽 자식 -&gt; ...</code> 경로를 가지던 것이, 변형 후, <code>S -&gt; S 오른쪽 자식 -&gt; ...</code>로 바뀌게 되었다. 하지만 붉은 노드가 하나 줄었기 때문에 경로 상에서는 같은 검은 노드를 만나게 된다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteCase6</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = getSibling(node);</span><br><span class="line">  s.color = node.parent.color;</span><br><span class="line">  node.parent.color = BLACK;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">    s.right.color = BLACK;</span><br><span class="line">    rotateRight(node.parent);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s.left.color = BLACK;</span><br><span class="line">    rotateRight(node.parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC">https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC</a></li><li><a href="https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98">https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98</a></li><li><a href="https://coding-factory.tistory.com/557">https://coding-factory.tistory.com/557</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/algorithm/">algorithm</category>
      
      
      <category domain="https://changhoi.github.io/tags/data-structure/">data_structure</category>
      
      
      <comments>https://changhoi.github.io/posts/algorithm/red-black-tree/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>이벤트 기반 마이크로서비스 구축 간단 리뷰</title>
      <link>https://changhoi.github.io/posts/books/building-event-driven-microservices/</link>
      <guid>https://changhoi.github.io/posts/books/building-event-driven-microservices/</guid>
      <pubDate>Sat, 22 May 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;이번년도에도 한빛 미디어의 &lt;strong&gt;나는 리뷰어다&lt;/strong&gt;에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 5월 미션으로 나온 책 중에 하나인 &lt;strong&gt;이벤트 기반 마이크로서비스 구축&lt;/strong&gt;을 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번년도에도 한빛 미디어의 <strong>나는 리뷰어다</strong>에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 5월 미션으로 나온 책 중에 하나인 <strong>이벤트 기반 마이크로서비스 구축</strong>을 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.</p><span id="more"></span><p>최근 마이크로 서비스와, 이벤트 기반 아키텍처에 대한 관심과, 그를 뒷받침 해주는 기술들의 큰 발전이 있었다고 생각한다. 그에 따라 많은 자료, 방법, 아키텍처 등이 등장했는데, 이 책은 그러한 여러 패턴 및 자료를 집대성해둔 책이라는 생각이 들었다. 본인은 이벤트 기반 서비스를 개발해보거나, 잘 알지 못헤서, 읽는데 굉장히 어려움이 많았다. 그러나 책 자체가 이벤트 기반 마이크로서비스를 잘 모르더라도 어느 정도 이해할 수 있도록 기본 개념도 함께 설명해준다. 다만, 책 안에는 특별한 예시 상황에 대해서는 다루지 않는다. 그러나 만들 수 있는 패턴, FaaS에 대해서도 소개하고 알려주며, 어떤 상황에서 사용해야 하는지에 대해서도 챕터로 나누어 다루고 있다. 책을 읽으면서 페이지를 넘기기 어려웠던 건 사실이지만, 꼭 몇 번을 읽어서 숙지하고 싶은 책이다. </p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/books/">books</category>
      
      
      <category domain="https://changhoi.github.io/tags/review/">review</category>
      
      
      <comments>https://changhoi.github.io/posts/books/building-event-driven-microservices/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MongoDB 모델링</title>
      <link>https://changhoi.github.io/posts/backend/mongodb-modeling/</link>
      <guid>https://changhoi.github.io/posts/backend/mongodb-modeling/</guid>
      <pubDate>Fri, 07 May 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;최근에 시험도 준비하고, 일도 바빠서 쉽게 글을 남기기 힘들었는데, 쓸 내용들은 차곡차곡 쌓아두긴 했었다. 우선 정리와 복습도 할 겸, 최근 서비스에서 사용하고 있는 MongoDB 모델링 하는 걸 공부한 내용을 정리했다. 이 내용은 공식 문서를 보고 번역하고 재배열한 내용이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>최근에 시험도 준비하고, 일도 바빠서 쉽게 글을 남기기 힘들었는데, 쓸 내용들은 차곡차곡 쌓아두긴 했었다. 우선 정리와 복습도 할 겸, 최근 서비스에서 사용하고 있는 MongoDB 모델링 하는 걸 공부한 내용을 정리했다. 이 내용은 공식 문서를 보고 번역하고 재배열한 내용이다.</p><span id="more"></span><h1 id="Flexible-Schema"><a href="#Flexible-Schema" class="headerlink" title="Flexible Schema"></a>Flexible Schema</h1><p>MongoDB는 어떤 데이터를 집어 넣을지 미리 결정되어 있는 “테이블”과 다르게, 스키마에 대해 자유로운 <code>document</code>(다큐멘트)가 모이는, <code>collection</code>(콜렉션)으로 구성된다.</p><ul><li>하나의 콜랙션에 있는 다큐멘트들은 같은 필드나, 같은 데이터 타입을 가질 필요가 없다.</li><li>필드를 더하거나, 필드의 데이터 타입을 바꾸는 등, 다큐멘트의 구조를 바꾸려면, 그 특정 다큐멘트의 구조를 바꿔주면 된다.</li></ul><blockquote><p>실제로는 <a href="https://docs.mongodb.com/manual/core/schema-validation/"><code>document</code> rules</a>를 강제해 하나의 콜렉션이 유사한 구조를 공유하도록 강제한다.</p></blockquote><h1 id="Document-Structure"><a href="#Document-Structure" class="headerlink" title="Document Structure"></a>Document Structure</h1><p>“MongoDB란 무엇일까?”에 대한 내용을 다루는 글이 아니므로, 스키마의 특징, 데이터 타입 등은 건너 뛰고, 다큐멘트 구조에 대해서 한 번 살펴보자. MongoDB 앱의 데이터 모델을 설계할 때 중요한 사항은 다큐멘트의 구조와 애플리케이션이 데이터 관계를 어떻게 나타내는지이다. MongoDB는 관련 데이터를 하나의 다큐멘트 안에 포함하도록 한다. 두 가지 방법으로 관계에 대한 표현을 할 수 있는데, 하나의 다큐멘트 안에 포함시키는 <code>Embedded</code> 방식, 참조하도록 하는 <code>Reference</code> 방식이다.</p><h2 id="Embedded-Data"><a href="#Embedded-Data" class="headerlink" title="Embedded Data"></a>Embedded Data</h2><p><code>Embedded Data</code> 모델에서는 유관한 데이터를 하나의 다큐멘트에 담는다. 이러한 스키마는 일반적으로 “비정규화” 모델로 알려져있다.</p><p><img src="https://docs.mongodb.com/manual/_images/data-model-denormalized.bakedsvg.svg"></p><p>임베디드된 데이터 모델들은 애플리케이션이 유관한 정보 조각들을 하나의 데이터베이스 레코드에 저장할 수 있게 한다. 결과적으로 애플리케이션은 더 적은 쿼리와 업데이트를 가지고 필요한 작업을 수행할 수 있게 된다.</p><h3 id="엔티티-사이에-포함-관계가-있는-경우-1-1-관계"><a href="#엔티티-사이에-포함-관계가-있는-경우-1-1-관계" class="headerlink" title="엔티티 사이에 포함 관계가 있는 경우 (1:1 관계)"></a>엔티티 사이에 포함 관계가 있는 경우 (1:1 관계)</h3><ol><li><p><strong>Embedded Document Pattern</strong><br>“고객”과 주소 관계를 이어주는 예시를 생각해보자. <code>address</code>는 <code>patron</code>에게 종속되는 관계이다. 정규화 되어있다면, 아래와 같은 모습을 보인다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// patron document</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Joe Bookreader&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// address document</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="attr">patron_id</span>: <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">     <span class="attr">street</span>: <span class="string">&quot;123 Fake Street&quot;</span>,</span><br><span class="line">     <span class="attr">city</span>: <span class="string">&quot;Faketon&quot;</span>,</span><br><span class="line">     <span class="attr">state</span>: <span class="string">&quot;MA&quot;</span>,</span><br><span class="line">     <span class="attr">zip</span>: <span class="string">&quot;12345&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 이 경우, 만약 <code>address</code>의 데이터가 자주 이름 정보와 함께 검색되는 편이라면, 레퍼런스를 참조하기 위해 여러 쿼리를 실행하게 된다. 해결 방안은 <code>address</code> 데이터를 <code>patron</code> 데이터에 임베드 하는 것이다. 임베디드 데이터 모델은 애플리케이션에서 완전한 <code>patron</code> 정보를 가져오기 위해 한 번의 쿼리만 사용할 수 있다.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Joe Bookreader&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">street</span>: <span class="string">&quot;123 Fake Street&quot;</span>,</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;Faketon&quot;</span>,</span><br><span class="line">        <span class="attr">state</span>: <span class="string">&quot;MA&quot;</span>,</span><br><span class="line">        <span class="attr">zip</span>: <span class="string">&quot;12345&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Subset Pattern</strong><br> Embedded Document Pattern은 애플리케이션이 사용할 때 별로 필요 없는 정보를 포함한 큰 다큐멘트를 만들 수 있다는 문제가 있다. 이런 불필요한 데이터는 추가적인 로드를 야기하고, 당연히 읽기 퍼포먼스를 떨어뜨릴 수 있다. 대신, 자주 접근하는 정보를 모아 Subset 패턴틀 사용할 수 있다. 영화 정보를 보여주는 애플리케이션을 생각해보자. 데이터베이스는 아래와 같은 <code>movie</code> 스키마를 가지고 있다.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;The Arrival of a Train&quot;</span>,</span><br><span class="line">    <span class="attr">year</span>: <span class="number">1896</span>,</span><br><span class="line">    <span class="attr">runtime</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">released</span>: ISODate(<span class="string">&quot;01-25-1896&quot;</span>),</span><br><span class="line">    <span class="attr">poster</span>: <span class="string">&quot;http://ia.media-imdb.com/images/M/MV5BMjEyNDk5MDYzOV5BMl5BanBnXkFtZTgwNjIxMTEwMzE@._V1_SX300.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">plot</span>: <span class="string">&quot;A group of people are standing in a straight line along the platform of a railway station, waiting for a train, which is seen coming at some distance. When the train stops at the platform, ...&quot;</span>,</span><br><span class="line">    <span class="attr">fullplot</span>: <span class="string">&quot;A group of people are standing in a straight line along the platform of a railway station, waiting for a train, which is seen coming at some distance. When the train stops at the platform, the line dissolves. The doors of the railway-cars open, and people on the platform help passengers to get off.&quot;</span>,</span><br><span class="line">    <span class="attr">lastupdated</span>: ISODate(<span class="string">&quot;2015-08-15T10:06:53&quot;</span>),</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;movie&quot;</span>,</span><br><span class="line">    <span class="attr">directors</span>: [ <span class="string">&quot;Auguste Lumière&quot;</span>, <span class="string">&quot;Louis Lumière&quot;</span> ],</span><br><span class="line">    <span class="attr">imdb</span>: &#123;</span><br><span class="line">        <span class="attr">rating</span>: <span class="number">7.3</span>,</span><br><span class="line">        <span class="attr">votes</span>: <span class="number">5043</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">countries</span>: [ <span class="string">&quot;France&quot;</span> ],</span><br><span class="line">    <span class="attr">genres</span>: [ <span class="string">&quot;Documentary&quot;</span>, <span class="string">&quot;Short&quot;</span> ],</span><br><span class="line">    <span class="attr">tomatoes</span>: &#123;</span><br><span class="line">        <span class="attr">viewer</span>: &#123;</span><br><span class="line">            <span class="attr">rating</span>: <span class="number">3.7</span>,</span><br><span class="line">            <span class="attr">numReviews</span>: <span class="number">59</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lastUpdated</span>: ISODate(<span class="string">&quot;2020-01-09T00:02:53&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> movie 콜렉션은 애플리케이션이 간단한 영화의 Overview를 보여줄 때 사용하지 않는 정보들을 가지고 있다. 예를 들어서, <code>fullPlot</code>, <code>rating</code> 관련된 정보들이 그렇다고 가정하자. 이 경우, 모든 영화 데이터를 하나의 콜렉션에 저장하기 보다는 두 콜렉션으로 나눌 수 있다.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 영화 기본 정보를 담고 있는 movie 콜렉션. 애플리케이션이 기본적으로 불러오게 되는 데이터</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;The Arrival of a Train&quot;</span>,</span><br><span class="line">    <span class="attr">year</span>: <span class="number">1896</span>,</span><br><span class="line">    <span class="attr">runtime</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">released</span>: ISODate(<span class="string">&quot;1896-01-25&quot;</span>),</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;movie&quot;</span>,</span><br><span class="line">    <span class="attr">directors</span>: [ <span class="string">&quot;Auguste Lumière&quot;</span>, <span class="string">&quot;Louis Lumière&quot;</span> ],</span><br><span class="line">    <span class="attr">countries</span>: [ <span class="string">&quot;France&quot;</span> ],</span><br><span class="line">    <span class="attr">genres</span>: [ <span class="string">&quot;Documentary&quot;</span>, <span class="string">&quot;Short&quot;</span> ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// movie_detail 콜렉션은 부가적이고, 덜 접근이 되는 정보를 담는다.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">156</span>,</span><br><span class="line">    <span class="attr">movie_id</span>: <span class="number">1</span>, <span class="comment">// reference to the movie collection</span></span><br><span class="line">    <span class="attr">poster</span>: <span class="string">&quot;http://ia.media-imdb.com/images/M/MV5BMjEyNDk5MDYzOV5BMl5BanBnXkFtZTgwNjIxMTEwMzE@._V1_SX300.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">plot</span>: <span class="string">&quot;A group of people are standing in a straight line along the platform of a railway station, waiting for a train, which is seen coming at some distance. When the train stops at the platform, ...&quot;</span>,</span><br><span class="line">    <span class="attr">fullplot</span>: <span class="string">&quot;A group of people are standing in a straight line along the platform of a railway station, waiting for a train, which is seen coming at some distance. When the train stops at the platform, the line dissolves. The doors of the railway-cars open, and people on the platform help passengers to get off.&quot;</span>,</span><br><span class="line">    <span class="attr">lastupdated</span>: ISODate(<span class="string">&quot;2015-08-15T10:06:53&quot;</span>),</span><br><span class="line">    <span class="attr">imdb</span>: &#123;</span><br><span class="line">      <span class="attr">rating</span>: <span class="number">7.3</span>,</span><br><span class="line">      <span class="attr">votes</span>: <span class="number">5043</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">tomatoes</span>: &#123;</span><br><span class="line">        <span class="attr">viewer</span>: &#123;</span><br><span class="line">            <span class="attr">rating</span>: <span class="number">3.7</span>,</span><br><span class="line">            <span class="attr">numReviews</span>: <span class="number">59</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lastUpdated</span>: ISODate(<span class="string">&quot;2020-01-29T00:02:53&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 이 방법은 더 적은 데이터를 일반적인 요청 상황에서 불러오기 때문에, 읽기 퍼포먼스를 향상시킨다. 애플리케이션에서 필요하다면, <code>movie collection</code>의 데이터를 불러올 수 있게 구성한다.</p><blockquote><p>이 방식에서는 <strong>Trade-off</strong>가 존재한다. 자주 접근되는 데이터를 담은 더 작은 다큐멘트들은 Working set의 전체적인 크기를 줄여주고, 읽기 퍼포먼스 향상, 그리고 애플리케이션 메모리를 절약해준다. 하지만, 애플리케이션이 데이터를 읽어오는 방식에 대한 이해도가 필요하다. 만약 데이터를 여러 콜렉션으로 부적절하게 나눈다면, 애플리케이션은 필요한 데이터를 가져오기 위해 <code>JOIN</code>을 수행하게 될 수 있다. 게다가, 데이터를 많은 조각으로 나누면, 어떤 데이터가 어떤 콜렉션에 저장되어 있는지 추적하기 어려워지기 때문에 필요한 데이터베이스 유지보수가 증가할 수 있다.</p></blockquote></li></ol><h3 id="엔티티-사이에-1-N-관계가-있고-N이-1-부분에-항상-보여야-할-때"><a href="#엔티티-사이에-1-N-관계가-있고-N이-1-부분에-항상-보여야-할-때" class="headerlink" title="엔티티 사이에 1:N 관계가 있고, N이 1 부분에 항상 보여야 할 때"></a>엔티티 사이에 1:N 관계가 있고, N이 1 부분에 항상 보여야 할 때</h3><p>이 경우에도 위와 같이, <code>Embedded Document Pattern</code>과, <code>Subset Pattern</code>이 있다. 구현 방식 역시 유사하다.</p><ol><li><p><strong>Embedded Document Pattern</strong><br>아래 예시에서는 고객과 여러 주소 관계를 표현하고 있다. 많은 데이터 엔티티들을 다른 하나의 컨텍스트 안에서 봐야 할 때, 임베딩 하는 것이 레퍼런스 하는 경우보다 나은 경우를 설명한다 (안 그런 경우도 있다). <code>patron</code>과 <code>address</code> 사이의 1:N 관계에서, <code>patron</code>은 복수의 <code>address</code>를 가지고 있다. 정규화 되어있는 경우, <code>address</code> 다큐멘트는 <code>patron</code> 다큐멘트를 참조하고 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정규화 된 데이터</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Joe Bookreader&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// address documents</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">patron_id</span>: <span class="string">&quot;joe&quot;</span>, <span class="comment">// reference to patron document</span></span><br><span class="line">    <span class="attr">street</span>: <span class="string">&quot;123 Fake Street&quot;</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&quot;Faketon&quot;</span>,</span><br><span class="line">    <span class="attr">state</span>: <span class="string">&quot;MA&quot;</span>,</span><br><span class="line">    <span class="attr">zip</span>: <span class="string">&quot;12345&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line">     <span class="attr">patron_id</span>: <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">     <span class="attr">street</span>: <span class="string">&quot;1 Some Other Street&quot;</span>,</span><br><span class="line">     <span class="attr">city</span>: <span class="string">&quot;Boston&quot;</span>,</span><br><span class="line">     <span class="attr">state</span>: <span class="string">&quot;MA&quot;</span>,</span><br><span class="line">     <span class="attr">zip</span>: <span class="string">&quot;12345&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>만약 애플리케이션이 address 데이터를 이름 정보와 함께 조회하는 경우가 많다면, 참조된 데이터를 가져오기 위해 여러번의 쿼리를 수행해야 한다. 더 최적화된 스키마는 address 데이터를 patron에 임베드 시키는 것이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Joe Bookreader&quot;</span>,</span><br><span class="line">    <span class="attr">addresses</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="attr">street</span>: <span class="string">&quot;123 Fake Street&quot;</span>,</span><br><span class="line">             <span class="attr">city</span>: <span class="string">&quot;Faketon&quot;</span>,</span><br><span class="line">             <span class="attr">state</span>: <span class="string">&quot;MA&quot;</span>,</span><br><span class="line">             <span class="attr">zip</span>: <span class="string">&quot;12345&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="attr">street</span>: <span class="string">&quot;1 Some Other Street&quot;</span>,</span><br><span class="line">             <span class="attr">city</span>: <span class="string">&quot;Boston&quot;</span>,</span><br><span class="line">             <span class="attr">state</span>: <span class="string">&quot;MA&quot;</span>,</span><br><span class="line">             <span class="attr">zip</span>: <span class="string">&quot;12345&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Subset Pattern</strong><br>Embbed Document Pattern의 문제는 거대한 다큐멘트를 만들 수 있다는 점이다. 이런 경우, Subset Pattern을 사용해서 오직 애플리케이션이 요구하는 데이터에만 접근하도록 수 있다. 프로덕트에 리뷰를 달 수 있는 커머스 사이트를 예로 들어보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">_id</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Super Widget&quot;</span>,</span><br><span class="line">   <span class="attr">description</span>: <span class="string">&quot;This is the most useful item in your toolbox.&quot;</span>,</span><br><span class="line">   <span class="attr">price</span>: &#123; <span class="attr">value</span>: NumberDecimal(<span class="string">&quot;119.99&quot;</span>), <span class="attr">currency</span>: <span class="string">&quot;USD&quot;</span> &#125;,</span><br><span class="line">   <span class="attr">reviews</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">review_id</span>: <span class="number">786</span>,</span><br><span class="line">            <span class="attr">review_author</span>: <span class="string">&quot;Kristina&quot;</span>,</span><br><span class="line">            <span class="attr">review_text</span>: <span class="string">&quot;This is indeed an amazing widget.&quot;</span>,</span><br><span class="line">            <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2019-02-18&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">review_id</span>: <span class="number">785</span>,</span><br><span class="line">            <span class="attr">review_author</span>: <span class="string">&quot;Trina&quot;</span>,</span><br><span class="line">            <span class="attr">review_text</span>: <span class="string">&quot;Nice product. Slow shipping.&quot;</span>,</span><br><span class="line">            <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2019-02-17&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">review_id</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">review_author</span>: <span class="string">&quot;Hans&quot;</span>,</span><br><span class="line">            <span class="attr">review_text</span>: <span class="string">&quot;Meh, it&#x27;s okay.&quot;</span>,</span><br><span class="line">            <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2017-12-06&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리뷰는 최신순으로 정렬되어있다. 프로덕트 페이지에 들어가면, 애플리케이션은 10개의 가장 최근 리뷰를 보여준다. 이 경우 모든 리뷰를 하나의 콜렉션에 담을 필요는 없다. 그 대신, 콜렉션을 두 개로 나눌 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10개의 최신 리뷰와 함게, 각 프로덕트 정보를 저장하느 product 콜렉션</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Super Widget&quot;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&quot;This is the most useful item in your toolbox.&quot;</span>,</span><br><span class="line">    <span class="attr">price</span>: &#123; <span class="attr">value</span>: NumberDecimal(<span class="string">&quot;119.99&quot;</span>), <span class="attr">currency</span>: <span class="string">&quot;USD&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">reviews</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="attr">review_id</span>: <span class="number">786</span>,</span><br><span class="line">             <span class="attr">review_author</span>: <span class="string">&quot;Kristina&quot;</span>,</span><br><span class="line">             <span class="attr">review_text</span>: <span class="string">&quot;This is indeed an amazing widget.&quot;</span>,</span><br><span class="line">             <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2019-02-18&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="attr">review_id</span>: <span class="number">776</span>,</span><br><span class="line">             <span class="attr">review_author</span>: <span class="string">&quot;Pablo&quot;</span>,</span><br><span class="line">             <span class="attr">review_text</span>: <span class="string">&quot;Amazing!&quot;</span>,</span><br><span class="line">             <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2019-02-16&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 모든 리뷰들을 저장하는 review 콜렉션, 각 리뷰들은 product를 참조한다.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">review_id</span>: <span class="number">786</span>,</span><br><span class="line">    <span class="attr">product_id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">review_author</span>: <span class="string">&quot;Kristina&quot;</span>,</span><br><span class="line">    <span class="attr">review_text</span>: <span class="string">&quot;This is indeed an amazing widget.&quot;</span>,</span><br><span class="line">    <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2019-02-18&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">review_id</span>: <span class="number">785</span>,</span><br><span class="line">    <span class="attr">product_id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">review_author</span>: <span class="string">&quot;Trina&quot;</span>,</span><br><span class="line">    <span class="attr">review_text</span>: <span class="string">&quot;Nice product. Slow shipping.&quot;</span>,</span><br><span class="line">    <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2019-02-17&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">review_id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">product_id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">review_author</span>: <span class="string">&quot;Hans&quot;</span>,</span><br><span class="line">    <span class="attr">review_text</span>: <span class="string">&quot;Meh, it&#x27;s okay.&quot;</span>,</span><br><span class="line">    <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2017-12-06&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최근 10개의 리뷰만 product 콜랙션에 담아두는 것을 통해서, 필요한 부분만 production 콜랙션에 요청을 했을 때 받을 수 있다. 만약 유저가 추가적인 리뷰를 보고 싶어 하면, 애플리케이션은 review 콜랙션에서 이를 가져오면 된다.</p><blockquote><p>마찬가지로, 이 경우의 Subset Pattern에서도 Trade off가 존재한다. 더 자주 접근 되는 데이터만 담고 있는 작은 다큐멘트를 쓰는 것은 working set의 전체 사이즈를 줄여준다. 이러한 더 작은 다큐멘트들은 결과적으로 읽기 퍼포먼스를 향상시킨다. 하지만, Subset 패턴은 데이터 중복으로 이어진다. 예를 들어서, review는 product와 review 콜랙션 모두에게 있다. 추가적인 단계들이 각 콜랙션 사이에 동일성을 유지하기 위해 필요하다. 또한 애플리케이션에서 제한된 Subset 수를 유지하기 위한 추가적인 로직이 필요하다. (최근 리뷰가 들어오면, 마지막 리뷰를 빼주는 등)</p></blockquote></li></ol><hr><p>일반적으로 임베딩 하는 것이 읽기 작업에서 더 나은 퍼포먼스를 보여준다. 임베디드 데이터 모델은 연관된 데이터를 업데이트 하는 것을 하나의 쓰기 작업으로 가능하게 만든다.</p><h1 id="Normalized-Data-Model-Reference"><a href="#Normalized-Data-Model-Reference" class="headerlink" title="Normalized Data Model (Reference)"></a>Normalized Data Model (Reference)</h1><p>정규화된 데이터 모델은 관계를 <code>reference</code>를 통해 표현한다.</p><p><img src="https://docs.mongodb.com/manual/_images/data-model-normalized.bakedsvg.svg"></p><p>일반적으로, 정규화된 데이터 모델은 다음과 같은 상황에서 사용한다.</p><ul><li>1:N 관계에서 임베딩 하는 것이 데이터 중복을 일으키고, 충분한 읽기 퍼포먼스를 제공하지 못하는 경우</li><li>더 복잡한 N:M 관계를 표현해야 할 때</li><li>큰 계층적 데이터 셋을 표현해야 할 때</li></ul><p>문서에서는 N:M에 대한 부분을 직접 언급하는 페이지는 없었고, 1:N 관계와, 트리구조라는 형태로 분류되어있다.</p><h2 id="1-N-관계"><a href="#1-N-관계" class="headerlink" title="1:N 관계"></a>1:N 관계</h2><p><code>publisher</code>와 <code>book</code>의 관계를 연결하는 예시를 살펴보자. 아래 예시의 경우는 <code>publisher</code> 정보의 반복을 피하기 위해서는 임베딩 하는 것보다 참조를 사용하는 것이 더 좋다는 내용이다. 임베딩 된 경우를 확인해보면 아래와 같다. <code>publisher</code>에 대한 정보가 <code>book</code> 다큐멘트 안에서 중복되고 있다는 것을 알 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&quot;MongoDB: The Definitive Guide&quot;</span>,</span><br><span class="line">   <span class="attr">author</span>: [ <span class="string">&quot;Kristina Chodorow&quot;</span>, <span class="string">&quot;Mike Dirolf&quot;</span> ],</span><br><span class="line">   <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2010-09-24&quot;</span>),</span><br><span class="line">   <span class="attr">pages</span>: <span class="number">216</span>,</span><br><span class="line">   <span class="attr">language</span>: <span class="string">&quot;English&quot;</span>,</span><br><span class="line">   <span class="attr">publisher</span>: &#123; </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;O&#x27;Reilly Media&quot;</span>,</span><br><span class="line">  <span class="attr">founded</span>: <span class="number">1980</span>,</span><br><span class="line">  <span class="attr">location</span>: <span class="string">&quot;CA&quot;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&quot;50 Tips and Tricks for MongoDB Developer&quot;</span>,</span><br><span class="line">   <span class="attr">author</span>: <span class="string">&quot;Kristina Chodorow&quot;</span>,</span><br><span class="line">   <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2011-05-06&quot;</span>),</span><br><span class="line">   <span class="attr">pages</span>: <span class="number">68</span>,</span><br><span class="line">   <span class="attr">language</span>: <span class="string">&quot;English&quot;</span>, </span><br><span class="line">   <span class="attr">publisher</span>: &#123; </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;O&#x27;Reilly Media&quot;</span>,</span><br><span class="line">  <span class="attr">founded</span>: <span class="number">1980</span>, </span><br><span class="line">  <span class="attr">location</span>: <span class="string">&quot;CA&quot;</span> </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 중복을 피하기 위해서 <code>reference</code>를 사용한다. 참조를 사용할 때 관계들의 증가에 따라 참조를 저장할 위치를 결정한다. 위 예시 상황을 말 해보자면, <code>publisher</code> 당 <code>book</code>의 수가 조금만 증가 하는 경우, <code>book</code> 참조를 <code>publisher</code> 다큐멘트 안에 넣는것이 좋다. 그렇지 않다면, 즉, <code>publisher</code> 당 <code>book</code>의 수가 제한 없이 커진다면, 이 데이터 모델은 아래 예시처럼 변경 가능하고 증가 하는 배열 형태를 가져야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;O&#x27;Reilly Media&quot;</span>,</span><br><span class="line">   <span class="attr">founded</span>: <span class="number">1980</span>,</span><br><span class="line">   <span class="attr">location</span>: <span class="string">&quot;CA&quot;</span>,</span><br><span class="line">   <span class="attr">books</span>: [<span class="number">123456789</span>, <span class="number">234567890</span>, ...] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">123456789</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;MongoDB: The Definitive Guide&quot;</span>,</span><br><span class="line">    <span class="attr">author</span>: [ <span class="string">&quot;Kristina Chodorow&quot;</span>, <span class="string">&quot;Mike Dirolf&quot;</span> ],</span><br><span class="line">    <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2010-09-24&quot;</span>),</span><br><span class="line">    <span class="attr">pages</span>: <span class="number">216</span>,</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&quot;English&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">_id</span>: <span class="number">234567890</span>,</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&quot;50 Tips and Tricks for MongoDB Developer&quot;</span>,</span><br><span class="line">   <span class="attr">author</span>: <span class="string">&quot;Kristina Chodorow&quot;</span>,</span><br><span class="line">   <span class="attr">published_date</span>: ISODate(<span class="string">&quot;2011-05-06&quot;</span>),</span><br><span class="line">   <span class="attr">pages</span>: <span class="number">68</span>,</span><br><span class="line">   <span class="attr">language</span>: <span class="string">&quot;English&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="트리-구조"><a href="#트리-구조" class="headerlink" title="트리 구조"></a>트리 구조</h2><p><img src="https://docs.mongodb.com/manual/_images/data-model-tree.bakedsvg.svg"></p><h3 id="Parent-References"><a href="#Parent-References" class="headerlink" title="Parent References"></a>Parent References</h3><p><em>Parent References</em> 패턴은 각 트리 노드를 다큐멘트에 저장한다. 트리 노드 외에도 문서는 노드의 부모 ID를 저장한다.</p><p>위 이미지 형태의 구조를 아래와 같이 저장한다고 볼 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.categories.insertMany( [</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;MongoDB&quot;</span>, <span class="attr">parent</span>: <span class="string">&quot;Databases&quot;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;dbm&quot;</span>, <span class="attr">parent</span>: <span class="string">&quot;Databases&quot;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Databases&quot;</span>, <span class="attr">parent</span>: <span class="string">&quot;Programming&quot;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Languages&quot;</span>, <span class="attr">parent</span>: <span class="string">&quot;Programming&quot;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Programming&quot;</span>, <span class="attr">parent</span>: <span class="string">&quot;Books&quot;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Books&quot;</span>, <span class="attr">parent</span>: <span class="literal">null</span> &#125;</span><br><span class="line">] )</span><br></pre></td></tr></table></figure><p>노드의 부모를 검색할 때는 다음과 같이 검색할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.categories.findOne( &#123; <span class="attr">_id</span>: <span class="string">&quot;MongoDB&quot;</span> &#125; ).parent</span><br></pre></td></tr></table></figure><p>부모 필드를 통해 children을 검색할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.categories.find( &#123; <span class="attr">parent</span>: <span class="string">&quot;Databases&quot;</span> &#125; )</span><br></pre></td></tr></table></figure><h3 id="Child-References"><a href="#Child-References" class="headerlink" title="Child References"></a>Child References</h3><p><em>Child References</em> 패턴은 각 트리 노드를 하나의 다큐멘트에 저장한다. 트리 노드 데이터에 자식 노드들의 id 배열을 저장한다.</p><p>즉 아래와 같이 위 이미지 형태의 트리 구조를 저장한다는 뜻이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.categories.insertMany( [</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;MongoDB&quot;</span>, <span class="attr">children</span>: [] &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;dbm&quot;</span>, <span class="attr">children</span>: [] &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Databases&quot;</span>, <span class="attr">children</span>: [ <span class="string">&quot;MongoDB&quot;</span>, <span class="string">&quot;dbm&quot;</span> ] &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Languages&quot;</span>, <span class="attr">children</span>: [] &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Programming&quot;</span>, <span class="attr">children</span>: [ <span class="string">&quot;Databases&quot;</span>, <span class="string">&quot;Languages&quot;</span> ] &#125;,</span><br><span class="line">   &#123; <span class="attr">_id</span>: <span class="string">&quot;Books&quot;</span>, <span class="attr">children</span>: [ <span class="string">&quot;Programming&quot;</span> ] &#125;</span><br><span class="line">] )</span><br></pre></td></tr></table></figure><p>자식 노드들을 찾을 때는 아래와 같이 쿼리를 하게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.categories.findOne( &#123; <span class="attr">_id</span>: <span class="string">&quot;Databases&quot;</span> &#125; ).children</span><br></pre></td></tr></table></figure><p>특정 자식 노드 값을 가지고 있는 부모 값을 찾기 위해서는 다음과 같은 쿼리를 사용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.categories.find( &#123; <span class="attr">children</span>: <span class="string">&quot;MongoDB&quot;</span> &#125; )</span><br></pre></td></tr></table></figure><p><em>Children References</em> 패턴은 하위 트리에 대한 작업이 필요하지 않다면 적합한 방법이다. 이 패턴은 노드가 여러 개의 부모를 가질 수 잇는 경우에도 적합한 방법이 될 수 있다.</p><h3 id="Array-of-Ancestors"><a href="#Array-of-Ancestors" class="headerlink" title="Array of Ancestors"></a>Array of Ancestors</h3><p><em>Array of Ancestors</em> 패턴은 각 트리 노드를 하나의 다큐멘트에 담는 방법이다. 트리 노드 데이터에, 노드의 조상들 또는 경로의 id 배열을 저장하는 방법이다.</p><p>위 이미지 형태를 아래와 같이 저장하는 방법이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.categories.insertMany( [</span><br><span class="line">  &#123; <span class="attr">_id</span>: <span class="string">&quot;MongoDB&quot;</span>, <span class="attr">ancestors</span>: [ <span class="string">&quot;Books&quot;</span>, <span class="string">&quot;Programming&quot;</span>, <span class="string">&quot;Databases&quot;</span> ], <span class="attr">parent</span>: <span class="string">&quot;Databases&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">_id</span>: <span class="string">&quot;dbm&quot;</span>, <span class="attr">ancestors</span>: [ <span class="string">&quot;Books&quot;</span>, <span class="string">&quot;Programming&quot;</span>, <span class="string">&quot;Databases&quot;</span> ], <span class="attr">parent</span>: <span class="string">&quot;Databases&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">_id</span>: <span class="string">&quot;Databases&quot;</span>, <span class="attr">ancestors</span>: [ <span class="string">&quot;Books&quot;</span>, <span class="string">&quot;Programming&quot;</span> ], <span class="attr">parent</span>: <span class="string">&quot;Programming&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">_id</span>: <span class="string">&quot;Languages&quot;</span>, <span class="attr">ancestors</span>: [ <span class="string">&quot;Books&quot;</span>, <span class="string">&quot;Programming&quot;</span> ], <span class="attr">parent</span>: <span class="string">&quot;Programming&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">_id</span>: <span class="string">&quot;Programming&quot;</span>, <span class="attr">ancestors</span>: [ <span class="string">&quot;Books&quot;</span> ], <span class="attr">parent</span>: <span class="string">&quot;Books&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">_id</span>: <span class="string">&quot;Books&quot;</span>, <span class="attr">ancestors</span>: [ ], <span class="attr">parent</span>: <span class="literal">null</span> &#125;</span><br><span class="line">] )</span><br></pre></td></tr></table></figure><p>조상들 또는 경로를 찾기 위해 다음과 같이 쿼리를 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.categories.findOne( &#123; <span class="attr">_id</span>: <span class="string">&quot;MongoDB&quot;</span> &#125; ).ancestors</span><br></pre></td></tr></table></figure><p>자손들을 모두 찾기 위해서 다음과 같이 쿼리를 사용할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.categories.find( &#123; <span class="attr">ancestors</span>: <span class="string">&quot;Programming&quot;</span> &#125; )</span><br></pre></td></tr></table></figure><p><em>Array of Ancestors</em> 패턴은 빠르고 효율적으로 자손과 조상들을 찾을 수 있게 해준다.</p><p><em>Array of Ancestors</em> 패턴은 <a href="https://docs.mongodb.com/manual/tutorial/model-tree-structures-with-materialized-paths/">Materialized Paths</a> 패턴보다는 약간 느리지만, 좀 더 직관적으로 사용할 수 있다.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://docs.mongodb.com/manual/core/data-modeling-introduction/">https://docs.mongodb.com/manual/core/data-modeling-introduction/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/backend/">backend</category>
      
      
      <category domain="https://changhoi.github.io/tags/database/">database</category>
      
      <category domain="https://changhoi.github.io/tags/architecture/">architecture</category>
      
      <category domain="https://changhoi.github.io/tags/mongodb/">mongodb</category>
      
      
      <comments>https://changhoi.github.io/posts/backend/mongodb-modeling/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4개월 간 서비스 개발 후기 (사업화 실패하는 데 성공)</title>
      <link>https://changhoi.github.io/posts/logs/20210501/</link>
      <guid>https://changhoi.github.io/posts/logs/20210501/</guid>
      <pubDate>Fri, 30 Apr 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;지난 21년 1월 2일부터 시작해서 4월 30일까지 열심히 노력해온 서비스의 사업화가 실패로 돌아갔다. 실패로 돌아갔다기 보다, 결과를 보지 못하고 정리하게 되었다. 4월 30일은 예비창업패키지가 선정되는 날이었다. 결과적으로 심사하시는 분들을 설득하는 것에 실패했고, 팀원들과 지속할 수 없다고 판단하여, 클로즈 베타 중인 서비스를 종료하고, 코어 컨셉만으로 동작하는 서비스 상태로 둘 예정이다. 이 기록은 4개월 동안 어떤 것을 배웠는지 회고하는 글이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이 글이, 그니까, 누군가에게 배웠던 걸 가르치고 싶어서 쓰는 내용이 절대 아니다. 이 글은 순전히 개인적인 경험과 의견이다.&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>지난 21년 1월 2일부터 시작해서 4월 30일까지 열심히 노력해온 서비스의 사업화가 실패로 돌아갔다. 실패로 돌아갔다기 보다, 결과를 보지 못하고 정리하게 되었다. 4월 30일은 예비창업패키지가 선정되는 날이었다. 결과적으로 심사하시는 분들을 설득하는 것에 실패했고, 팀원들과 지속할 수 없다고 판단하여, 클로즈 베타 중인 서비스를 종료하고, 코어 컨셉만으로 동작하는 서비스 상태로 둘 예정이다. 이 기록은 4개월 동안 어떤 것을 배웠는지 회고하는 글이다.</p><blockquote><p>이 글이, 그니까, 누군가에게 배웠던 걸 가르치고 싶어서 쓰는 내용이 절대 아니다. 이 글은 순전히 개인적인 경험과 의견이다.</p></blockquote><span id="more"></span><p>우리 서비스는 <a href="https://mangotable.me/">망고테이블</a>라는 서비스로, 만다라트 차트로 프로젝트를 계층적으로 분할하고, 서브 프로젝트를 통합적으로 관리하는 시각화 대시보드를 제공해주는 서비스를 기획했다. 기존 칸반 시스템으 포괄하면서, 서브 프로젝트를 포괄할 수 있다면, 충분히 이 치열한 시장에서 고개를 내밀 수 있을 것 같다는 생각을 했다.</p><p><img src="/images/2021-05-01-20210501/01.png" alt="망고테이블 이미지"><br><small>우리의 망고테이블 로고…</small></p><h2 id="나는-창업이-좋은-것-같아"><a href="#나는-창업이-좋은-것-같아" class="headerlink" title="나는 창업이 좋은 것 같아!"></a>나는 창업이 좋은 것 같아!</h2><p>나 개인적은 특성으로서도 한 두가지 느낀바가 있었다. 나는 창업을 천 억을 모을 수 있는 나와 가장 잘 맞는 방법이라고 생각했다. 서비스를 만드는 것을 좋아하고, 내가 좋아하는 서비스를 만들 때 정말 행복감을 느끼는 편이다. 이번 프로젝틀르 진행하면서도 물론 압도적인 작업량과 미래의 작업량을 생각하면 어지러울 정도로 힘든 적도 많았지만, 결과물이 눈에 나타나기 시작하는 점에서는 정말 재밌었다. 창업을 지금 시작한 계기는 졸업 전에 꼭 한번 만들어 보겠노라고 생각하던 서비스이기 때문이고, 두 번째는 학생으로서 받을 수 있는 많은 창업 관련 지원을 받을 수 있을 것이라 생각했다. 졸업이 1년 남은 시점에서 시작한 것은 좀 아쉽긴 했지만 (만약, 예비창업패키지만 되었다면? 1년 이상은 할 것 같다는 생각을 했기 때문에, 확실한 성패를 1년 안에 확인하지 못 할 수도 있겠다는 걱정을 했다.) 결과적으로 정말 깔끔하게 망했기 때문에, 시간 낭비가 딱히 없이 좋은 경험으로 남았다.</p><p>그러나 창업가가 나와 잘 맞을까? 나는 엔지니어 역할을 하는 것이 더 즐겁다. 나는 대표로서 재원을 끌어모으기 위한 활동을 할 때, 물론 미래를 그려보면서 느꼈던 즐거움도 있긴 하지만… 개발을 할 수 있다면 개발을 하는 상태가 더 좋았던 것 같다. 한 가지 가능성 있는 예상은, 서비스의 PMF가 잘 맞지 않았기 때문이 아니었을까? 내가 봐도, 언제쯤 트렐로보다 쓸만하다고 생각되는 서비스가 될 수 있을까에 대한 고민이 항상 많았다. 만약 내가 만들던 서비스의 PMF가 잘 맞아, 좋은 반응을 가져올만 했다면, 이런 대표로서 비개발적인 작업 역시 즐겁게 할 수 있었으려나?</p><h2 id="팀원"><a href="#팀원" class="headerlink" title="팀원"></a>팀원</h2><p>창업을 시작하는 사람들의 가장 답답한 부분은, 좋은 팀원을 어디에서 구할까에 대한 고민이다. 나는 시작이 가장 중요하다고 생각했고, 주변에 개발하는 친구 한 명, 디자인 하던 친구 한 명을 꼬셔서 시작했다. 다들 돈을 바란다기 보다는 서비스를 만들어보는 경험을 하고 싶었던 학생이었다는 점이 팀원으로 들어오는 데 큰 이유가 된 것 같다. 창업을 시작할 때는 4인으로 시작했으나, 4월부터는 3인 체제로 바뀌었다. 아주 대단치 않은 조직이었으나, 그 조직 안에서도 공동 창업 멤버로서 부적합하다고 판단되어 한 팀원을 내보내는 선택을 했다. 원인은 내가 판단했던 능력보다, 경험치의 부재가 더 큰 친구였기 때문인데, 초기 팀의 방향에서 눈에 띄는 도움을 줄 수 없었던 친구였다. 이 과정에서 느꼈던 점은, 명백한 JD를 수행할 수 없다면, 특히 초기에 팀원으로 데려오는 것에 대해 신중을 기해야 한다는 점이다. 같이 하게 된 친구도 친밀한 관계의 친구였는데, 지난 약 6개월 동안 목표에 집중할 수 있는 모습을 보여주어서 같이 해도 충분히 금방 역할을 해낼 것이라고 생각했기 때문에 함께 했는데, 쉽지 않은 동행을 했던 것 같다.</p><p>남은 두 팀원들은 그 뒤로도 정말 열심히 뛰어주었다. 돈 한 푼도 못 주는 창업이었지만 기량을 펼쳐주고 발전되는 모습을 보는 것도 신기했다. 좋은 사람들을 만나서 짧지 않은 시간을 함께한 것만으로도 원하던 것 중 하나를 이루긴 했다고 생각이 든다.</p><p><img src="https://images.unsplash.com/photo-1522881193457-37ae97c905bf?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1650&q=80"></p><p>정리하자면, 팀원은 내가 지내왔던, 경험한 곳에서 지인들이 주로 오게 되는 것 같고, 사람마다 다르겠지만, 전혀 모르는 사람하고 하루 아침에 만나서 공동 창업자로 뚝딱 변모하는 경우는 거의 없을 것 같다. (<del>아이러니하게도, 지난 직장에서 나는 그런 케이스이긴 했다.</del>) 또, 팀원을 모시기 위해서는 그 사람의 역할에 대해 충분히 고민해볼 필요가 있다. 나의 능력의 한계를 커버해줄 수 있는 능력이 있는 사람인지, 또 창업에 대한 열정이 넘치는 사람인지, 같은 비전을 공유할 수 있는 사람인지, 창업가가 지시하지 않아도 많은 의견을 개진해주고, 스스로가 서비스를 발전시켜줄 수 있는 사람인지 등…. 창업을 하면서 “대표는 원래 외롭게 결국 혼자 이끌어야 해” 라는 말을 들었다. 위에서 언급했던 것들을 해줄 수 있는 공동 창업 팀원을 만난다면 최소한 혼자 하는 것 같다는 느낌은 최소화 할 수 있을 것 같다.</p><h2 id="서비스"><a href="#서비스" class="headerlink" title="서비스"></a>서비스</h2><p>초기 스타트업에 조인한 개발자는 으레 다음과 같은 생각을 하는 것 같다. <strong>“내가 서비스를 만들어 내는데, 내 기여도는 적어도 절반 아니야?”</strong> 필자는 사실 초기엔 서비스를 만들어내는 개발자나, 디자이너와 같은 실무자들의 지분이 상당히 높다고 생각했던 개발자이다. 절대 틀린 말은 아니지만, 과장 해석할 필요가 없다. 서비스를 만드는 건 서비스를 성공시킨다와 동일하지 않다. 서비스를 성공시키는 것은 비개발적 영역일 확률이 높은 것 같다. 절반은 서비스 개발, 절반은 그 외 사업의 영역이라고 본다. 오히려 지분으로만 냉정히 보자면, 대표가 왜 90퍼센트나 가져가야 해라는 생각을 싹 없애도 좋다. 망한 사업의 대표들도 열심히 했겠지만, 성공한 사업의 대표는 90퍼센트 이상을 했다고 생각한다.</p><p><img src="https://images.unsplash.com/photo-1581093804475-577d72e38aa0?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1650&q=80"></p><p><strong>“나는 내가 아이디어, 기획도 하고 개발도 하는데, 그럼 내가 서비스를 만들고 있는 거 아니야?”</strong> 맞지! 그런데 사업은 서비스를 만드는 게 아니고, 돈을 벌어오는 것이라고 생각한다. 그것도 본인이 하고 있으면 본인이 대표 해야지. 나는 대표를 지내면서, 돈을 벌기 위한 준비 과정을 맛봤다고 생각하고, 그 과정 조차 쉽지는 않구나라는 걸 느꼈다.</p><p>마켓 핏이 잘 맞지 않는 사업은 끌고 가지 않는 게 무조건 맞는 것 같다. 시장을 개척한다는 발상은 너무나 훌룡하고 존경스러우나, 너무 어렵고 가능성이 적은 일인 것 같다. 가장 크지만, 우리가 신경 써야 할 일부분이 줄어든다는 것이 PMF가 잘 맞는 아이템을 선정하는 것이라고 생각한다. 우리 서비스는 어땠을까? 우리 서비스는 사실 상상으로는 굉장히 사용할만 하다. 이것 또한 나의 상상이고 부딪혀 봐야 아는 거지만, 잘 만들기만 하면 된다. 잘 만들려면 시간과 인력이 필요한 부분이 있었고, 인력을 충원하기 위한 재원을 마련하지 못하면서 사이드 프로젝트로 돌리고, 초장기적으로 한 번 끌고 가보려고 한다.</p><p>이 서비스를 포기한 상태는 아니다. 어쨌든 재밌겠다라고 생각했던 서비스라 그런지, 재밌게 개발했고 앞으로 사이드 프로젝트로 돌린 후 경험하고 싶은 것들이 꽤 많다.</p><h2 id="초기-과정은-짧게-근데-이제-완성도를-곁들인"><a href="#초기-과정은-짧게-근데-이제-완성도를-곁들인" class="headerlink" title="초기 과정은 짧게, 근데 이제 완성도를 곁들인"></a>초기 과정은 짧게, 근데 이제 완성도를 곁들인</h2><p>우리에게 초기 과정은, MVP를 만들어내는 것이었다. MVP는 가볍게 만들었지만, 우리가 원하는 바를 충실히 수행하는 상태는 아니었다. 무엇이든 예창패를 위해 지표를 만들 생각이었고 클로즈 베타를 빠르게 냈다. 속도는 나쁘지 않았던 것 같다. 우리가 Product Hunt에 게시하고, 클로즈 베타를 위한 유저풀을 모은 뒤, 메일을 통해 클로즈 베타가 오픈되었음을 알렸는데, 사람들이 우선 사용하기 위해 접근하지 않았다. “서비스가 별로네요. 쓰기 힘들듯 합니다.” 이런 느낌도 아니라, 메일을 통한 접근 정도가 정말 작았다. 그래서 다시 한다면, Product Hunt에는 클로즈 베타가 준비된 상태로 서비스를 올리고, 프로덕트 헌트를 통해 접근한 유저에게 서비스를 열어주는 방식으로 하고 싶다. 이 방식이 훨씬 많은 피드백을 얻을 수 있다고 생각한다. 너무 초조해 하지 말고, 천천히 칼을 갈 수 있는 마인드 셋이 있었다면, 사용한 유저 수도 늘고, 더 좋은 사용자 경험을 줄 수 있었을 것 같다.</p><h2 id="그럼-이제"><a href="#그럼-이제" class="headerlink" title="그럼 이제?"></a>그럼 이제?</h2><p>역량을 기르고 주변에 더 좋은 사람들을 만드는 과정을 지내야 할 것 같다. 언젠간 다시 창업을 도전 할 것 같다. 그런데 지금은 아주 훌륭한 팀원들고 함께 서비스를 만들고 싶다. 학점은 얼마 안남았지만, 아직 졸업까지 한 학기가 더 남아있고 공부할 시간이 충분히 있으니까, 열심히 기본기에 대한 공부랑 그동안 미뤄왔던 개인 프로젝트들을 정리해서 블로그도 다시 시작해야겠다. (지금 쓰겠노라고 리스트업 해놓은 글만 해도 좀 많다.)</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/logs/">logs</category>
      
      
      <category domain="https://changhoi.github.io/tags/log/">log</category>
      
      <category domain="https://changhoi.github.io/tags/retrospect/">retrospect</category>
      
      
      <comments>https://changhoi.github.io/posts/logs/20210501/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>배워서 바로 쓰는 14가지 AWS 구축 패턴 간단 리뷰</title>
      <link>https://changhoi.github.io/posts/books/aws-architecture-pattern/</link>
      <guid>https://changhoi.github.io/posts/books/aws-architecture-pattern/</guid>
      <pubDate>Sat, 17 Apr 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;이번년도에도 한빛 미디어의 &lt;strong&gt;나는 리뷰어다&lt;/strong&gt;에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 4월 미션으로 나온 책 중에 하나인 &lt;strong&gt;배워서 바로 쓰는 14가지 AWS 구축 패턴&lt;/strong&gt;을 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번년도에도 한빛 미디어의 <strong>나는 리뷰어다</strong>에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 4월 미션으로 나온 책 중에 하나인 <strong>배워서 바로 쓰는 14가지 AWS 구축 패턴</strong>을 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.</p><span id="more"></span><p>이 책은 여러 경우의 예시를 들면서, 어떤 경우에 AWS 아키텍처를 어떤 방식으로 쓸 수 있다는 형식의 레시피 북이다. 책이 짧아서 빨리 읽을 수 있었고, 구체적인 설정 방법을 하나하나 알려주는 것 보다, 상황과 그 상황에 맞는 아키텍처를 소개하는 것에 집중했다. 다시 말하자면, 초보자는 이 책을 읽고 직접 수행해보기 어렵다. 하지만, AWS를 어떻게 쓰는 거구나 하는 감을 잡을 수 있고, 이미 경험이 많은 사람들에게는 이렇게도 할 수 있겠구나, 또는 이런 서비스가 이럴때 쓸 수 있구나와 같은 인사이트를 적립해주는 책이다. 목적이 명확한 책이라 내용이 부실하더라도 확실히 좋은 책이라고 생각이 들었다. 이 책을 읽은 다음, 관심이 생긴 영역에 대해 더 집중적으로 공부할 수 있는 시작점 역할도 해줄 수 있는 책이다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/books/">books</category>
      
      
      <category domain="https://changhoi.github.io/tags/review/">review</category>
      
      
      <comments>https://changhoi.github.io/posts/books/aws-architecture-pattern/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>고객이 보이는 구글 애널리틱스 간단 리뷰</title>
      <link>https://changhoi.github.io/posts/books/google-analytics/</link>
      <guid>https://changhoi.github.io/posts/books/google-analytics/</guid>
      <pubDate>Tue, 23 Mar 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;이번년도에도 한빛 미디어의 &lt;strong&gt;나는 리뷰어다&lt;/strong&gt;에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 3월달 미션으로 나온 책 중에 하나인 &lt;strong&gt;고객이 보이는 구글 애널리틱스&lt;/strong&gt;를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번년도에도 한빛 미디어의 <strong>나는 리뷰어다</strong>에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 3월달 미션으로 나온 책 중에 하나인 <strong>고객이 보이는 구글 애널리틱스</strong>를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.</p><span id="more"></span><p>한빛 미디어 나는 리뷰어다에서 가장 기가 막힌 점은, 현재 가장 공부가 필요한 영역에대한 책이 선정되어 받아서 읽어보게 된다는 것이다. 특히 이번에 이 책도 진행 중인 프로젝트에 애널리틱스를 붙이고, 필요한 지표를 정리하기 위해서 구글 애널리틱스에 대한 공부가 필요한 순간 이렇게 책으로 받아보게 되었다. 구글 애널리틱스는 유의미한 데이터가 없다면 사실 실습하기 어렵다는 문제도 있는데, 이 책에서는 유의미한 데이터를 확인할 수 있는 방법도 함께 제공해서, 정말 실무같은 느낌이 나는 실습을 진행할 수 있었다. 총 다섯 개의 파트로 구성되어 있고 4개 파트가 구글 애널리틱스의 기본, 심화, 전자상거래 분석 기능을 보게 된다. 마지막은 애널리틱스가 아닌, A/B 테스팅 도구인 옵티마이즈, 개발자 없이 데이터 수집, 내용 변경이 가능하게 해주는 구글 태그매니저에 대해서 간단하게 공부할 수 있다.</p><p>이 책이 좋은 이유는 엔지니어링 영역과 최대한 분리했다는 느낌을 받을 수 있었다는 점이다. 즉, 개발과 거리감이 있는 사람도 쉽게 구글 애널리틱스를 학습 할 수 있도록 만들었다. 실습 예제도 굉장히 실제적이라고 생각되어 흥미를 끄는데 충분했다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/books/">books</category>
      
      
      <category domain="https://changhoi.github.io/tags/review/">review</category>
      
      
      <comments>https://changhoi.github.io/posts/books/google-analytics/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>맛있는 디자인 프리미어 프로&amp;애프터 이펙트 CC 2021 간단 리뷰</title>
      <link>https://changhoi.github.io/posts/books/after-effect/</link>
      <guid>https://changhoi.github.io/posts/books/after-effect/</guid>
      <pubDate>Sat, 20 Feb 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;이번년도에도 한빛 미디어의 &lt;strong&gt;나는 리뷰어다&lt;/strong&gt;에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 2월달 미션으로 나온 책 중에 하나인 &lt;strong&gt;맛있는 디자인 프리미어 프로&amp;amp;애프터 이펙트 CC 2021&lt;/strong&gt;를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번년도에도 한빛 미디어의 <strong>나는 리뷰어다</strong>에 선정되어 매달 책 한 권씩을 읽을 수 있게 됐다. 2월달 미션으로 나온 책 중에 하나인 <strong>맛있는 디자인 프리미어 프로&amp;애프터 이펙트 CC 2021</strong>를 받게 됐고, 이번 달에 읽어보게 됐다. 이 글은 이 책에 대한 간단한 리뷰이다.</p><span id="more"></span><p>이 책은 누구나 쉽게 배워서 써먹을 수 있는 그래픽 입문서로, 각 프로그램별로 도구부터 편집 방법까지 하나하나 알려주는 친절한 가이드북이다. 편집 기능을 익히는데에 있어서 적합만 기능 소개, 실무 예제들로 구성이 되어있어, 보다 쉽고 빠르게 이해할 수 있었다. 책은 파트 1과 파트 2로 구성되어있다. 파트 1은 프리미어 프로, 파트 2는 에프터 이펙트로 구성되어 있다. 프리미어 프로보다 에프터 이펙트가 다루기 아려워 먼저 기반으로 프리미어 프로를 먼저 배우도록 방향을 유도해 읽기 더 쉬웠던 것 같다. 기본기를 탄탄하게 잡을 수 있을 뿐만 아니라 매번 새롭게 업데이트 되는 신기능에 완벽하게 대응할 수 있고 단축키들이 깔끔하게 정리되어 있어 보다 빠르게 작업을 할 수 있는 친절한 지침서이다. 또한 스토리보드 구성, 제작 방식 결정 등의 정보들이 들어 있어 영상 편집 센스를 이 책을 통해 배울 수 있다. 이러한 모든 과정들이 커리큘럼으로 구성되어 있기 때문에 누구나 쉽게 도전할 수 있을 것 같다. 누구에게나 쉽고 잘 활용할 수 있는 레시피를 담은 책이라고 말하고 싶다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/books/">books</category>
      
      
      <category domain="https://changhoi.github.io/tags/review/">review</category>
      
      
      <comments>https://changhoi.github.io/posts/books/after-effect/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React UI Kit 만들기 대작전</title>
      <link>https://changhoi.github.io/posts/etc/great-operation-creating-react-ui-kit/</link>
      <guid>https://changhoi.github.io/posts/etc/great-operation-creating-react-ui-kit/</guid>
      <pubDate>Sat, 13 Feb 2021 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;리액트 프로젝트를 새로 시작하기 앞서, 프로젝트 전반에 걸쳐서 사용되는 UI Kit을 만들기 위해서 두 가지 시도를 했던 내용에 대해서 적어보려고 한다. 한 가지는 Private Package이고, 다른 한 가지는 StoryBook이다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>리액트 프로젝트를 새로 시작하기 앞서, 프로젝트 전반에 걸쳐서 사용되는 UI Kit을 만들기 위해서 두 가지 시도를 했던 내용에 대해서 적어보려고 한다. 한 가지는 Private Package이고, 다른 한 가지는 StoryBook이다. </p><span id="more"></span><p>프라이빗 패키지는 npm에 공개된 패키지가 아니라, 특정 권한이 있어야 설치가 가능한 패키지를 말한다. 프라이빗 패키지는 클라이언트, 백앤드 작업을 모두 TS로 하면서 가끔 공유하고 있는 타입이나 클래스를 일종의 패키지로 구성한 적이 있다. StoryBook은 클라이언트 개발자들에게 Swagger와 같은 역할을 해주는 컴포넌트 뷰어라고 볼 수 있다. 스토리북에 대해서는 이전부터 알고는 있었지만, 클라이언트 개발에 항상 반만 진심이었던 필자는, 사용할만한 상황이 오지 않았다. 이런 UI 킷을 만들어야 하는 경우가 생기면, UI가 어떻게 생겼는지 보면서 개발하기가 애매한 경우가 있는데, 이런 문제를 깔끔하게 해결해줬다.</p><p><video autoplay="" muted="" loop="" playsinline="" alt="Demo video" class="Video__StyledVideo-sc-1d2xgwb-0 gXgTXy"><source src="https://storybook.js.org/videos/storybook-hero-video-optimized.mp4" type="video/mp4"></video></p><p><small>스토리북 메인에 등장하는 소개 영상</small></p><blockquote><p>Private Package를 관리하는 것 보다, Submodule을 만드는 것도 하나의 방법이 될 수 있을 것 같다.</p></blockquote><h2 id="Private-UI-Library-Package-만들기"><a href="#Private-UI-Library-Package-만들기" class="headerlink" title="Private UI Library Package 만들기"></a>Private UI Library Package 만들기</h2><p>필자는 프라이빗 패키지를 Github에 배포하는 편이다. Github에서 패키지 관리를 할 수 있는 기능을 추가하면서 가능해졌는데, 이를 위해서는, 기본으로는 NPM 패키지로 배포가 되기 때문에,  배포할 때 패키지가 어디에 배포되는지 명시해야 한다. 물론 패키지를 가져올 때에도 그렇다.</p><blockquote><p>실제로 가장 별로라고 생각했던 점 중에 하나이다.</p></blockquote><p>그 역할을 해주는 것이 바로 <code>.npmrc</code>이다. 이름 그대로 npm 설정 파일이고, 이 파일 안에 배포하는 패키지가 Github package repository를 바라보게 하고, 그 패키지 권한이 있는 토큰을 함께 명시해주면 된다. 아래와 같은 모습을 갖게 된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//npm.pkg.github.com/:_authToken=[string]</span><br><span class="line">@[package-scope]:registry=https://npm.pkg.github.com/</span><br></pre></td></tr></table></figure><p>첫 번째 줄에는 <code>npm.pkg.github.com</code>에 접근할 때 권한을 어떤 권한으로 접근하게 되는지를 설정한다. authToken은 권한마다 다르게 발급된다. 권한을 받으려면, 깃헙의 <code>Settings</code> 페이지 아래 <code>Developer settings</code> 페이지에서 받을 수 있다.</p><p><img src="/images/2021-02-14-great-operation-creating-react-ui-kit/01.png"></p><p>두 번째 줄에는 배포시에 레포지토리가 속한 Organization? 이라고 할 수 있는 걸 정의 해둬야 한다. 예를 들어서 <code>toy-program</code>이라는 이름의 Organization에 배포한 경우, <code>@toy-program</code>을 붙여주면 된다.</p><p>이 작업이 끝나면, <code>npm.pkg.github.com</code>에 접근할 때는 <code>[string]</code> 권한을 가지고 접근하고, 이 프로젝트의 <code>package.json</code>에서 <code>@[package-scope]</code>에 포함되는 패키지들은 <code>npm.pkg.github.com</code>에서 찾도록 해라! 라고 설정을 마친 것이다.</p><h2 id="package-json-설정하기"><a href="#package-json-설정하기" class="headerlink" title="package.json 설정하기"></a><code>package.json</code> 설정하기</h2><h3 id="기본-설정"><a href="#기본-설정" class="headerlink" title="기본 설정"></a>기본 설정</h3><p><code>package.json</code>에도 몇 가지 설정해줘야 할 부분이 있다. 어떤 파일을 대상으로 하는지, 어디 레포지토리에 올리는지, 배포 관련 설정 등이 있다. 아래 내용들을 추가해줬다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;lib&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;lib/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;types&quot;</span>: <span class="string">&quot;lib/index.d.ts&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;repository&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;[github repository url]&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;publishConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;directory&quot;</span>: <span class="string">&quot;lib&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;registry&quot;</span>: <span class="string">&quot;https://npm.pkg.github.com/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 설정을 마쳐야 Typescript로 만든 React 컴포넌트를 <code>lib</code> 디렉토리에 빌드 한 후 배포할 수 있었다. 배포 명령은 <code>yarn publish</code>로 할 수 있다.</p><blockquote><p>주의할 점 몇 가지가 있다면, <code>yarn publish</code> 후, 명시된 버전이 배포된 다음엔 같은 버전으로 배포할 수가 없다. 버저닝에 신중을 가할 필요가 있다. 또한, 타입스크립트 프로젝트의 경우, 배포시 빌드가 완료된 부분을 배포하는데, 웹팩이나 <code>tsconfig</code>에서 Output으로 설정한 부분을 files에 추가해줘야 한다. 필자의 경우는 일반적으로 <code>dist</code> 이름이 붙는 부분을 <code>lib</code>으로 한 것이다.</p></blockquote><h3 id="husky-lint-staged-설정하기"><a href="#husky-lint-staged-설정하기" class="headerlink" title="husky, lint-staged 설정하기"></a><code>husky</code>, <code>lint-staged</code> 설정하기</h3><p><code>husky</code>와 <code>lint-staged</code>는 깃 훅을 쉽게 설정해둘 수 있도록 도와주는 패키지이다. <a href="https://changhoi.github.io/posts/etc/husky/">이전 글</a>에서 <code>husky</code>를 간단하게 설명한 바 있지만, 아주 간략한 소개였다. 근데 사실 그 이상 디테일한 내용도 없다. 그냥 깃 훅을 적절하게 조합하면 되는 건데, <code>lint-staged</code>는 깃 훅이 동작할 때, 특정 파일에 대해 특정 커맨드를 실행할 수 있게 해준다. </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;*.&#123;js,ts,tsx&#125;&quot;</span>: <span class="string">&quot;eslint --fix&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와같이 <code>package.json</code>에 추가해서, 커밋 전에 린트를 돌려주고 수정 가능하면 수정하도록 설정해뒀다. 이제 협업을 할 때 정한 코드 컨벤션에 맞지 않는 코드가 커밋되는 것을 방어할 수 있다.</p><h2 id="webpack-config-js-설정하기"><a href="#webpack-config-js-설정하기" class="headerlink" title="webpack.config.js 설정하기"></a><code>webpack.config.js</code> 설정하기</h2><p>“웹팩 설정이 뭐 크게 다르겠냐”고 생각했지만, 뼈 아픈 결과를 맛 보고, 꼭 기록해야지 하는 생각이 들게 만든 부분이 있었다. 바로 모듈과 관련된 내용이었다. 웹팩에는 라이브러리를 빌드할 때 빌드 타겟을 설정할 수 있는 옵션이 있다. <code>libraryTarget</code>이라고 하는 옵션인데, 웹팩 문서의 설명에는 라이브러리가 어떻게 <code>exposed</code> 될지 설정하는 값이며, 기본 값은 <code>var</code>이라고 한다. </p><h3 id="웹팩이-빌드-할-때-ES-방식으로-import-할-수-있도록-target-설정"><a href="#웹팩이-빌드-할-때-ES-방식으로-import-할-수-있도록-target-설정" class="headerlink" title="웹팩이 빌드 할 때, ES 방식으로 import 할 수 있도록 target 설정"></a>웹팩이 빌드 할 때, ES 방식으로 import 할 수 있도록 target 설정</h3><p>이제 빌드 하고 사용해봐야겠다고 생각하고, 빌드 후 <code>yarn publish</code>로 배포까지 했지만 리액트 프로젝트에서 사용이 안되는 문제가 있었다. 알아본 결과, 패키지를 빌드할 때, <code>target</code>을 설정해줘야 하는 이슈였다. 아마 그냥 빌드를 하면 ES Module 방식으로 import 할 수 없는 상태로 빌드되는 것 같았다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="attr">libraryTarget</span>: <span class="string">&#x27;umd&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>Webpack에 <code>output</code> 옵션 중 <code>libraryTarget</code>에 <code>umd</code> 옵션을 붙여주는 방식으로 해결했다. <code>libraryTarget</code> 옵션은 라이브러리가 어떻게 <code>exposed</code> 될지를 결정하는 옵션이다. 기본 옵션은 <code>var</code>이다.</p><blockquote><p>옵션 값이 어떤 것을 의미하는지 <a href="https://webpack.js.org/configuration/output/#module-definition-systems">웹팩 공식문서 내용</a>을 통해 알아보려고 했지만, 무슨 의미인지 쉽게 알 수 없어 이 <a href="https://kishu.gitbooks.io/webpack/content/">링크</a>에서 내용을 학습했다.</p></blockquote><p><code>umd</code>옵션은 ES Module 방식, CommonJS 방식, AMD 방식 모두 모듈을 불러올 수 있도록 번들링 해준다. 위 모듈 임포트 방식에 대해서 정확히 알지 못 한다면, <a href="https://ui.toast.com/weekly-pick/ko_20190418">TOAST 개발 블로그 글</a>을 꼭 참고하길 바란다. 정말 최고.</p><p>내용은 짧았지만, 이 문제를 경험하면서, 역시 나는 프론트를 제대로 공부하지 못했구나 싶은 생각도 들었다.</p><h2 id="StoryBook-붙이기"><a href="#StoryBook-붙이기" class="headerlink" title="StoryBook 붙이기"></a>StoryBook 붙이기</h2><h3 id="What’s-a-Story"><a href="#What’s-a-Story" class="headerlink" title="What’s a Story"></a>What’s a Story</h3><p>스토리는 렌더링 된 형태의 UI 컴포넌트를 뜻한다. 개발자는 여러 스토리들을 한 컴포넌트에 할당해 만들 수 있다. 컴포넌트가 여러 상태를 가질 수 있기 때문에, 지원 중인 모든 상황에 대해 스토리를 만들 수 있게 구성되어있다. 예를 들자면, 버튼의 Primary한 상태, Secondary 상태 등으로 나눌 수도 있고, 사이즈 별로 나눌 수도 있는 것이다.</p><h3 id="인스톨"><a href="#인스톨" class="headerlink" title="인스톨"></a>인스톨</h3><p>이미 컴포넌트 진행이 되어있는 프로젝트의 루트 디렉토리에서 설치할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sb init</span><br></pre></td></tr></table></figure><p>매지컬리 아주 깔끔하게 스토리북이 설치된다.</p><h3 id="스토리북에-버튼-한-번-붙여보기"><a href="#스토리북에-버튼-한-번-붙여보기" class="headerlink" title="스토리북에 버튼 한 번 붙여보기"></a>스토리북에 버튼 한 번 붙여보기</h3><p>예를 들어서 만들어진 <code>RoundButton</code>을 스토리북에 올려보자. 먼저 결과적으로는 이렇게 나오고 있다.</p><p><img src="/images/2021-02-14-great-operation-creating-react-ui-kit/04.png"></p><p>스토리북은 <code>stories</code> 디렉토리 안에 있는 모든 <code>**.stories.tsx</code> 형태를 컴포넌트로 올려주는 것 같다. <code>stories/Buttons/RoundButton.stories.tsx</code>라는 파일을 만들어서, 다음과 같이 코드를 짰다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// also exported from &#x27;@storybook/react&#x27; if you can deal with breaking changes in 6.1</span></span><br><span class="line"><span class="keyword">import</span> &#123;Story, Meta&#125; <span class="keyword">from</span> <span class="string">&#x27;@storybook/react/types-6-0&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RoundButton, RoundButtonProps&#125; <span class="keyword">from</span> <span class="string">&#x27;@/components/RoundButton&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&#x27;Button/RoundButton&#x27;</span>,</span><br><span class="line"> <span class="attr">component</span>: RoundButton</span><br><span class="line">&#125; <span class="keyword">as</span> Meta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Template: Story&lt;RoundButtonProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">RoundButton</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Default = Template.bind(&#123;&#125;);</span><br><span class="line">Default.args = &#123;</span><br><span class="line"> <span class="attr">children</span>: <span class="string">&#x27;RoundButtonComponent&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 글에서는 자세하게 설명되어 있지는 않지만, 일반적으로 Typescript 프로젝트를 구성할 때 절대경로를 만들어서 사용하는 편이다. <code>@/*</code> 형태의 절대경로는 루트 디렉토리 아래 <code>packages</code>라는 디렉토리로 경로를 찾게 해두었다.</p><p>이때 문제가 발생했는데, 절대 경로를 스토리북에서 제대로 컴파일 하지 못 하는 문제였다. 확인 결과, 스토리북에서 사용하는 webpack config는 따로 설정해줘야 한다는 점이다. 설정은 <code>.storybook</code>안에 두면 된다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ForkTsCheckerWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;fork-ts-checker-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;TsconfigPathsPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;tsconfig-paths-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">&#123;config, mode&#125;</span>) =&gt;</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> config.resolve.plugins.push(<span class="keyword">new</span> TsconfigPathsPlugin());</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위 코드처럼, 스토리북이 웹팩 설정을 적용하기 전에, 주입을 넣는 것 방법으로 작동한다. <code>TsconfigPathsPlugin</code>를 사용해서 <code>tsconfigs.json</code>의 Path 설정을 공유하도록 만들었다.</p><p><img src="/images/2021-02-14-great-operation-creating-react-ui-kit/05.png"></p><p>별 다른 옵션을 안 넣어줬는데, Props에 따라서 컨트롤을 넣어준다. 저렇게 컨트롤러를 사용해볼 수도 있고, Docs처럼 컴포넌트를 정리해주기도 한다. 스크린 뷰를 휴대폰이나 테블릿 사이즈로 맞춰 볼 수도 있고 그리드를 넣어서 볼 수도 있다. 문서만 확인해봐도 다양한 기능들을 쉽게 쓸 수 있게 생기긴 했는데, 하나씩 시도해보고, 쓸만한 거 있으면 도입하면서 알아갈 필요가 있을 것 같다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://kishu.gitbooks.io/webpack/content/">https://kishu.gitbooks.io/webpack/content/</a></li><li><a href="https://ui.toast.com/weekly-pick/ko_20190418">https://ui.toast.com/weekly-pick/ko_20190418</a></li><li><a href="https://webpack.js.org/configuration/output/#outputlibrarytarget">https://webpack.js.org/configuration/output/#outputlibrarytarget</a></li><li><a href="https://avengersrhydon1121.tistory.com/276">https://avengersrhydon1121.tistory.com/276</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/etc/">etc</category>
      
      
      <category domain="https://changhoi.github.io/tags/react/">react</category>
      
      
      <comments>https://changhoi.github.io/posts/etc/great-operation-creating-react-ui-kit/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020년, 개발 2년차 회고</title>
      <link>https://changhoi.github.io/posts/logs/20201230/</link>
      <guid>https://changhoi.github.io/posts/logs/20201230/</guid>
      <pubDate>Tue, 29 Dec 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;개발에 흥미를 갖고 시작한 지 대충 2년이 찼다. 만족스러운 개발자 직업을 가진 적이 없음으로 주니어 개발자라고 하기는 아직도 거북한 감각이 있다. 이번 한 해는 다사다난했으므로 성장하기 좋은 한 해가 아니었을까 싶다. 올해 경험한 내용을 정리하고 내년에는 더 탄력받을 수 있으면 좋겠다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>개발에 흥미를 갖고 시작한 지 대충 2년이 찼다. 만족스러운 개발자 직업을 가진 적이 없음으로 주니어 개발자라고 하기는 아직도 거북한 감각이 있다. 이번 한 해는 다사다난했으므로 성장하기 좋은 한 해가 아니었을까 싶다. 올해 경험한 내용을 정리하고 내년에는 더 탄력받을 수 있으면 좋겠다.</p><span id="more"></span><h2 id="초기-창업-팀"><a href="#초기-창업-팀" class="headerlink" title="초기 창업 팀"></a>초기 창업 팀</h2><p><img src="https://cdn.pixabay.com/photo/2020/01/02/13/08/startup-4735778_1280.jpg"></p><p>작년 말부터 올해 8월까지는 초기 창업 팀에서 열심히 창업 과정을 겪었다. 바닥부터 시작하는 창업은 많은 걸 경험해볼 수 있었다. 과거에 한 개발자 선배님께서, 현재 정말 잘되고 있는 스타트업의 초기 멤버로 참여해, DAU가 늘어나는 과정을 짧은 시간 내에 경험했던 것이 개발자로서 쉽게 경험할 수 없는 것이라고 말씀하신 것에 홀려 초기 창업을 생각한 적이 있다. 운이 좋게도(?), 좋은 실적을 낼 수 있다고 생각되는 아이디어를 가진 초기 창업 대표님을 만나서 창업을 시작했다. 하지만 말씀하신 그 경험은 사실 타이밍에 대한 아주 큰 행운이 따라 주면 겪을 수 있는 케이스이다. 물론 시작 전에도 그렇게 생각했지만, 아쉽게도 그 과정을 초기 창업 팀에 있을 때 겪지는 못했다.</p><p>사실 목적으로 정한 바는 위와 같았지만, 더 많은 것을 경험하고, 여러 방면으로 새로운 시야와 방향으로 동기부여를 많이 얻을 기회가 되었다고 생각했다. 창업에 대한 아주 막연한 관심만 두고 있던 필자는 이 과정 이후 초기 창업에 어떤 단계가 있고, 개발 외에도 해야 할 것이 수만 가지이며 어떤 점들을 특히 신경 써줄 필요가 있을지, 팀원들과 어떻게 소통해야 좋을지에 대한 엄청난 고민, 팀을 리드할 때 어떻게 해야 팀에게 동기부여를 줄 수 있을지에 대한 고민 등등을 했다.</p><h3 id="초기-창업에서-개발자가-겪는-문제"><a href="#초기-창업에서-개발자가-겪는-문제" class="headerlink" title="초기 창업에서 개발자가 겪는 문제"></a>초기 창업에서 개발자가 겪는 문제</h3><p>초기 창업이라는 상황이 가져오는 몇 가지 고통이 있었던 것 같다. 보통 인력 부족으로 생기는 문제이다.</p><ol><li><p>금전적 여유가 없는 단계에서 생기는 문제<br> 예비 창업 패키지, 초기 창업 패키지를 바라보면서 달리는 상황에서는 금전적인 압박이 있을 수밖에 없다. 대표님께서 개인 돈도 꽤 투자하신 편이라, 일단 정말 바닥부터 하는 스타트업들과 다르게 여유가 아예 없었던 건 아니지만, 당연히 어마어마한 금액은 아니므로, 바로 다음 단계를 위한 시드 머니가 필요한 상황이다. 이런 상황에서 개발자 구인은 정말 힘들다. 초기 창업 멤버로 잘하는 사람을 데려오기는 정말 어렵고, 잘하지 못 하는 사람이더라도 포텐셜을 믿고 가기엔 금전적인 한계가 있다 (애초에 잘한다 잘 하지 못 한다는 것에 대한 평가조차 어렵다). 기본적으로 많은 사람과 함께 일할 수 없지만, 개발 일정은 정말 촉박하다. 바로 다음 달 안에 MVP를 뽑아야 하고 며칠 안에 완성해야 하고 이런 상황이 부지기수이다. 갈려 나가는 느낌은 정말 잊을 수가 없다. 하루 열 시간 이상 근무, 잠도 못 자는 경우도 많았다.</p></li><li><p>불완전한 사업 모델로 인해 생기는 문제<br> 필자의 경우, 가장 동기부여를 깎아 먹는 문제는 여기에서 발생했다. 또한 이 문제로 인해 파생되는 여러 문제가 있다. 초기 창업 아이템은 정말 추상적이거나, 불완전하다. 물론 서비스라는 것은 항상 더 나은 방향으로 발전해야 하므로 불완전이라고 하는 것이 언제나 존재하지만, 초기 창업에서 불완전은 뜻이 아주 다르다. 피벗 수준의 기획 변경 과정이 수도 없이 발생하고, 정말 아예 새로운 프로젝트가 되어서 갈아엎고 처음부터 하게 되는 경우도 생긴다. 필자와 함께한 창업팀의 아이템은 상당히 규제에 민감한 사업이어서 특히 여러 번 프로젝트가 엎어졌고, 거의 코드 십만 줄 이상은 버린 것 같다. 그 과정에서 오는 현타가 정말 심했던 것 같다.</p></li><li><p>원하는 개발을 하지 못하는 문제<br> 이 문제는 사실 초기 창업뿐만 아니라 어디서든 마찬가지이다. 창업에서 비즈니스 앞에 개발이 있을 수는 없기 때문에, 비즈니스 요구사항을 위해 선택할 수 있는 개발 선택지가 제한되는 경우가 있다. 하지만 초기 창업에서는 선택지가 과하게 좁혀지는 경우가 많다. 예를 들어서 본인은 테스트코드를 작성하고 주기적인 리팩토링 하는 것이 결과적으로 좋다는 걸 알고 있고, 그렇게 하고 싶었다. 하지만 MVP 모델인 것도 알고 있고, 쉽게 엎어지는 과정을 반복하기도 하고, 빡빡한 개발 일정을 보고 있으면서 테스트코드를 촘촘히 짜며 개발할 수는 없었다. 그리고 문제를 해결하기 위해 새로운 기술을 도입하는 것에 대해서도 아주 보수적으로 바라봐야 한다. 러닝 커브가 일정 수준 이상인 경우 적용할 수 없다.</p></li></ol><h3 id="초기-창업에서-개발자가-경험할-수-있는-것들"><a href="#초기-창업에서-개발자가-경험할-수-있는-것들" class="headerlink" title="초기 창업에서 개발자가 경험할 수 있는 것들"></a>초기 창업에서 개발자가 경험할 수 있는 것들</h3><p>힘든 경험도 있었지만, 그래도 하길 잘 했다고 생각이 들게 만드는 몇 가지 포인트도 있었다.</p><ol><li><p>개발 외 다양한 업무를 맛볼 수 있음.<br> 초기 창업의 팀원은 말 그대로 제네럴리스트여야 한다. 본인의 전문 분야가 아니더라도 해결해야 할 문제에 초점을 맞춰야 할 때가 많고, 필자의 경우에는 대부분 개발에 집중할 수 있는 환경을 최대한 보장 받았음에도 불구하고, 기획과 기업의 운영 관련해서도 일부 참여하기도 했다. 많은 개발자는 이런 것을 그리 좋아하지 않는다. 하지만 본인은 좋은 경험이었다고 생각했다. <del>(회의가 많고 여러 이유로 사람들을 만나는 역할도 해야 했다는 점은 좋지 않았음)</del></p></li><li><p>공동 창업자로서의 대우<br> 개발자에게 한정된 얘기는 아니지만, 창업에 함께 뛰어들면 위험 부담과 기여에 따라 공동 창업자로서 대우를 받게 된다. 감사하게도 대표님이 공동 창업자로서 필자를 잘 챙겨주셔서, 어느 정도 감사한 마음과 함께 동기부여가 잘 되던 기간도 있었다. 애초에 지분 공유 관련된 얘기라든지, 경영과 관련된 얘기를 이번 기회가 아니었다면 어디서 경험했을 수 있겠냐는 생각도 들기 때문에 이런 경험 자체가 신선하고 좋았다.</p></li><li><p>열정적인 사람들과 일 하는 맛<br> 초기에는 소수의 인원이 프로젝트에 참여하고, 프로덕트에 기여하는 정도가 큰 편이기 때문에, 프로덕트에 대한 주인 의식도 높고, 다들 애정을 갖고 하는 기간이 있다. 이 기간에는 창업자들이 함께 열심히 일하는 과정에 껴서 하루하루를 <del>즐겁게</del> 일할 수 있었다. <del>(사실 즐겁게는 자기최면일 수도 있다. 본인은 즐겁긴 했는데, 업무량 증가로 인해 즐겁게 보다 고통이 커지는 순간이 오기는 했다)</del> 그래도 스타트업 판이라는 게, 초기 삼산텍처럼 느긋할 수가 없이 정신없는 구조이고 이런 구조 속에서 재미를 느낄 수 있는 사람이면 또 나름의 매력을 얻는 포인트가 되지 않을까…</p></li></ol><h2 id="학기"><a href="#학기" class="headerlink" title="학기"></a>학기</h2><p>필자는 현재 대학생으로, 가을 학기를 수료하면서 6학기를 수료한 상태가 되었다. 스타트업은 코로나 상황으로 인해 갑작스러운 개인적인 계획의 변경이 생기면서 오래 일하지 못하고 나오게 되었다. 남은 학점을 많이 채우고 조기 졸업을 할 수 있게 하기 위해서 22학점을 수강했다. 성적도 나름 잘 받았고 프로젝트에 생각보다 집중을 많이 해서 원하던 공부를 열심히 할 수 있던 건 아니었다.</p><h3 id="소프트웨어공학"><a href="#소프트웨어공학" class="headerlink" title="소프트웨어공학"></a>소프트웨어공학</h3><p>이번 학기의 정말 80%를 차지했다고 볼 수 있는 수업이었다. 한 학기 동안 프로젝트를 하는 수업인데, 간단하게 만들 계획이었으나 백앤드가 요구 사항에 들어가고, 인공지능 AI 스피커와 결합한 프로젝트를 하려고 팀원들과 얘기하다 보니까 어느새 앱이 비대해져서 프로젝트를 쉽게 마무리 지을 수 없게 되었다. 결국, 한 달 조금 넘는 기간 동안 프로젝트를 진행했고 이 프로젝트 동안 그래도 나름 새로운 것들을 공부하려고 큰 노력을 했다.</p><p>프로젝트는 Ivy Lee Method를 구현한 애플리케이션이었다. 이 <a href="https://github.com/6-things-must-to-do?type=source">링크</a>에서 프로젝트의 자세한 소스코드와 문서를 확인할 수 있다.</p><p><img src="/images/2020-12-30-20201230/01.png"><br><img src="/images/2020-12-30-20201230/02.png"><br><small> 약 한 달 동안 많은 코드를 짰다 </small></p><p>이 프로젝트에서 Go와 DynamoDB를 한번 써봐야겠다고 생각하고 (DynamoDB는 지난번에 맛보기처럼 사용한 적이 있는데, 익숙하지 않아 많이 당황하고 메인 데이터베이스로 쓸 수 있는 거 맞나 싶은 생각도 했었다. <a href="https://changhoi.github.io/posts/serverless/serverless-cronjob-crawler-demo/">처음 DynamoDB를 맛보고 남겼던 글</a>도 있다) 그 이후로 여러 레퍼런스를 찾아보고, 특히 이번 학기에 <a href="https://changhoi.github.io/posts/backend/dynamodb-single-table-design/">이 독특한 구조의 데이터베이스는 어떻게 설계해야 할까에 대한 고민을 많이 하고 공부한 글</a>도 남겼다. 그래도 만들면서 “복잡한 관계를 설정하기는 여전히 어렵군” 하면서 만들었던 기억이 있다.</p><p>필자는 꼭 학생으로서 받을 수 있는 많은 지원을 최대한 받으며 직접 창업에 도전해보고 싶다는 생각을 오래전부터 하고 있었기 때문에, 이번 학기에 아이디어 MVP를 한 번 빌드해 봐야겠다고 생각했는데, 하고 싶던 아이디어가 노코드 앱처럼 일반적인 케이스가 아니라서 직접 만들어야 했다. 계획은 학기와 그 MVP 만들기를 병행할 계획이었으나, 현실은 이 수업에 묶여서 아예 생각하지 않았던 앱을 만들어냈다.</p><hr><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>2019년에 작성했던 회고도 한 번 읽어봤다. 지금도 항상 비슷하지만, 필자가 봐 왔던 어떤 n년차 개발자를 기준으로, 내가 n년차가 되면 저분보다 더 잘 할 수 있을까에 대한 기대와 걱정이 항상 있었다. 처음 개발을 공부한 지 1년 되는 해에는 “당연히 가능하지, 지금 이 속도면 어떻게 불가능하겠어” 같은 느낌이 정말 컸지만, 최근에는 성장 속도가 이전에 비해 느려진 것 같다는 생각도 하게 된다. 아마도 개인적으로 경험해볼 수 있는 시나리오의 한계가 있어서 그렇겠다고 생각은 하고 있고, 그래서 가을 학기가 시작할 때쯤엔 오히려 공학 이론이나 알고리즘과 같은 기본기에 충실해져야겠다고 생각해서, 수업에 집중했던 것 같다. 결과적으로 내가 튼튼한 개발자가 되었는가? 그것에 대해서는 잘 모르겠다, 단시간에 해결되지는 않는 것 같고, 더 집중적으로 공부해야 할 것 같다.</p><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>2020년 말에 교수님의 도움으로 창업 할 수 있는 사무실을 받게 되었다. 그리고 소프트웨어공학 수업에서 팀으로 만난 친구와 개발하는 친구, 디자인하는 친구 이렇게 4명이 같이 창업을 하기로 했다. 기대도 되고 걱정도 많고, 괜히 일을 벌여놓으려니까 감당 할 수 있나 싶기도 한데, 어차피 졸업 전에는 꼭 해보고 싶었던 거니까 올해는 데이터베이스, 알고리즘, 창업, 이 세 가지에 몰빵 해보는 거로 결정했다.</p>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/logs/">logs</category>
      
      
      <category domain="https://changhoi.github.io/tags/log/">log</category>
      
      <category domain="https://changhoi.github.io/tags/retrospect/">retrospect</category>
      
      
      <comments>https://changhoi.github.io/posts/logs/20201230/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>어떤 글을 써야 잘 썼다고 소문이 날까</title>
      <link>https://changhoi.github.io/posts/essay/what-post-is-good-post/</link>
      <guid>https://changhoi.github.io/posts/essay/what-post-is-good-post/</guid>
      <pubDate>Wed, 11 Nov 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;최근에 열심히 공부한 내용을 바탕으로 기존 글과 다르게, 많은 노력을 들이며 ‘좋은 글 쓰기가 뭘까?’ 생각하면서 나름 열심히 &lt;a href=&quot;/posts/backend/dynamodb-single-table-design/&quot;&gt;글을 작성&lt;/a&gt;한 적이 있는데, 쓰던 버릇도 있고… 시간 투자에 대한 부담도 있어서 다시 원래 내가 보기 위한 글을 썼던 기존과 비슷한 느낌이 나는 글을 썼다. &lt;/p&gt;
&lt;p&gt;글을 쓴 다음 블로그 애널리틱스를 확인하게 되었는데, 과거와 다르게 많은 글들이 올라가 있어서 그런지, 생각보다는 많은 사람들이 블로그를 구경하고 가신다는 걸 알게 되었다. 본인도 리서치 하면서, 저질의 글을 보면 썩 좋지 않기 때문에, 조금씩 글의 질에 신경을 많이 써야 할 것 같다고 생각했다. 필자 역시 아티클을 자주 검색해 보는 편인데, 그 중에서 확실히 선호하는 느낌의 글을 자주 보던 블로그들을 확인해보고 어떤 점이 좋은 글 느낌을 내는지 고민해봤다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>최근에 열심히 공부한 내용을 바탕으로 기존 글과 다르게, 많은 노력을 들이며 ‘좋은 글 쓰기가 뭘까?’ 생각하면서 나름 열심히 <a href="/posts/backend/dynamodb-single-table-design/">글을 작성</a>한 적이 있는데, 쓰던 버릇도 있고… 시간 투자에 대한 부담도 있어서 다시 원래 내가 보기 위한 글을 썼던 기존과 비슷한 느낌이 나는 글을 썼다. </p><p>글을 쓴 다음 블로그 애널리틱스를 확인하게 되었는데, 과거와 다르게 많은 글들이 올라가 있어서 그런지, 생각보다는 많은 사람들이 블로그를 구경하고 가신다는 걸 알게 되었다. 본인도 리서치 하면서, 저질의 글을 보면 썩 좋지 않기 때문에, 조금씩 글의 질에 신경을 많이 써야 할 것 같다고 생각했다. 필자 역시 아티클을 자주 검색해 보는 편인데, 그 중에서 확실히 선호하는 느낌의 글을 자주 보던 블로그들을 확인해보고 어떤 점이 좋은 글 느낌을 내는지 고민해봤다.</p><span id="more"></span><h2 id="과거에-자기-만족을-위해-쓰던-글"><a href="#과거에-자기-만족을-위해-쓰던-글" class="headerlink" title="과거에 자기 만족을 위해 쓰던 글"></a>과거에 자기 만족을 위해 쓰던 글</h2><p>블로그를 시작한 이유 중 가장 큰 이유는, 내가 공부한 내용을 어떤 공간에 정리를 하고 싶다는 것이었다. 깃헙 TIL 레포지토리, Notion 처럼 개인적인 공간에 작성한 적도 있지만, 작성하다 보니 이왕이면 누군가에게 피드백 받을 수 있는 공간이면 좋지 않을까 싶은 생각에 블로그를 만들게 되었다. </p><p>여러 블로그 서비스를 사용하지 않은 이유는 기록 자체를 마크다운 형태로 가지고 있고 싶었기 때문이었다. 그런 요구사항때문에 자연스럽게 깃헙 블로그를 사용하게 되었다. 근본적으로 본인의 만족과 효용을 타겟으로 글을 쓰다 보니 가장 큰 목표는 공부했던 내용을 천천히 정리하는 것과, 나중에 봤을 때 ‘아 이게 이랬지’ 하는 효과를 느끼도록 글을 쓰는 것이었다. 그 결과로 지금 다시 글을 보면서 느껴지는 점은, 많은 블로그 글들이 나에게만 읽기 쉬운 경우가 많았다. 타인이 보기엔 지나치게 듬성듬성하지 않았을까 싶다.</p><h2 id="블로그-방문자의-점진적-증가"><a href="#블로그-방문자의-점진적-증가" class="headerlink" title="블로그 방문자의 점진적 증가"></a>블로그 방문자의 점진적 증가</h2><p>블로그 글을 쓴지는 대충 일년 정도가 되었는데, 그래도 나름 짜잘한 내용의 포스트를 여러 개 올려서 그런지, 점진적으로 블로그 방문자들이 증가하고 있다.</p><p><img src="/images/2020-11-12-what-post-is-good-post/01.png"><br><small>신기함을 느끼는 중</small></p><p>부끄럽지만 현재 블로그에는 부실한데 부실하지 않은 척 하는 글들이 많다. 본인이 보기에는 부실하지 않겠지만, 처음 맥락을 접하는 사람들에게는 갸우뚱 할 수 있는 전개를 가진 글들이 많이 있다고 생각하는데, 보통 이런 글을 보게 되면 온전한 정보를 획득하지 못하는 경우가 많이 발생하게 된다. 글을 쓰면 사람들에게 유기적으로 전파될 정도의 퀄리티를 가진 글을 쓰고 싶다는 생각이 들어서, 평소에 어떤 아티클을 보면서 필자가 ‘좋은 글이다’ 라고 느꼈는지 고민해봤다.</p><h2 id="좋은-블로그-특"><a href="#좋은-블로그-특" class="headerlink" title="좋은 블로그 특"></a>좋은 블로그 특</h2><p>좋은 블로그는 사실 아주 많다. 그 중에서도 아주 개인적인 기준으로 만족감이 높았던 블로그 특징이 뭐가 있을까 고민해 보면서 (개인적이지만, 커뮤니티에서 공유되는 횟수를 봤을 때 객관적이라고 생각된다.) 느꼈던 것들을 정리했다.</p><h3 id="evan-moon-블로그"><a href="#evan-moon-블로그" class="headerlink" title="evan-moon 블로그"></a><a href="https://evan-moon.github.io/">evan-moon 블로그</a></h3><p>Evan Moon이라는 이름으로 블로그를 운영하시는 개발자 개인 블로그인데, 이곳에 올라오는 글을 빠지지 않고 보는 편이다. 이 블로그 글을 읽으면 읽기 편하고 부담스럽지 않다고 생각 된다. 왜 그런 생각을 하게 되었을까?</p><p><img src="/images/2020-11-12-what-post-is-good-post/02.png"><br><small>evan-moon.github.io 블로그의 최근 글</small></p><p>이 블로그와 포스트를 보면 항상 생각 나는 점은 깔끔한 블로그 모습과 UI와 중간 중간 끼워져 있는 위와같은 여담 또는 적절한 이미지 배치이다. 실제로 굳이 필요한 이미지가 아니더라도 글 흐름상 읽는 텀을 만들어주고 다음 문장을 읽으로 가기 편하게 만들어준다.</p><p>또 이 글을 쓰면서 느꼈는데, 폭보다 좁은 이미지의 가운데 정렬이라든지, 이미지 설명을 가운데 정렬 한다든지, 이미지에 <code>border-radius</code>가 적용되어있는 것 등이 깔끔하고 읽으면서나 글을 작성 하면서 불편함을 느끼지 않게 해줄 수 있을 것 같다고 생각이 들었다.</p><p>마지막으로 기술적인 내용에 대해서 전개가 아주 적절하다고 느꼈다. 예를 들어서 3만명이 읽었다고 하는 <a href="https://evan-moon.github.io/2020/05/21/about-cors/"><code>CORS는 왜 이렇게 우리를 힘들게 하는걸까?</code></a> 글은 글쓴이가 겪은 스토리를 앞서 간단하게 보여면서 시작하고, CORS가 무엇인지 등 정말 기본적인 내용, 그리고 문제 해결을 위한 보다 근본적인 동작 방식, 마지막으로 본격 문제 해결하는 방법. 이런 식으로 구성되어있다.</p><p><img src="/images/2020-11-12-what-post-is-good-post/03.png"></p><p>떠올리기 힘들다거나 시도하지 못할 구성이라는 건 아니지만, 저런 구성 역시 앞서 고민을 한 후에 적용할 수 있는 방법일 것 같다. 본인은 이런 구성에 대한 부분을 크게 신경 쓰면서 글을 쓰지 못 하고 있었기 때문에… 어느 정도 반성이 되는 성찰이었다.</p><h3 id="jbee-블로그"><a href="#jbee-블로그" class="headerlink" title="jbee 블로그"></a><a href="https://jbee.io/">jbee 블로그</a></h3><p>유우명한 블로그 중에 하나인 jbee님 개인 블로그 글은 아주 적당한 마크다운 문법이 자주 사용되는 걸 자주 봤다. 지금 글처럼 소주제에 맞게 <code>###</code> 하는 거 외에도 여러 방법으로 문단을 나누고 내용을 보여준다. 읽기에 불편함이 없을 정도로 문단을 구성하고 새로운 형태로 글이 보여지게 만들면, 글을 읽는 입장에서 조금 더 쉽게 읽혀지는 것 같다. </p><blockquote><p>이와 유사한 현상은 Evan moon님 블로그에서도 느껴졌었다.</p></blockquote><p><img src="/images/2020-11-12-what-post-is-good-post/04.png"><br><small>이렇게 귀여운 썸네일은 직접 만드시는 걸까</small></p><p>위는 정말 정말 마음에 드는 썸네일인데 내용과 상관은 없지만, 비모를 사용한 게 제대로 취저인 썸네일이었다. 아, 비모 얘기도 사실이지만, 썸네일에 들이는 공도 고민해볼만 했다. 사실 본인은 썸네일에 큰 노력을 들이는 편이 아니다. 그냥 있던 이미지이거나(현재 글) 흔히 구글에서 사용되던 이미지를 찾아서 사용하는 편이다. 가끔 정말 아키텍쳐 모습이라든지, 그려서 만든 적은 있는데… 본인 만족을 위해 써오던 글에서 썸네일에 공을 들이는 경우는 거의 없었던 것 같다.</p><p>두 개인 블로그 모두 공교롭게도 Gatsby를 사용하고 있다. 현재 블로그에서 큰 불편함을 느끼거나, 옮겨타고 싶은 욕구가 솟지는 않지만, 왜 그러셨는지 조사해볼만 할 것 같다. 현재 사용 중인 테마도 Evan moon님이 사용하시던 테마였는데, 너무 깔끔해보여서 따라 선택하게 되었다. 이 테마에서 Gatsby로 옮기시게 된 까닭을 작성하셨던 적이 있었던 것 같으니 참고하고… 조금 더 깔끔한 블로그 모습을 만들 수 있을 것 같다고 생각되면 옮기는 것도 고민해봐야겠다.</p><h3 id="Toast-기술-블로그"><a href="#Toast-기술-블로그" class="headerlink" title="Toast 기술 블로그"></a><a href="https://meetup.toast.com/">Toast 기술 블로그</a></h3><p>이 기술블로그는 NHN Toast 팀이 운영하는 기술블로그이다. 정말 기술적으로 좋은 글이다 라고 느꼈던 많은 글들이 이 블로그에 있었다. 레디스 관련 글이 퍼뜩 떠오르는데, 이 글 말고도 정말 퀄리티 높은 많은 글이 있다.</p><p><img src="/images/2020-11-12-what-post-is-good-post/05.png"><br><small>이 시리즈… 정말 못 버려…</small></p><p>아무래도 개인 공부한 내용이 블로그 글의 주 타겟이 되다 보니, 특정 기술의 공식 문서를 빠르게 보고 배우는 시리즈를 작성한 경험이 많은데, 사실 최근엔 이런 식으로 정리 할 필요가 있을까 싶은 생각도 든다. 특정 기술에 한정된 경우 버전업이 되면서 자연스럽게 레거시 포스팅이 되어버리고 필자 조차도 다시 사용해야 할 경우에 이 글을 찾지 않고 새로운 내용을 확인하게 된다.</p><p>이번에 새롭게 Toast 팀이 쓰는 글을 살펴보면서, 보다 전문성이 느껴지도록, 휙휙 바뀌는 내용이 아니라 기술들이 가지고 있는 패러다임이나 컨셉을 가지고 깊은 글을 쓰면 좋겠다고 생각하게 되었다.</p><blockquote><p>이 내용은 사실 여전히 고민 중이다. 필자가 쓸 수 있는 글의 범위가 많이 줄지 않을까 하는 염려도 섞여있다.</p></blockquote><h2 id="그래서-앞으로는"><a href="#그래서-앞으로는" class="headerlink" title="그래서 앞으로는"></a>그래서 앞으로는</h2><p>여러 블로그를 다니며 성찰한 결과, 앞으로는 대충 아래와 같은 점을 유의해봐야겠다고 결심했다.</p><ul><li>글의 주제를 범용적이면서 기술이나 공학의 핵심에 가까운 내용으로 고민해보자</li><li>글의 구성을 먼저 고민하고, 입시하면서 썼던 일반적인 논술 쓰기처럼 뼈대와 구조에 대한 부분도 많은 고민을 해야겠다.</li><li>글 자체가 여유로운 느낌, 잘 읽히는 느낌을 주기 위해 적절한 마크다운 문법과 이미지, 문단 나누기, 여담 등을 끼워 넣어 보자</li><li>블로그가 조금 더 깔끔한 글쓰기 플랫폼이 될 수 있도록 자체적인 커스텀을 해볼까 싶다. 조금 더 깔끔하고 쓰기 편하게!</li></ul><p>마지막을 제외하고는 당장 실행해볼 법 하지만, 1년간 블로그를 대하는 태도가 하루 아침에 싹 바뀌겠는가. 그리고 너무 부담을 느끼고 글 쓰는 빈도가 확 줄어들까봐 걱정스럽기도 하다. 그래도 위 정도는 할만하지 하면서 작성한 거니까… 트라이 해보자.</p><blockquote><p>이런 기술 외적인 내용을 다루는 글도 가끔 써야겠다. 카테고리는 essay</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/essay/">essay</category>
      
      
      
      <comments>https://changhoi.github.io/posts/essay/what-post-is-good-post/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DynamoDB 설계 방법: Single Table Design</title>
      <link>https://changhoi.github.io/posts/backend/dynamodb-single-table-design/</link>
      <guid>https://changhoi.github.io/posts/backend/dynamodb-single-table-design/</guid>
      <pubDate>Fri, 23 Oct 2020 15:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;NoSQL 종류 중 하나인 &lt;code&gt;DyanamoDB&lt;/code&gt;는 일반적인 SQL 테이블과 다르게, &lt;code&gt;query&lt;/code&gt;를 할 때 조건을 설정할 수 있는 대상이 &lt;code&gt;Partition Key&lt;/code&gt; (이하 &lt;code&gt;PK&lt;/code&gt;)와 &lt;code&gt;Sort Key&lt;/code&gt; (이하 &lt;code&gt;SK&lt;/code&gt;) 그리고 추가적으로는 &lt;code&gt;Global Secondary Index&lt;/code&gt; (이하 &lt;code&gt;GSI&lt;/code&gt;)와 &lt;code&gt;Local Secondary Index&lt;/code&gt;(이하 &lt;code&gt;LSI&lt;/code&gt;)로 구분되는 Secondary Index로 한정된다. 다른 속성 필드에 대해서는 쿼리 조건을 설정할 수 없다. 만약 다른 속성에 대해 결과를 보려면 &lt;code&gt;scan&lt;/code&gt;을 사용해야 한다. &lt;code&gt;scan&lt;/code&gt;은 테이블의 모든 데이터를 조회하기 때문에 성능면에서 좋지 않은 모습을 보여준다. 이러한 특성이 있어서, DynamoDB 테이블은 일반적으로 SQL 테이블을 만들듯 만들면 안 된다. 이 글은 AWS에서 공식적으로 추천하고 있는 &lt;code&gt;Single Table&lt;/code&gt; 구조로 설계하는 방법에 대해서 다루고 있다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>NoSQL 종류 중 하나인 <code>DyanamoDB</code>는 일반적인 SQL 테이블과 다르게, <code>query</code>를 할 때 조건을 설정할 수 있는 대상이 <code>Partition Key</code> (이하 <code>PK</code>)와 <code>Sort Key</code> (이하 <code>SK</code>) 그리고 추가적으로는 <code>Global Secondary Index</code> (이하 <code>GSI</code>)와 <code>Local Secondary Index</code>(이하 <code>LSI</code>)로 구분되는 Secondary Index로 한정된다. 다른 속성 필드에 대해서는 쿼리 조건을 설정할 수 없다. 만약 다른 속성에 대해 결과를 보려면 <code>scan</code>을 사용해야 한다. <code>scan</code>은 테이블의 모든 데이터를 조회하기 때문에 성능면에서 좋지 않은 모습을 보여준다. 이러한 특성이 있어서, DynamoDB 테이블은 일반적으로 SQL 테이블을 만들듯 만들면 안 된다. 이 글은 AWS에서 공식적으로 추천하고 있는 <code>Single Table</code> 구조로 설계하는 방법에 대해서 다루고 있다.</p><span id="more"></span><h2 id="DynamoDB와-RDBS-설계의-차이점"><a href="#DynamoDB와-RDBS-설계의-차이점" class="headerlink" title="DynamoDB와 RDBS 설계의 차이점"></a>DynamoDB와 RDBS 설계의 차이점</h2><p>전통적으로 SQL 데이터베이스에서 테이블을 설계할 때, 스키마를 디자인하고, 데이터를 정규화 한 다음 사용하면서 필요한 쿼리를 작성하게 된다. AWS에서는 이 순서를 뒤집어 생각해야 한다고 설명한다.</p><p>다시 말해서 사용하게 될 쿼리들에 대해서 테이블을 만들기 전에 알고 있어야 한다는 뜻이다. 그래야 위에서 언급한 <code>scan</code>과 <code>filter</code>를 사용하는 것을 최소화 할 수 있게 된다. 또한, <code>GSI</code>는 테이블이 만들어진 이후에도 추가 또는 삭제가 가능하지만, <code>LSI</code>는 테이블이 만들어질 때 설정 해줘야 한다는 이유도 있다.</p><p>또한 AWS는 <code>Single Table</code>형태로 DynamoDB 테이블을 설계할 것을 추천한다. SQL 데이터베이스를 설계할 때는 보통 여러 테이블에 데이터를 나눠 담고, 관계에 따라 <code>Relation</code>을 설정한다. 데이터를 쿼리 할 때는 적절하게 <code>Join</code>하는 방식으로 데이터를 가져오게 된다. 이 방식은 개발자 입장에서 개발의 편리함을 주지만, 성능면에서 비용이 있는 방식이다. 하지만 DynamoDB는 SQL처럼 <code>Join</code>을 기본적으로 지원해주지 않는다. 즉, 일반적으로 SQL 테이블처럼 테이블을 나누기 시작하면, 복잡한 쿼리를 사용해야 할 때 여러 번의 쿼리를 사용해야 한다는 뜻이다. 이는 RDS보다 더 큰 비용을 감수해야 하는 샘이다.</p><h2 id="배경-지식"><a href="#배경-지식" class="headerlink" title="배경 지식"></a>배경 지식</h2><p>간단하게 Primary Key와 Secondary Index에 대해 확인해보자.</p><blockquote><p>글 전체에서 Primary Key는 줄이지 않고 사용했다. Partition Key는 <code>PK</code>로 줄여 사용했다. 마찬가지로 Secondary Index는 줄이지 않고 사용하고, Sort Key는 <code>SK</code>로 줄여 표현했다.</p></blockquote><h3 id="Primary-Key"><a href="#Primary-Key" class="headerlink" title="Primary Key"></a>Primary Key</h3><p>Primary Key는 항목을 나타내는 고유 식별자가 되어야 하며, 두 아이템이 동일한 키를 가질 수는 없다. DynamoDB에서 Primary Key는 단일한 <code>PK</code>, 또는 <code>PK</code>와 <code>SK</code>로 구성될 수 있다. </p><p>Primary Key라는 조건때문에 단일 <code>PK</code>로 이루어진 경우는 아이템마다 다른 <code>PK</code>를 보장해야 하지만, <code>SK</code>와 함께 Primary Key를 구성한다면, 중복된 <code>PK</code>가 존재해도 된다. <code>PK</code>와 <code>SK</code>가 함께 사용된 Primary Key를 <code>Composite primary key</code>라고 하고, 이 경우에는 <code>PK</code>와 <code>SK</code>에 의해 항목이 구분될 수 있어야 한다.</p><p>DynamoDB는 <code>PK</code>의 해시 값을 계산해, 항목을 저장할 파티션을 결정한다. 동일한 <code>PK</code>를 가질 수 있고, 같은 값에 대해서는 같은 파티션에 <code>SK</code>의 오름차순으로 저장하게 된다.</p><h3 id="Secondary-Index"><a href="#Secondary-Index" class="headerlink" title="Secondary Index"></a>Secondary Index</h3><p>보조 인덱스라고 문서에 해석되어있지만, 글에서는 Secondary Index로 사용했다. 기본적으로 쿼리를 위해 <code>PK</code>와 <code>SK</code>를 사용하게 되지만, Secondary Index를 추가해 사용할 수 있게 된다. DynamoDB는 다음 두 가지 형태의 Secondary Index를 지원하고 있다.</p><table><thead><tr><th align="center">Global Secondary Index (<code>GSI</code>)</th><th align="center">Local Secondary Index (<code>LSI</code>)</th></tr></thead><tbody><tr><td align="center"><code>PK</code>와 <code>SK</code>로 구성되고, 기존 테이블과 달라도 된다.</td><td align="center">테이블과 같은 <code>PK</code>를 사용하지만, 다른 <code>SK</code>를 사용하게 할 수 있다.</td></tr><tr><td align="center">할당량 30개</td><td align="center">할당량 5개</td></tr><tr><td align="center">테이블 사용 중에 추가나 삭제 가능</td><td align="center">테이블 만들 때만 생성이 가능하고 중간 삭제도 할 수 없음</td></tr></tbody></table><h2 id="Single-Table-Design"><a href="#Single-Table-Design" class="headerlink" title="Single Table Design"></a>Single Table Design</h2><h3 id="설계-방식"><a href="#설계-방식" class="headerlink" title="설계 방식"></a>설계 방식</h3><p><code>Single Table</code>은 관계가 있는 테이블을 하나로 관리하는 것을 의미한다. 이 방법은 관계가 있는 테이블을 <code>pre-join</code> 하는 방법으로써 SQL 테이블 설계 할 때처럼 DynamoDB를 설계하면 나타날 수 있는 문제를 해결한 것으로 볼 수 있다. <code>Single Table</code>을 설계하는 과정은 다음과 같다.</p><ol><li>SQL 설계 하듯, 일반적인 <a href="https://ko.wikipedia.org/wiki/%EA%B0%9C%EC%B2%B4-%EA%B4%80%EA%B3%84_%EB%AA%A8%EB%8D%B8">ERD</a>를 설계한다.</li><li>데이터 접근 패턴을 정의한다.</li><li><strong>Primary Key</strong>와 <strong>Secondary Indexes</strong>을 디자인 한다.</li></ol><p>위 순서에서, <strong>3 번</strong>의 경우, <code>PK</code>와 <code>SK</code>를 합쳐서 Primary Key를 구성하게 되는데, 이때 여러 테이블이 <code>pre-join</code> 되어있다고 봐야 하기 때문에,  <code>PK</code>와 <code>SK</code>를 디테일한 이름을 가진 필드로 두지 말고 아주 일반적인 이름을 사용할 것을 권장한다. 그렇게 설계한 뒤 <code>PK</code>와 <code>SK</code>를 통해 어떤 Entity에 접근 하고 있는 건지 구분 할 수 있게 해야 한다. 자세한 예시를 확인해보자</p><h3 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h3><p>2019 AWS re:invent에서 들어준 예시를 확인해보자. E-commerce 서비스를 위해 <code>User</code>와 <code>Order</code>테이블을 설계하는 예시이다.</p><blockquote><p>실제로는 아래 예시에서 조금 더 나아가 Filtering Pattern에 대해서도 다룬다. 정말 정리 해두고 싶은 내용이지만, 글 분량이 너무 길어지고 적당하게 잘 정리할 수 있을지 모르겠어서 생략했다.</p></blockquote><ol><li><p>먼저 ERD 정의를 해줘야 한다. ERD를 정의는 다음과 같이 했다.<br><img src="/images/2020-10-24-dynamodb-single-table-design/01.png"></p></li><li><p>다음은 데이터 접근을 어떻게 할지 미리 정의해야 한다. 예시에서 애플리케이션에서 다음과 같은 접근 패턴을 갖고 있다고 가정해보자.</p><ul><li>User Profile 가져오기</li><li>User에 대한 Order 리스트 가져오기</li><li>단일한 Order와 그에 대한 Order Items를 가져오기</li></ul></li><li><p><strong>Primary Key</strong>와 <strong>Secondary Indexes</strong>를 설계할 차례이다. 위에서 말한 것 처럼 일반적인 이름으로 <code>PK</code>와 <code>SK</code>를 만들고, 두 값으로 어떤 Entity에 접근하는지 구분할 수 있게 설계한다.</p></li></ol><p><img src="/images/2020-10-24-dynamodb-single-table-design/02.png"><br><small>데이터 예시</small></p><p>위 데이터는 <code>users</code>, <code>user_address</code>, <code>orders</code> 관계를 일부 반영한 모습이다. ERD와 설계한 접근 패턴을 반영했는지 확인해보자. </p><p>Primary Key는 <code>PK</code>와 <code>SK</code>로 구성되고, <code>PK</code>는 <code>USER#username</code>, <code>SK</code>는 <code>#PROFILE#username</code> 또는 <code>ORDER#orderId</code> 형태로 구성되고 있다. 이렇게 패턴을 정의해서 어떤 Entity에 접근하는 건지 구분 할 수 있게 만들면 된다.</p><p><code>user_address</code>는 1:N 관계지만, <code>user_address</code> 자체를 <code>PK</code>또는 <code>SK</code>로 쿼리 해야하는 경우는 없다. (예를 들어서, 주소를 기반으로 유저를 검색하거나, 주소에 따라 유저들을 가져오는 쿼리는 필요가 없다.) 따라서 비정규화 + Document 타입의 <code>Address</code>라는 이름으로 필드에 추가된 모습이다. 다만 <code>Address</code>는 Orders의 필드로서의 역할도 한다. 두 경우는 다른 모습을 가질 수 있다.</p><p><code>orders</code>와 <code>users</code>도 마찬가지로 1:N 관계이다. 다만 위와 다르게 Order에 따른 쿼리가 필요하다. 따라서, <code>PK</code>와 <code>SK</code>로 User에 따라 Order 리스트를 쿼리할 수 있어야 한다. 예를 들면 아래와 같이 쿼리할 수 있게 된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PK = USER#alexdebrie AND BEGIN_WITH(SK, &#x27;ORDER#&#x27;)</span><br></pre></td></tr></table></figure><p>위 쿼리로 유저에 대한 Order 리스트를 가져올 수 있게 된다.</p><hr><p>지금까지 설계된 테이블은 아래 모습을 갖췄다. 하지만 아직 <code>orders</code>와 <code>order_items</code> 관계는 설계되기 전 모습이다.</p><p><img src="/images/2020-10-24-dynamodb-single-table-design/03.png"></p><p>Order에 따라서 Item을 가져오지 못하므로 남은 부분들을 고려해 테이블을 설계해보자. <code>orders</code>와 <code>order_items</code>의 관계를 살펴보면, 마찬가지로 1:N 관계이다. 그리고 단일한 Item 조회를 해야 한다는 점을 반영해 아래와 같이 <code>PK</code> 패턴을 정의해 넣을 수 있다.</p><p><img src="/images/2020-10-24-dynamodb-single-table-design/04.png"></p><p>결과적으로 Entity를 아래 이미지 처럼 설계하게 되었는데, 이때 관계에 따라 동일한 패턴을 <code>PK</code>또는 <code>SK</code>로 쓰게 하는 것이 중요한 핵심이고, 이 방식으로 설계 해야 <code>Join</code> 하는 것과 같은 효과를 가질 수 있다.</p><p><img src="/images/2020-10-24-dynamodb-single-table-design/05.png"></p><p>지금까지 진행된 설계의 문제는 Order를 기준으로 데이터를 가져오는게 불가능하다는 점이다. <code>PK</code>에서 Order를 쿼리할 수 없기 때문인데, 이를 해결하기 위해서 <strong>Secondary Index</strong>를 설정해보자.</p><p>이번 예시에서는 <code>Inverted Index</code>라고 불리는 전략을 소개한다. 이 전략은 말 그대로 <code>PK</code>와 <code>SK</code>를 뒤집은 Primary Key를 <code>GSI</code>로 만드는 것이다.</p><p><img src="/images/2020-10-24-dynamodb-single-table-design/06.png"></p><p>위와 같은 <code>GSI</code>를 만들면, Order를 쿼리 했을 때, 두 가지 타입의 Entity에 바로 접근이 가능해지는데, Order에 따른 Item 리스트와, Order의 User를 가져오게 된다. 이렇게 데이터를 쿼리하면 <code>orders</code>에 <code>users</code>와 <code>order_items</code>를 조인한 것과 같은 결과를 갖게 된다.</p><hr><p>위 예시를 정리해 보자면 ERD에서 1:N 관계로 설계 했을 때, DynamoDB의 테이블을 설계하는 패턴들에 대해서 다루고 있다.</p><ol><li>Denormalizing + Attributes화 하기 (<code>user_address</code>와 <code>users</code>)</li><li>Primary Key로 구성해서 쿼리 (<code>users</code>와 <code>orders</code>)</li><li>Secondary Index를 구성해서 쿼리 (<code>orders</code>와 <code>order_items</code>)</li></ol><p>미리 두 번째 단계에서 설계했던 접근 패턴에 대해서 이제 다음과 같은 쿼리 형태로 접근할 수 있게 됐다. (나타낸 코드는 실제 코드가 아닌 의사코드이다.)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- User Profile 가져오기</span><br><span class="line">  PK = USER#alexdebrie AND SK = #PROFILE#alexdebrie</span><br><span class="line">- User에 대한 Order 리스트 가져오기</span><br><span class="line">  PK = USER#alexdebrie AND BEGINS_WITH(SK, &#x27;ORDER#&#x27;)</span><br><span class="line">- 단일한 Order와 그에 대한 Order Items를 가져오기</span><br><span class="line">  SK = ORDER#orderId AND BEGIN_WITH(PK, &#x27;ITEM#&#x27;)</span><br></pre></td></tr></table></figure><h2 id="Single-Table-Design의-한계"><a href="#Single-Table-Design의-한계" class="headerlink" title="Single Table Design의 한계"></a>Single Table Design의 한계</h2><p><code>Single Table Design</code>은 DynamoDB에 아주 적합한 설계 방식이지만, 몇 가지 한계점이 있다.</p><p>우선 가장 큰 문제는 필요한 쿼리를 미리 알고 있어야 한다는 점이고, 새로운 접근 방식을 정의해야 하는 경우에 어려움이 따를 수 있다는 점이다.</p><p>그리고 설계에 있어서 유연성이 떨어지는 점도 있다. 특히 <code>LSI</code>는 한 번 만들어지고 나면 수정이 되지 않기 때문에 여러 테이블을 모아놓은 하나의 테이블의 설계가 적합하지 않는 경우에 수정이 어렵다. 또한 이 방법 자체에 대한 이해와 적용이 까다롭다는 점도 한계라고 볼 수 있을 것 같다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.alexdebrie.com/posts/dynamodb-single-table/">The What, Why, and When of Single-Table Design with DynamoDB</a></li><li><a href="https://medium.com/@nabtechblog/advanced-design-patterns-for-amazon-dynamodb-c31d65d2e3de">Advanced Design Patterns for Amazon DynamoDB</a></li><li><a href="https://www.coursera.org/learn/dynamodb-nosql-database-driven-apps/lecture/Zhkb1/single-table">Single Table - Week 4 | Coursera</a></li><li><a href="https://www.youtube.com/watch?v=DIQVJqiSUkE&feature=youtu.be&t=831&ab_channel=AWSEvents">AWS re:Invent 2019: Data modeling with Amazon DynamoDB (CMY304) - YouTube</a></li><li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html">AWS DynamoDB Docs: Core Components of Amazon DynamoDB</a></li><li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html">AWS DynamoDB Docs: Partitions and Data Distribution</a></li><li><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/SecondaryIndexes.html">AWS DynamoDB Docs: Improving Data Access with Secondary Indexes</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://changhoi.github.io/categories/backend/">backend</category>
      
      
      <category domain="https://changhoi.github.io/tags/serverless/">serverless</category>
      
      <category domain="https://changhoi.github.io/tags/dynamodb/">dynamodb</category>
      
      <category domain="https://changhoi.github.io/tags/database/">database</category>
      
      <category domain="https://changhoi.github.io/tags/architecture/">architecture</category>
      
      
      <comments>https://changhoi.github.io/posts/backend/dynamodb-single-table-design/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
